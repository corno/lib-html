"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$$ = void 0;
const pi = __importStar(require("pareto-core-internals"));
const createContainingDirectories_native_1 = require("../native/createContainingDirectories.native");
const joinPath_native_1 = require("../native/joinPath.native");
const n_fs = __importStar(require("fs"));
const $$ = () => {
    return {
        'construct': ($is) => ($) => {
            const overwrite = $['overwrite if exists'];
            const joinedPath = (0, joinPath_native_1.joinPath)($.path);
            function createError(errcode, message) {
                switch (errcode) {
                    case 'ENOENT': return ['no entity', null];
                    case 'EISDIR': return ['is directory', null];
                    default: {
                        console.error(`CORE: DEV TODO: ADD THIS OPTION TO pareto-filesystem WRITEFILE: ${message}`);
                        return ['unknown', { message: message }];
                    }
                }
            }
            let stream = ['pending', []];
            function init() {
                const queue = stream[0] === 'pending'
                    ? stream[1]
                    : [];
                //trycatch is most likely not necessary, errors will be sent to the error stream I think
                // try {
                //     stream = ['initialized', n_fs.createWriteStream(joinedPath, {
                //         'encoding': "utf-8",
                //         'flags': $['overwrite if exists'] ? "w" : "wx"
                //     })]
                // } catch (e) {
                //     //FIXME make sure that the error is thrown because the file already exists
                //     stream = ['failed', null]
                // }
                stream = ['initialized', n_fs.createWriteStream(joinedPath, {
                        'encoding': "utf-8",
                        'flags': $['overwrite if exists'] ? "w" : "wx"
                    })];
                if (stream[0] === 'initialized') {
                    const str = stream[1];
                    str.on('error', ($) => {
                        //must the stream be set to failed? I think not, otherwise I cannot end it
                        //stream = ['failed', null]
                        const errcode = $.message.split(":")[0];
                        if (errcode === undefined) {
                            pi.panic(`unknown error: ${$.message}`);
                        }
                        if (errcode === "EEXIST") {
                            if (overwrite) {
                                console.error("Did not expect an EEXIST error");
                            }
                        }
                        else {
                            $is.onWriteFileError({
                                'error': createError(errcode, $.message),
                                'path': joinedPath,
                            });
                        }
                    });
                    queue.forEach(($) => {
                        str.write($);
                    });
                }
            }
            if ($['create containing directories']) {
                (0, createContainingDirectories_native_1.createContainingDirectories)(joinedPath, () => {
                    init();
                }, ($) => {
                    $is.onWriteFileError({
                        'error': $,
                        'path': joinedPath,
                    });
                });
            }
            else {
                init();
            }
            return {
                'data': ($) => {
                    switch (stream[0]) {
                        case 'failed':
                            //drop the data
                            break;
                        case 'initialized':
                            stream[1].write($);
                            break;
                        case 'pending':
                            stream[1].push($);
                            break;
                        default: pi.au(stream[0]);
                    }
                },
                'end': () => {
                    if (stream[0] === 'initialized') {
                        stream[1].end();
                    }
                },
            };
        }
    };
};
exports.$$ = $$;
