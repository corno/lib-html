import * as pt from 'pareto-core-types';
export declare namespace N {
    namespace Arguments {
        namespace N {
            namespace D {
                namespace N { }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace AsynchronousInterface {
        namespace N {
            namespace TU {
                namespace N {
                    namespace choice {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace options {
                                        namespace N {
                                            namespace D {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace method {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace data {
                                        namespace N {
                                            namespace O {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace _$linterface {
                                        namespace N {
                                            namespace O {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace reference {
                        namespace N { }
                        namespace T { }
                    }
                    namespace streamconsumer {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace data {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace end {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace AsynchronousInterfaceReference {
        namespace N {
            namespace G {
                namespace N {
                    namespace context {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace _$limport {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace glossary {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace local {
                                        namespace N {
                                            namespace G {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace interfaceXX {
                        namespace N { }
                        namespace T { }
                    }
                    namespace type_$_$arguments {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace DataOrSynchronousInterface {
        namespace N {
            namespace TU {
                namespace N {
                    namespace data {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$linterface {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace DataSpecifier {
        namespace N {
            namespace TU {
                namespace N {
                    namespace glossary_$_$parameterXX {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$ltype {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace context {
                                        namespace N {
                                            namespace TU {
                                                namespace N {
                                                    namespace _$limport {
                                                        namespace N {
                                                            namespace G {
                                                                namespace N {
                                                                    namespace glossary {
                                                                        namespace N { }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                    namespace local {
                                                        namespace N {
                                                            namespace G {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace tailXX {
                                        namespace N {
                                            namespace A {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace type_$_$arguments {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace typeXX {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace type_$_$parameterXX {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Dummy {
        namespace N {
            namespace G {
                namespace N { }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Glossary {
        namespace N {
            namespace G {
                namespace N {
                    namespace asynchronous {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace algorithms {
                                        namespace N {
                                            namespace D {
                                                namespace N {
                                                    namespace G {
                                                        namespace N {
                                                            namespace parameters {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                            namespace _$ltype {
                                                                namespace N {
                                                                    namespace TU {
                                                                        namespace N {
                                                                            namespace _$lconstructor {
                                                                                namespace N {
                                                                                    namespace G {
                                                                                        namespace N {
                                                                                            namespace downstreams {
                                                                                                namespace N {
                                                                                                    namespace D {
                                                                                                        namespace N { }
                                                                                                        namespace T { }
                                                                                                    }
                                                                                                }
                                                                                                namespace T { }
                                                                                            }
                                                                                            namespace _$linterface {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                        }
                                                                                        namespace T { }
                                                                                    }
                                                                                }
                                                                                namespace T { }
                                                                            }
                                                                            namespace _$lfunction {
                                                                                namespace N {
                                                                                    namespace G {
                                                                                        namespace N {
                                                                                            namespace _$lin {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                            namespace out {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                        }
                                                                                        namespace T { }
                                                                                    }
                                                                                }
                                                                                namespace T { }
                                                                            }
                                                                            namespace resource {
                                                                                namespace N {
                                                                                    namespace G {
                                                                                        namespace N {
                                                                                            namespace consumer {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                            namespace request {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                        }
                                                                                        namespace T { }
                                                                                    }
                                                                                }
                                                                                namespace T { }
                                                                            }
                                                                        }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace interfaces {
                                        namespace N {
                                            namespace D {
                                                namespace N {
                                                    namespace G {
                                                        namespace N {
                                                            namespace _$linterface {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                            namespace parameters {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace glossary_$_$parameters {
                        namespace N { }
                        namespace T { }
                    }
                    namespace imports {
                        namespace N { }
                        namespace T { }
                    }
                    namespace root {
                        namespace N { }
                        namespace T { }
                    }
                    namespace synchronous {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace algorithms {
                                        namespace N {
                                            namespace D {
                                                namespace N {
                                                    namespace G {
                                                        namespace N {
                                                            namespace parameters {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                            namespace _$ltype {
                                                                namespace N {
                                                                    namespace TU {
                                                                        namespace N {
                                                                            namespace _$lfunction {
                                                                                namespace N {
                                                                                    namespace G {
                                                                                        namespace N {
                                                                                            namespace callbacks {
                                                                                                namespace N {
                                                                                                    namespace D {
                                                                                                        namespace N {
                                                                                                            namespace G {
                                                                                                                namespace N {
                                                                                                                    namespace _$lin {
                                                                                                                        namespace N { }
                                                                                                                        namespace T { }
                                                                                                                    }
                                                                                                                    namespace lookups {
                                                                                                                        namespace N {
                                                                                                                            namespace D {
                                                                                                                                namespace N { }
                                                                                                                                namespace T { }
                                                                                                                            }
                                                                                                                        }
                                                                                                                        namespace T { }
                                                                                                                    }
                                                                                                                    namespace out {
                                                                                                                        namespace N { }
                                                                                                                        namespace T { }
                                                                                                                    }
                                                                                                                }
                                                                                                                namespace T { }
                                                                                                            }
                                                                                                        }
                                                                                                        namespace T { }
                                                                                                    }
                                                                                                }
                                                                                                namespace T { }
                                                                                            }
                                                                                            namespace _$lin {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                            namespace out {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                        }
                                                                                        namespace T { }
                                                                                    }
                                                                                }
                                                                                namespace T { }
                                                                            }
                                                                            namespace procedure {
                                                                                namespace N {
                                                                                    namespace G {
                                                                                        namespace N {
                                                                                            namespace _$lin {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                            namespace out {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                        }
                                                                                        namespace T { }
                                                                                    }
                                                                                }
                                                                                namespace T { }
                                                                            }
                                                                        }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace interfaces {
                                        namespace N {
                                            namespace D {
                                                namespace N {
                                                    namespace G {
                                                        namespace N {
                                                            namespace _$linterface {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                            namespace parameters {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Glossary_$_$Reference {
        namespace N {
            namespace G {
                namespace N {
                    namespace glossary {
                        namespace N { }
                        namespace T { }
                    }
                    namespace glossary_$_$arguments {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Imports {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Namespace {
        namespace N {
            namespace G {
                namespace N {
                    namespace namespaces {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace types {
                        namespace N {
                            namespace D {
                                namespace N {
                                    namespace G {
                                        namespace N {
                                            namespace parameters {
                                                namespace N { }
                                                namespace T { }
                                            }
                                            namespace _$ltype {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Parameters {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Synchronous_$_$Interface {
        namespace N {
            namespace TU {
                namespace N {
                    namespace group {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace members {
                                        namespace N {
                                            namespace D {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace method {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace data {
                                        namespace N {
                                            namespace O {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace _$linterface {
                                        namespace N {
                                            namespace O {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace reference {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace SynchronousInterfaceReference {
        namespace N {
            namespace G {
                namespace N {
                    namespace context {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace _$limport {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace glossary {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace interfaceXX {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace local {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace interfaceXX {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace type_$_$arguments {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type {
        namespace N {
            namespace TU {
                namespace N {
                    namespace array {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$lboolean {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace computed {
                        namespace N { }
                        namespace T { }
                    }
                    namespace dictionary {
                        namespace N { }
                        namespace T { }
                    }
                    namespace group {
                        namespace N {
                            namespace D {
                                namespace N {
                                    namespace G {
                                        namespace N {
                                            namespace _$ltype {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lnull {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lnumber {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace optional {
                        namespace N { }
                        namespace T { }
                    }
                    namespace reference {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$lstring {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace taggedUnion {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
}
export declare namespace T {
    namespace Arguments {
        type D<GAnnotation> = T.DataSpecifier<GAnnotation>;
    }
    type Arguments<GAnnotation> = pt.Dictionary<T.DataSpecifier<GAnnotation>>;
    namespace AsynchronousInterface {
        namespace choice {
            namespace options {
                type D<GAnnotation> = T.AsynchronousInterface<GAnnotation>;
            }
            type options<GAnnotation> = pt.Dictionary<T.AsynchronousInterface<GAnnotation>>;
        }
        type choice<GAnnotation> = {
            readonly 'options': pt.Dictionary<T.AsynchronousInterface<GAnnotation>>;
        };
        namespace method {
            namespace data {
                type O<GAnnotation> = T.DataSpecifier<GAnnotation>;
            }
            type data<GAnnotation> = [false] | [true, T.DataSpecifier<GAnnotation>];
            namespace _linterface {
                type O<GAnnotation> = T.AsynchronousInterface<GAnnotation>;
            }
            type _linterface<GAnnotation> = [false] | [true, T.AsynchronousInterface<GAnnotation>];
        }
        type method<GAnnotation> = {
            readonly 'data': [false] | [true, T.DataSpecifier<GAnnotation>];
            readonly 'interface': [false] | [true, T.AsynchronousInterface<GAnnotation>];
        };
        type reference<GAnnotation> = T.AsynchronousInterfaceReference<GAnnotation>;
        namespace streamconsumer {
            type data<GAnnotation> = T.AsynchronousInterface<GAnnotation>;
            type end<GAnnotation> = T.AsynchronousInterface<GAnnotation>;
        }
        type streamconsumer<GAnnotation> = {
            readonly 'data': T.AsynchronousInterface<GAnnotation>;
            readonly 'end': T.AsynchronousInterface<GAnnotation>;
        };
    }
    type AsynchronousInterface<GAnnotation> = [
        'choice',
        {
            readonly 'options': pt.Dictionary<T.AsynchronousInterface<GAnnotation>>;
        }
    ] | [
        'method',
        {
            readonly 'data': [false] | [true, T.DataSpecifier<GAnnotation>];
            readonly 'interface': [false] | [true, T.AsynchronousInterface<GAnnotation>];
        }
    ] | ['reference', T.AsynchronousInterfaceReference<GAnnotation>] | [
        'streamconsumer',
        {
            readonly 'data': T.AsynchronousInterface<GAnnotation>;
            readonly 'end': T.AsynchronousInterface<GAnnotation>;
        }
    ];
    namespace AsynchronousInterfaceReference {
        namespace context {
            namespace _limport {
                type glossary<GAnnotation> = T.Glossary__Reference<GAnnotation>;
            }
            type _limport<GAnnotation> = {
                readonly 'glossary': T.Glossary__Reference<GAnnotation>;
            };
            namespace local { }
            type local<GAnnotation> = null;
        }
        type context<GAnnotation> = [
            'import',
            {
                readonly 'glossary': T.Glossary__Reference<GAnnotation>;
            }
        ] | ['local', null];
        type interfaceXX<GAnnotation> = string;
        type type__arguments<GAnnotation> = T.Arguments<GAnnotation>;
    }
    type AsynchronousInterfaceReference<GAnnotation> = {
        readonly 'context': [
            'import',
            {
                readonly 'glossary': T.Glossary__Reference<GAnnotation>;
            }
        ] | ['local', null];
        readonly 'interfaceXX': string;
        readonly 'type arguments': T.Arguments<GAnnotation>;
    };
    namespace DataOrSynchronousInterface {
        type data<GAnnotation> = T.DataSpecifier<GAnnotation>;
        type _linterface<GAnnotation> = T.SynchronousInterfaceReference<GAnnotation>;
    }
    type DataOrSynchronousInterface<GAnnotation> = ['data', T.DataSpecifier<GAnnotation>] | ['interface', T.SynchronousInterfaceReference<GAnnotation>];
    namespace DataSpecifier {
        type glossary__parameterXX<GAnnotation> = string;
        namespace _ltype {
            namespace context {
                namespace _limport {
                    type glossary<GAnnotation> = T.Glossary__Reference<GAnnotation>;
                }
                type _limport<GAnnotation> = {
                    readonly 'glossary': T.Glossary__Reference<GAnnotation>;
                };
                namespace local { }
                type local<GAnnotation> = null;
            }
            type context<GAnnotation> = [
                'import',
                {
                    readonly 'glossary': T.Glossary__Reference<GAnnotation>;
                }
            ] | ['local', null];
            namespace tailXX {
                type A<GAnnotation> = string;
            }
            type tailXX<GAnnotation> = pt.Array<string>;
            type type__arguments<GAnnotation> = T.Arguments<GAnnotation>;
            type typeXX<GAnnotation> = string;
        }
        type _ltype<GAnnotation> = {
            readonly 'context': [
                'import',
                {
                    readonly 'glossary': T.Glossary__Reference<GAnnotation>;
                }
            ] | ['local', null];
            readonly 'tailXX': pt.Array<string>;
            readonly 'type arguments': T.Arguments<GAnnotation>;
            readonly 'typeXX': string;
        };
        type type__parameterXX<GAnnotation> = string;
    }
    type DataSpecifier<GAnnotation> = ['glossary parameterXX', string] | [
        'type',
        {
            readonly 'context': [
                'import',
                {
                    readonly 'glossary': T.Glossary__Reference<GAnnotation>;
                }
            ] | ['local', null];
            readonly 'tailXX': pt.Array<string>;
            readonly 'type arguments': T.Arguments<GAnnotation>;
            readonly 'typeXX': string;
        }
    ] | ['type parameterXX', string];
    namespace Dummy { }
    type Dummy<GAnnotation> = null;
    namespace Glossary {
        namespace asynchronous {
            namespace algorithms {
                namespace D {
                    type parameters<GAnnotation> = T.Parameters<GAnnotation>;
                    namespace _ltype {
                        namespace _lconstructor {
                            namespace downstreams {
                                type D<GAnnotation> = T.AsynchronousInterfaceReference<GAnnotation>;
                            }
                            type downstreams<GAnnotation> = pt.Dictionary<T.AsynchronousInterfaceReference<GAnnotation>>;
                            type _linterface<GAnnotation> = T.AsynchronousInterfaceReference<GAnnotation>;
                        }
                        type _lconstructor<GAnnotation> = {
                            readonly 'downstreams': pt.Dictionary<T.AsynchronousInterfaceReference<GAnnotation>>;
                            readonly 'interface': T.AsynchronousInterfaceReference<GAnnotation>;
                        };
                        namespace _lfunction {
                            type _lin<GAnnotation> = T.DataSpecifier<GAnnotation>;
                            type out<GAnnotation> = T.DataSpecifier<GAnnotation>;
                        }
                        type _lfunction<GAnnotation> = {
                            readonly 'in': T.DataSpecifier<GAnnotation>;
                            readonly 'out': T.DataSpecifier<GAnnotation>;
                        };
                        namespace resource {
                            type consumer<GAnnotation> = T.AsynchronousInterfaceReference<GAnnotation>;
                            type request<GAnnotation> = T.DataSpecifier<GAnnotation>;
                        }
                        type resource<GAnnotation> = {
                            readonly 'consumer': T.AsynchronousInterfaceReference<GAnnotation>;
                            readonly 'request': T.DataSpecifier<GAnnotation>;
                        };
                    }
                    type _ltype<GAnnotation> = [
                        'constructor',
                        {
                            readonly 'downstreams': pt.Dictionary<T.AsynchronousInterfaceReference<GAnnotation>>;
                            readonly 'interface': T.AsynchronousInterfaceReference<GAnnotation>;
                        }
                    ] | [
                        'function',
                        {
                            readonly 'in': T.DataSpecifier<GAnnotation>;
                            readonly 'out': T.DataSpecifier<GAnnotation>;
                        }
                    ] | [
                        'resource',
                        {
                            readonly 'consumer': T.AsynchronousInterfaceReference<GAnnotation>;
                            readonly 'request': T.DataSpecifier<GAnnotation>;
                        }
                    ];
                }
                type D<GAnnotation> = {
                    readonly 'parameters': T.Parameters<GAnnotation>;
                    readonly 'type': [
                        'constructor',
                        {
                            readonly 'downstreams': pt.Dictionary<T.AsynchronousInterfaceReference<GAnnotation>>;
                            readonly 'interface': T.AsynchronousInterfaceReference<GAnnotation>;
                        }
                    ] | [
                        'function',
                        {
                            readonly 'in': T.DataSpecifier<GAnnotation>;
                            readonly 'out': T.DataSpecifier<GAnnotation>;
                        }
                    ] | [
                        'resource',
                        {
                            readonly 'consumer': T.AsynchronousInterfaceReference<GAnnotation>;
                            readonly 'request': T.DataSpecifier<GAnnotation>;
                        }
                    ];
                };
            }
            type algorithms<GAnnotation> = pt.Dictionary<{
                readonly 'parameters': T.Parameters<GAnnotation>;
                readonly 'type': [
                    'constructor',
                    {
                        readonly 'downstreams': pt.Dictionary<T.AsynchronousInterfaceReference<GAnnotation>>;
                        readonly 'interface': T.AsynchronousInterfaceReference<GAnnotation>;
                    }
                ] | [
                    'function',
                    {
                        readonly 'in': T.DataSpecifier<GAnnotation>;
                        readonly 'out': T.DataSpecifier<GAnnotation>;
                    }
                ] | [
                    'resource',
                    {
                        readonly 'consumer': T.AsynchronousInterfaceReference<GAnnotation>;
                        readonly 'request': T.DataSpecifier<GAnnotation>;
                    }
                ];
            }>;
            namespace interfaces {
                namespace D {
                    type _linterface<GAnnotation> = T.AsynchronousInterface<GAnnotation>;
                    type parameters<GAnnotation> = T.Parameters<GAnnotation>;
                }
                type D<GAnnotation> = {
                    readonly 'interface': T.AsynchronousInterface<GAnnotation>;
                    readonly 'parameters': T.Parameters<GAnnotation>;
                };
            }
            type interfaces<GAnnotation> = pt.Dictionary<{
                readonly 'interface': T.AsynchronousInterface<GAnnotation>;
                readonly 'parameters': T.Parameters<GAnnotation>;
            }>;
        }
        type asynchronous<GAnnotation> = {
            readonly 'algorithms': pt.Dictionary<{
                readonly 'parameters': T.Parameters<GAnnotation>;
                readonly 'type': [
                    'constructor',
                    {
                        readonly 'downstreams': pt.Dictionary<T.AsynchronousInterfaceReference<GAnnotation>>;
                        readonly 'interface': T.AsynchronousInterfaceReference<GAnnotation>;
                    }
                ] | [
                    'function',
                    {
                        readonly 'in': T.DataSpecifier<GAnnotation>;
                        readonly 'out': T.DataSpecifier<GAnnotation>;
                    }
                ] | [
                    'resource',
                    {
                        readonly 'consumer': T.AsynchronousInterfaceReference<GAnnotation>;
                        readonly 'request': T.DataSpecifier<GAnnotation>;
                    }
                ];
            }>;
            readonly 'interfaces': pt.Dictionary<{
                readonly 'interface': T.AsynchronousInterface<GAnnotation>;
                readonly 'parameters': T.Parameters<GAnnotation>;
            }>;
        };
        type glossary__parameters<GAnnotation> = T.Parameters<GAnnotation>;
        type imports<GAnnotation> = T.Imports<GAnnotation>;
        type root<GAnnotation> = T.Namespace<GAnnotation>;
        namespace synchronous {
            namespace algorithms {
                namespace D {
                    type parameters<GAnnotation> = T.Parameters<GAnnotation>;
                    namespace _ltype {
                        namespace _lfunction {
                            namespace callbacks {
                                namespace D {
                                    type _lin<GAnnotation> = T.DataSpecifier<GAnnotation>;
                                    namespace lookups {
                                        type D<GAnnotation> = T.DataSpecifier<GAnnotation>;
                                    }
                                    type lookups<GAnnotation> = pt.Dictionary<T.DataSpecifier<GAnnotation>>;
                                    type out<GAnnotation> = T.DataSpecifier<GAnnotation>;
                                }
                                type D<GAnnotation> = {
                                    readonly 'in': T.DataSpecifier<GAnnotation>;
                                    readonly 'lookups': pt.Dictionary<T.DataSpecifier<GAnnotation>>;
                                    readonly 'out': T.DataSpecifier<GAnnotation>;
                                };
                            }
                            type callbacks<GAnnotation> = pt.Dictionary<{
                                readonly 'in': T.DataSpecifier<GAnnotation>;
                                readonly 'lookups': pt.Dictionary<T.DataSpecifier<GAnnotation>>;
                                readonly 'out': T.DataSpecifier<GAnnotation>;
                            }>;
                            type _lin<GAnnotation> = T.DataOrSynchronousInterface<GAnnotation>;
                            type out<GAnnotation> = T.DataSpecifier<GAnnotation>;
                        }
                        type _lfunction<GAnnotation> = {
                            readonly 'callbacks': pt.Dictionary<{
                                readonly 'in': T.DataSpecifier<GAnnotation>;
                                readonly 'lookups': pt.Dictionary<T.DataSpecifier<GAnnotation>>;
                                readonly 'out': T.DataSpecifier<GAnnotation>;
                            }>;
                            readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                            readonly 'out': T.DataSpecifier<GAnnotation>;
                        };
                        namespace procedure {
                            type _lin<GAnnotation> = T.DataOrSynchronousInterface<GAnnotation>;
                            type out<GAnnotation> = T.SynchronousInterfaceReference<GAnnotation>;
                        }
                        type procedure<GAnnotation> = {
                            readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                            readonly 'out': T.SynchronousInterfaceReference<GAnnotation>;
                        };
                    }
                    type _ltype<GAnnotation> = [
                        'function',
                        {
                            readonly 'callbacks': pt.Dictionary<{
                                readonly 'in': T.DataSpecifier<GAnnotation>;
                                readonly 'lookups': pt.Dictionary<T.DataSpecifier<GAnnotation>>;
                                readonly 'out': T.DataSpecifier<GAnnotation>;
                            }>;
                            readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                            readonly 'out': T.DataSpecifier<GAnnotation>;
                        }
                    ] | [
                        'procedure',
                        {
                            readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                            readonly 'out': T.SynchronousInterfaceReference<GAnnotation>;
                        }
                    ];
                }
                type D<GAnnotation> = {
                    readonly 'parameters': T.Parameters<GAnnotation>;
                    readonly 'type': [
                        'function',
                        {
                            readonly 'callbacks': pt.Dictionary<{
                                readonly 'in': T.DataSpecifier<GAnnotation>;
                                readonly 'lookups': pt.Dictionary<T.DataSpecifier<GAnnotation>>;
                                readonly 'out': T.DataSpecifier<GAnnotation>;
                            }>;
                            readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                            readonly 'out': T.DataSpecifier<GAnnotation>;
                        }
                    ] | [
                        'procedure',
                        {
                            readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                            readonly 'out': T.SynchronousInterfaceReference<GAnnotation>;
                        }
                    ];
                };
            }
            type algorithms<GAnnotation> = pt.Dictionary<{
                readonly 'parameters': T.Parameters<GAnnotation>;
                readonly 'type': [
                    'function',
                    {
                        readonly 'callbacks': pt.Dictionary<{
                            readonly 'in': T.DataSpecifier<GAnnotation>;
                            readonly 'lookups': pt.Dictionary<T.DataSpecifier<GAnnotation>>;
                            readonly 'out': T.DataSpecifier<GAnnotation>;
                        }>;
                        readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                        readonly 'out': T.DataSpecifier<GAnnotation>;
                    }
                ] | [
                    'procedure',
                    {
                        readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                        readonly 'out': T.SynchronousInterfaceReference<GAnnotation>;
                    }
                ];
            }>;
            namespace interfaces {
                namespace D {
                    type _linterface<GAnnotation> = T.Synchronous__Interface<GAnnotation>;
                    type parameters<GAnnotation> = T.Parameters<GAnnotation>;
                }
                type D<GAnnotation> = {
                    readonly 'interface': T.Synchronous__Interface<GAnnotation>;
                    readonly 'parameters': T.Parameters<GAnnotation>;
                };
            }
            type interfaces<GAnnotation> = pt.Dictionary<{
                readonly 'interface': T.Synchronous__Interface<GAnnotation>;
                readonly 'parameters': T.Parameters<GAnnotation>;
            }>;
        }
        type synchronous<GAnnotation> = {
            readonly 'algorithms': pt.Dictionary<{
                readonly 'parameters': T.Parameters<GAnnotation>;
                readonly 'type': [
                    'function',
                    {
                        readonly 'callbacks': pt.Dictionary<{
                            readonly 'in': T.DataSpecifier<GAnnotation>;
                            readonly 'lookups': pt.Dictionary<T.DataSpecifier<GAnnotation>>;
                            readonly 'out': T.DataSpecifier<GAnnotation>;
                        }>;
                        readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                        readonly 'out': T.DataSpecifier<GAnnotation>;
                    }
                ] | [
                    'procedure',
                    {
                        readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                        readonly 'out': T.SynchronousInterfaceReference<GAnnotation>;
                    }
                ];
            }>;
            readonly 'interfaces': pt.Dictionary<{
                readonly 'interface': T.Synchronous__Interface<GAnnotation>;
                readonly 'parameters': T.Parameters<GAnnotation>;
            }>;
        };
    }
    type Glossary<GAnnotation> = {
        readonly 'asynchronous': {
            readonly 'algorithms': pt.Dictionary<{
                readonly 'parameters': T.Parameters<GAnnotation>;
                readonly 'type': [
                    'constructor',
                    {
                        readonly 'downstreams': pt.Dictionary<T.AsynchronousInterfaceReference<GAnnotation>>;
                        readonly 'interface': T.AsynchronousInterfaceReference<GAnnotation>;
                    }
                ] | [
                    'function',
                    {
                        readonly 'in': T.DataSpecifier<GAnnotation>;
                        readonly 'out': T.DataSpecifier<GAnnotation>;
                    }
                ] | [
                    'resource',
                    {
                        readonly 'consumer': T.AsynchronousInterfaceReference<GAnnotation>;
                        readonly 'request': T.DataSpecifier<GAnnotation>;
                    }
                ];
            }>;
            readonly 'interfaces': pt.Dictionary<{
                readonly 'interface': T.AsynchronousInterface<GAnnotation>;
                readonly 'parameters': T.Parameters<GAnnotation>;
            }>;
        };
        readonly 'glossary parameters': T.Parameters<GAnnotation>;
        readonly 'imports': T.Imports<GAnnotation>;
        readonly 'root': T.Namespace<GAnnotation>;
        readonly 'synchronous': {
            readonly 'algorithms': pt.Dictionary<{
                readonly 'parameters': T.Parameters<GAnnotation>;
                readonly 'type': [
                    'function',
                    {
                        readonly 'callbacks': pt.Dictionary<{
                            readonly 'in': T.DataSpecifier<GAnnotation>;
                            readonly 'lookups': pt.Dictionary<T.DataSpecifier<GAnnotation>>;
                            readonly 'out': T.DataSpecifier<GAnnotation>;
                        }>;
                        readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                        readonly 'out': T.DataSpecifier<GAnnotation>;
                    }
                ] | [
                    'procedure',
                    {
                        readonly 'in': T.DataOrSynchronousInterface<GAnnotation>;
                        readonly 'out': T.SynchronousInterfaceReference<GAnnotation>;
                    }
                ];
            }>;
            readonly 'interfaces': pt.Dictionary<{
                readonly 'interface': T.Synchronous__Interface<GAnnotation>;
                readonly 'parameters': T.Parameters<GAnnotation>;
            }>;
        };
    };
    namespace Glossary__Reference {
        namespace glossary {
            type annotation<GAnnotation> = GAnnotation;
            namespace constraint {
                type O<GAnnotation> = T.Imports.D<GAnnotation>;
            }
            type constraint<GAnnotation> = [false] | [true, T.Imports.D<GAnnotation>];
            type key<GAnnotation> = string;
        }
        type glossary<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'constraint': [false] | [true, T.Imports.D<GAnnotation>];
            readonly 'key': string;
        };
        type glossary__arguments<GAnnotation> = T.Arguments<GAnnotation>;
    }
    type Glossary__Reference<GAnnotation> = {
        readonly 'glossary': {
            readonly 'annotation': GAnnotation;
            readonly 'constraint': [false] | [true, T.Imports.D<GAnnotation>];
            readonly 'key': string;
        };
        readonly 'glossary arguments': T.Arguments<GAnnotation>;
    };
    namespace Imports {
        namespace D { }
        type D<GAnnotation> = null;
    }
    type Imports<GAnnotation> = pt.Dictionary<null>;
    namespace Namespace {
        namespace namespaces {
            type D<GAnnotation> = T.Namespace<GAnnotation>;
        }
        type namespaces<GAnnotation> = pt.Dictionary<T.Namespace<GAnnotation>>;
        namespace types {
            namespace D {
                type parameters<GAnnotation> = T.Parameters<GAnnotation>;
                type _ltype<GAnnotation> = T.Type<GAnnotation>;
            }
            type D<GAnnotation> = {
                readonly 'parameters': T.Parameters<GAnnotation>;
                readonly 'type': T.Type<GAnnotation>;
            };
        }
        type types<GAnnotation> = pt.Dictionary<{
            readonly 'parameters': T.Parameters<GAnnotation>;
            readonly 'type': T.Type<GAnnotation>;
        }>;
    }
    type Namespace<GAnnotation> = {
        readonly 'namespaces': pt.Dictionary<T.Namespace<GAnnotation>>;
        readonly 'types': pt.Dictionary<{
            readonly 'parameters': T.Parameters<GAnnotation>;
            readonly 'type': T.Type<GAnnotation>;
        }>;
    };
    namespace Parameters {
        namespace D { }
        type D<GAnnotation> = null;
    }
    type Parameters<GAnnotation> = pt.Dictionary<null>;
    namespace Synchronous__Interface {
        namespace group {
            namespace members {
                type D<GAnnotation> = T.Synchronous__Interface<GAnnotation>;
            }
            type members<GAnnotation> = pt.Dictionary<T.Synchronous__Interface<GAnnotation>>;
        }
        type group<GAnnotation> = {
            readonly 'members': pt.Dictionary<T.Synchronous__Interface<GAnnotation>>;
        };
        namespace method {
            namespace data {
                type O<GAnnotation> = T.DataSpecifier<GAnnotation>;
            }
            type data<GAnnotation> = [false] | [true, T.DataSpecifier<GAnnotation>];
            namespace _linterface {
                type O<GAnnotation> = T.Synchronous__Interface<GAnnotation>;
            }
            type _linterface<GAnnotation> = [false] | [true, T.Synchronous__Interface<GAnnotation>];
        }
        type method<GAnnotation> = {
            readonly 'data': [false] | [true, T.DataSpecifier<GAnnotation>];
            readonly 'interface': [false] | [true, T.Synchronous__Interface<GAnnotation>];
        };
        type reference<GAnnotation> = T.SynchronousInterfaceReference<GAnnotation>;
    }
    type Synchronous__Interface<GAnnotation> = [
        'group',
        {
            readonly 'members': pt.Dictionary<T.Synchronous__Interface<GAnnotation>>;
        }
    ] | [
        'method',
        {
            readonly 'data': [false] | [true, T.DataSpecifier<GAnnotation>];
            readonly 'interface': [false] | [true, T.Synchronous__Interface<GAnnotation>];
        }
    ] | ['reference', T.SynchronousInterfaceReference<GAnnotation>];
    namespace SynchronousInterfaceReference {
        namespace context {
            namespace _limport {
                type glossary<GAnnotation> = T.Glossary__Reference<GAnnotation>;
                type interfaceXX<GAnnotation> = string;
            }
            type _limport<GAnnotation> = {
                readonly 'glossary': T.Glossary__Reference<GAnnotation>;
                readonly 'interfaceXX': string;
            };
            namespace local {
                type interfaceXX<GAnnotation> = string;
            }
            type local<GAnnotation> = {
                readonly 'interfaceXX': string;
            };
        }
        type context<GAnnotation> = [
            'import',
            {
                readonly 'glossary': T.Glossary__Reference<GAnnotation>;
                readonly 'interfaceXX': string;
            }
        ] | [
            'local',
            {
                readonly 'interfaceXX': string;
            }
        ];
        type type__arguments<GAnnotation> = T.Arguments<GAnnotation>;
    }
    type SynchronousInterfaceReference<GAnnotation> = {
        readonly 'context': [
            'import',
            {
                readonly 'glossary': T.Glossary__Reference<GAnnotation>;
                readonly 'interfaceXX': string;
            }
        ] | [
            'local',
            {
                readonly 'interfaceXX': string;
            }
        ];
        readonly 'type arguments': T.Arguments<GAnnotation>;
    };
    namespace Type {
        type array<GAnnotation> = T.Type<GAnnotation>;
        namespace _lboolean { }
        type _lboolean<GAnnotation> = null;
        type computed<GAnnotation> = T.Type<GAnnotation>;
        type dictionary<GAnnotation> = T.Type<GAnnotation>;
        namespace group {
            namespace D {
                type _ltype<GAnnotation> = T.Type<GAnnotation>;
            }
            type D<GAnnotation> = {
                readonly 'type': T.Type<GAnnotation>;
            };
        }
        type group<GAnnotation> = pt.Dictionary<{
            readonly 'type': T.Type<GAnnotation>;
        }>;
        namespace _lnull { }
        type _lnull<GAnnotation> = null;
        namespace _lnumber { }
        type _lnumber<GAnnotation> = null;
        type optional<GAnnotation> = T.Type<GAnnotation>;
        type reference<GAnnotation> = T.DataSpecifier<GAnnotation>;
        namespace _lstring { }
        type _lstring<GAnnotation> = null;
        namespace taggedUnion {
            type D<GAnnotation> = T.Type<GAnnotation>;
        }
        type taggedUnion<GAnnotation> = pt.Dictionary<T.Type<GAnnotation>>;
    }
    type Type<GAnnotation> = ['array', T.Type<GAnnotation>] | ['boolean', null] | ['computed', T.Type<GAnnotation>] | ['dictionary', T.Type<GAnnotation>] | [
        'group',
        pt.Dictionary<{
            readonly 'type': T.Type<GAnnotation>;
        }>
    ] | ['null', null] | ['number', null] | ['optional', T.Type<GAnnotation>] | ['reference', T.DataSpecifier<GAnnotation>] | ['string', null] | ['taggedUnion', pt.Dictionary<T.Type<GAnnotation>>];
}
