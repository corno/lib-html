"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$$ = void 0;
const pl = __importStar(require("pareto-core-lib"));
function tempoptional($, a, b) {
    return tempoptional($, a, b);
}
const $$ = ($d, $se) => {
    function map_A__dictionary__with__constraint($) {
        return pl.cc($, ($) => {
            const $p_dict = pl.cc($['dict'], ($) => $d.resolveDictionary($, { 'map': ($, $l) => pl.cc($.value, ($) => pl.cc($, ($) => {
                    return null;
                })) }));
            const $v_dict = [true, $p_dict];
            const $p_constrained__dict = pl.cc($['constrained dict'], ($) => $d.resolveDictionary($, { 'map': ($, $l) => {
                    const entrykey = $.key;
                    return pl.cc($.value, ($) => {
                        const /*dict constraint*/ $v_a__constraint = tempoptional /*3*/($v_dict, ($) => $.__getEntry(entrykey, ($) => [true, $], () => {
                            $se.error("no such entry");
                            return [false];
                        }), () => [false]);
                        return {
                            'annotation': $.annotation,
                            'constraints': {
                                'a constraint': $v_a__constraint,
                            },
                            'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                return null;
                            })),
                        };
                    });
                } }));
            const $v_constrained__dict = [true, $p_constrained__dict];
            return {
                'constrained dict': $p_constrained__dict,
                'dict': $p_dict,
            };
        });
    }
    function map_A__optional__with__result($, $v_result__param) {
        return pl.cc($, ($) => {
            const $p_opt = pl.cc($['opt'], ($) => pl.cc($, ($) => {
                const content = tempoptional /*4*/($, ($) => [true, pl.cc($, ($) => {
                        const $p_rslt = pl.cc($['rslt'], ($) => map_A__Result($));
                        const $v_rslt = [true, $p_rslt];
                        return {
                            'rslt': $p_rslt,
                        };
                    })], () => [false]);
                return {
                    'content': content,
                    'result': tempoptional(content, ($) => pl.cc($['rslt'], ($) => [true, $]), () => tempoptional /*3*/($v_result__param, ($) => [true, $], () => [false])),
                };
            }));
            const $v_opt = [true, $p_opt];
            return {
                'opt': $p_opt,
            };
        });
    }
    function map_A__Result($) {
        return pl.cc($, ($) => {
            const $p_foo = pl.cc($['foo'], ($) => $);
            const $v_foo = [true, $p_foo];
            return {
                'foo': $p_foo,
            };
        });
    }
    function map_A__tagged__union__with__constrained__option($) {
        return pl.cc($, ($) => {
            const $p_tu1 = pl.cc($['tu1'], ($) => pl.cc($, ($) => {
                switch ($[0]) {
                    case 'a': return pl.ss($, ($) => ['a', pl.cc($, ($) => {
                            const $p_bar = pl.cc($['bar'], ($) => $);
                            const $v_bar = [true, $p_bar];
                            return {
                                'bar': $p_bar,
                            };
                        })]);
                    default: return pl.au($[0]);
                }
            }));
            const $v_tu1 = [true, $p_tu1];
            const $p_tu2 = pl.cc($['tu2'], ($) => pl.cc($, ($) => {
                switch ($[0]) {
                    case 'a': return pl.ss($, ($) => {
                        const /*option constraint*/ $v_opt__constraint = pl.cc($, ($) => {
                            const optConstraint = tempoptional /*3*/($v_tu1, ($) => ($[0] === 'a')
                                ? [true, $[1]]
                                : pl.cc($, ($) => {
                                    $se.error("option constraint");
                                    return [false];
                                }), () => [false]);
                            return optConstraint;
                        });
                        return ['a', pl.cc($, ($) => {
                                return {
                                    'annotation': $.annotation,
                                    'constraints': {
                                        'opt constraint': $v_opt__constraint,
                                    },
                                    'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                        const $p_rslt = pl.cc($['rslt'], ($) => map_A__Result($));
                                        const $v_rslt = [true, $p_rslt];
                                        return {
                                            'rslt': $p_rslt,
                                        };
                                    })),
                                };
                            })];
                    });
                    default: return pl.au($[0]);
                }
            }));
            const $v_tu2 = [true, $p_tu2];
            return {
                'tu1': $p_tu1,
                'tu2': $p_tu2,
            };
        });
    }
    function map_A__tagged__union__with__constrained__option__and__result($) {
        return pl.cc($, ($) => {
            const $p_tu1 = pl.cc($['tu1'], ($) => pl.cc($, ($) => {
                switch ($[0]) {
                    case 'a': return pl.ss($, ($) => ['a', pl.cc($, ($) => {
                            const $p_bar = pl.cc($['bar'], ($) => $);
                            const $v_bar = [true, $p_bar];
                            return {
                                'bar': $p_bar,
                            };
                        })]);
                    default: return pl.au($[0]);
                }
            }));
            const $v_tu1 = [true, $p_tu1];
            const $p_tu2 = pl.cc($['tu2'], ($) => pl.cc($, ($) => {
                switch ($[0]) {
                    case 'a': return pl.ss($, ($) => {
                        const /*option constraint*/ $v_opt__constraint = pl.cc($, ($) => {
                            const optConstraint = tempoptional /*3*/($v_tu1, ($) => ($[0] === 'a')
                                ? [true, $[1]]
                                : pl.cc($, ($) => {
                                    $se.error("option constraint");
                                    return [false];
                                }), () => [false]);
                            return optConstraint;
                        });
                        const stateData = pl.cc($, ($) => {
                            return {
                                'annotation': $.annotation,
                                'constraints': {
                                    'opt constraint': $v_opt__constraint,
                                },
                                'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                    const $p_rslt = pl.cc($['rslt'], ($) => map_A__Result($));
                                    const $v_rslt = [true, $p_rslt];
                                    return {
                                        'rslt': $p_rslt,
                                    };
                                })),
                            };
                        });
                        return {
                            'content': ['a', stateData],
                            'result': pl.cc(stateData.content, ($) => pl.cc($['rslt'], ($) => [true, $])),
                        };
                    });
                    default: return pl.au($[0]);
                }
            }));
            const $v_tu2 = [true, $p_tu2];
            return {
                'tu1': $p_tu1,
                'tu2': $p_tu2,
            };
        });
    }
    function map_A__tagged__union__with__result($) {
        return pl.cc($, ($) => {
            const $p_tu = pl.cc($['tu'], ($) => pl.cc($, ($) => {
                switch ($[0]) {
                    case 'a': return pl.ss($, ($) => {
                        const stateData = pl.cc($, ($) => {
                            const $p_rslt = pl.cc($['rslt'], ($) => map_A__Result($));
                            const $v_rslt = [true, $p_rslt];
                            return {
                                'rslt': $p_rslt,
                            };
                        });
                        return {
                            'content': ['a', stateData],
                            'result': pl.cc(stateData, ($) => pl.cc($['rslt'], ($) => [true, $])),
                        };
                    });
                    default: return pl.au($[0]);
                }
            }));
            const $v_tu = [true, $p_tu];
            return {
                'tu': $p_tu,
            };
        });
    }
    function map_Address__Selection($, $v_namespace, $v_variable__stack) {
        const content = pl.cc($, ($) => {
            const $p_variable = pl.cc($['variable'], ($) => pl.cc($, ($) => {
                const refkey = $.key;
                const constraint = tempoptional /*3*/($v_variable__stack, ($) => $.__getEntry(refkey, ($) => [true, $], () => {
                    $se.error("no such entry");
                    return [false];
                }), () => [false]);
                return {
                    'annotation': $.annotation,
                    'constraint': constraint,
                    'key': $.key,
                };
            }));
            const $v_variable = [true, $p_variable];
            const $p_tail = pl.cc($['tail'], ($) => map_Address__Selection__Tail($, tempoptional /*3*/($v_variable, ($) => tempoptional /*1*/($.constraint, ($) => pl.cc($['type'], ($) => tempoptional($.result, ($) => [true, $], () => [false])), () => [false]), () => [false]), //$v_current__address
            tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
            tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
            const $v_tail = [true, $p_tail];
            return {
                'tail': $p_tail,
                'variable': $p_variable,
            };
        });
        return {
            'content': content,
            'result': pl.cc(content, ($) => pl.cc($['tail'], ($) => tempoptional($.result, ($) => [true, $], () => [false]))),
        };
    }
    function map_Address__Selection__Tail($, $v_current__address, $v_namespace, $v_variable__stack) {
        const content = pl.cc($, ($) => {
            const content = tempoptional /*4*/($, ($) => [true, pl.cc($, ($) => {
                    const $p_step = pl.cc($['step'], ($) => pl.cc($, ($) => {
                        switch ($[0]) {
                            case 'call': return pl.ss($, ($) => {
                                const /*option constraint*/ $v_address__function = pl.cc($, ($) => {
                                    const optConstraint = tempoptional /*3*/($v_current__address, ($) => ($[0] === 'address function')
                                        ? [true, $[1]]
                                        : pl.cc($, ($) => {
                                            $se.error("option constraint");
                                            return [false];
                                        }), () => [false]);
                                    return optConstraint;
                                });
                                const stateData = pl.cc($, ($) => {
                                    return {
                                        'annotation': $.annotation,
                                        'constraints': {
                                            'address function': $v_address__function,
                                        },
                                        'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                            const $p_type__arguments = pl.cc($['type arguments'], ($) => map_Type__Arguments($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                                            tempoptional /*3*/($v_address__function, ($) => pl.cc($['declaration'], ($) => pl.cc($['type parameters'], ($) => [true, $])), () => [false])));
                                            const $v_type__arguments = [true, $p_type__arguments];
                                            return {
                                                'type arguments': $p_type__arguments,
                                            };
                                        })),
                                    };
                                });
                                return {
                                    'content': ['call', stateData],
                                    'result': pl.cc(stateData.content, ($) => tempoptional /*3*/($v_address__function, ($) => pl.cc($['return type'], ($) => [true, $]), () => [false])),
                                };
                            });
                            case 'property': return pl.ss($, ($) => {
                                const /*option constraint*/ $v_group = pl.cc($, ($) => {
                                    const optConstraint = tempoptional /*3*/($v_current__address, ($) => ($[0] === 'group')
                                        ? [true, $[1]]
                                        : pl.cc($, ($) => {
                                            $se.error("option constraint");
                                            return [false];
                                        }), () => [false]);
                                    return optConstraint;
                                });
                                const stateData = pl.cc($, ($) => {
                                    return {
                                        'annotation': $.annotation,
                                        'constraints': {
                                            'group': $v_group,
                                        },
                                        'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                            const refkey = $.key;
                                            const constraint = tempoptional /*3*/($v_group, ($) => $.__getEntry(refkey, ($) => [true, $], () => {
                                                $se.error("no such entry");
                                                return [false];
                                            }), () => [false]);
                                            return {
                                                'annotation': $.annotation,
                                                'constraint': constraint,
                                                'key': $.key,
                                            };
                                        })),
                                    };
                                });
                                return {
                                    'content': ['property', stateData],
                                    'result': pl.cc(stateData.content, ($) => tempoptional /*1*/($.constraint, ($) => [true, $], () => [false])),
                                };
                            });
                            default: return pl.au($[0]);
                        }
                    }));
                    const $v_step = [true, $p_step];
                    const $p_tail = pl.cc($['tail'], ($) => map_Address__Selection__Tail($, tempoptional /*3*/($v_step, ($) => tempoptional($.result, ($) => [true, $], () => [false]), () => [false]), //$v_current__address
                    tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                    const $v_tail = [true, $p_tail];
                    return {
                        'step': $p_step,
                        'tail': $p_tail,
                    };
                })], () => [false]);
            return {
                'content': content,
                'result': tempoptional(content, ($) => pl.cc($['tail'], ($) => tempoptional($.result, ($) => [true, $], () => [false])), () => tempoptional /*3*/($v_current__address, ($) => [true, $], () => [false])),
            };
        });
        return {
            'content': content,
            'result': pl.cc(content, ($) => tempoptional($.result, ($) => [true, $], () => [false])),
        };
    }
    function map_Assign($, $v_namespace, $v_variable__stack) {
        return pl.cc($, ($) => {
            const $p_target = pl.cc($['target'], ($) => map_Address__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
            tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
            const $v_target = [true, $p_target];
            const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_Expression($, tempoptional /*3*/($v_target, ($) => tempoptional($.result, ($) => [true, $], () => [false]), () => [false]), //$v_expected__type
            tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
            tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
            const $v_right__hand__side = [true, $p_right__hand__side];
            return {
                'right hand side': $p_right__hand__side,
                'target': $p_target,
            };
        });
    }
    function map_Block($, $v_namespace, $v_type__parameters, $v_variable__stack) {
        return pl.cc($, ($) => {
            const $p_variables = pl.cc($['variables'], ($) => map_Variables($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
            tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
            const $v_variables = [true, $p_variables];
            const $p_statements = pl.cc($['statements'], ($) => map_Statements($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
            tempoptional /*3*/($v_type__parameters, ($) => [true, $], () => [false]), //$v_type__parameters
            tempoptional /*3*/($v_variables, ($) => [true, $], () => [false])));
            const $v_statements = [true, $p_statements];
            return {
                'statements': $p_statements,
                'variables': $p_variables,
            };
        });
    }
    function map_Boolean__Expression($, $v_namespace, $v_variable__stack) {
        return pl.cc($, ($) => {
            switch ($[0]) {
                case 'and': return pl.ss($, ($) => ['and', pl.cc($, ($) => {
                        const $p_left__hand__side = pl.cc($['left hand side'], ($) => map_Boolean__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_left__hand__side = [true, $p_left__hand__side];
                        const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_Boolean__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_right__hand__side = [true, $p_right__hand__side];
                        return {
                            'left hand side': $p_left__hand__side,
                            'right hand side': $p_right__hand__side,
                        };
                    })]);
                case 'false': return pl.ss($, ($) => ['false', pl.cc($, ($) => {
                        return null;
                    })]);
                case 'greater than': return pl.ss($, ($) => ['greater than', pl.cc($, ($) => {
                        const $p_left__hand__side = pl.cc($['left hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_left__hand__side = [true, $p_left__hand__side];
                        const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_right__hand__side = [true, $p_right__hand__side];
                        return {
                            'left hand side': $p_left__hand__side,
                            'right hand side': $p_right__hand__side,
                        };
                    })]);
                case 'less than': return pl.ss($, ($) => ['less than', pl.cc($, ($) => {
                        const $p_left__hand__side = pl.cc($['left hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_left__hand__side = [true, $p_left__hand__side];
                        const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_right__hand__side = [true, $p_right__hand__side];
                        return {
                            'left hand side': $p_left__hand__side,
                            'right hand side': $p_right__hand__side,
                        };
                    })]);
                case 'not': return pl.ss($, ($) => ['not', map_Boolean__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))]);
                case 'number equals': return pl.ss($, ($) => ['number equals', pl.cc($, ($) => {
                        const $p_left__hand__side = pl.cc($['left hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_left__hand__side = [true, $p_left__hand__side];
                        const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_right__hand__side = [true, $p_right__hand__side];
                        return {
                            'left hand side': $p_left__hand__side,
                            'right hand side': $p_right__hand__side,
                        };
                    })]);
                case 'number not equals': return pl.ss($, ($) => ['number not equals', pl.cc($, ($) => {
                        const $p_left__hand__side = pl.cc($['left hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_left__hand__side = [true, $p_left__hand__side];
                        const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_right__hand__side = [true, $p_right__hand__side];
                        return {
                            'left hand side': $p_left__hand__side,
                            'right hand side': $p_right__hand__side,
                        };
                    })]);
                case 'or': return pl.ss($, ($) => ['or', pl.cc($, ($) => {
                        const $p_left__hand__side = pl.cc($['left hand side'], ($) => map_Boolean__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_left__hand__side = [true, $p_left__hand__side];
                        const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_Boolean__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_right__hand__side = [true, $p_right__hand__side];
                        return {
                            'left hand side': $p_left__hand__side,
                            'right hand side': $p_right__hand__side,
                        };
                    })]);
                case 'string equals': return pl.ss($, ($) => ['string equals', pl.cc($, ($) => {
                        const $p_left__hand__side = pl.cc($['left hand side'], ($) => map_String__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_left__hand__side = [true, $p_left__hand__side];
                        const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_String__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_right__hand__side = [true, $p_right__hand__side];
                        return {
                            'left hand side': $p_left__hand__side,
                            'right hand side': $p_right__hand__side,
                        };
                    })]);
                case 'string not equals': return pl.ss($, ($) => ['string not equals', pl.cc($, ($) => {
                        const $p_left__hand__side = pl.cc($['left hand side'], ($) => map_String__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_left__hand__side = [true, $p_left__hand__side];
                        const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_String__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_right__hand__side = [true, $p_right__hand__side];
                        return {
                            'left hand side': $p_left__hand__side,
                            'right hand side': $p_right__hand__side,
                        };
                    })]);
                case 'true': return pl.ss($, ($) => ['true', pl.cc($, ($) => {
                        return null;
                    })]);
                default: return pl.au($[0]);
            }
        });
    }
    function map_Boolean__Expression__Or__Selection($, $v_namespace, $v_variable__stack) {
        return pl.cc($, ($) => {
            switch ($[0]) {
                case 'expression': return pl.ss($, ($) => ['expression', map_Boolean__Expression($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))]);
                case 'selection': return pl.ss($, ($) => ['selection', pl.cc($, ($) => {
                        const $p_selection = pl.cc($['selection'], ($) => map_Address__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_selection = [true, $p_selection];
                        const $p_cast__to__boolean = pl.cc($['cast to boolean'], ($) => pl.cc($, ($) => {
                            switch ($[0]) {
                                case 'boolean': return pl.ss($, ($) => {
                                    const /*option constraint*/ $v__lboolean = pl.cc($, ($) => {
                                        const optConstraint = tempoptional /*3*/($v_selection, ($) => tempoptional($.result, ($) => ($[0] === 'boolean')
                                            ? [true, $[1]]
                                            : pl.cc($, ($) => {
                                                $se.error("option constraint");
                                                return [false];
                                            }), () => [false]), () => [false]);
                                        return optConstraint;
                                    });
                                    return ['boolean', pl.cc($, ($) => {
                                            return {
                                                'annotation': $.annotation,
                                                'constraints': {
                                                    'boolean': $v__lboolean,
                                                },
                                                'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                                    return null;
                                                })),
                                            };
                                        })];
                                });
                                default: return pl.au($[0]);
                            }
                        }));
                        const $v_cast__to__boolean = [true, $p_cast__to__boolean];
                        return {
                            'cast to boolean': $p_cast__to__boolean,
                            'selection': $p_selection,
                        };
                    })]);
                default: return pl.au($[0]);
            }
        });
    }
    function map_Expression($, $v_expected__type, $v_namespace, $v_variable__stack) {
        return pl.cc($, ($) => {
            switch ($[0]) {
                case 'array literal': return pl.ss($, ($) => {
                    const /*option constraint*/ $v_out = pl.cc($, ($) => {
                        const optConstraint = tempoptional /*3*/($v_expected__type, ($) => ($[0] === 'array')
                            ? [true, $[1]]
                            : pl.cc($, ($) => {
                                $se.error("option constraint");
                                return [false];
                            }), () => [false]);
                        return optConstraint;
                    });
                    return ['array literal', pl.cc($, ($) => {
                            return {
                                'annotation': $.annotation,
                                'constraints': {
                                    'out': $v_out,
                                },
                                'content': pl.cc($.content, ($) => $.map(($) => map_Expression($, tempoptional /*3*/($v_out, ($) => [true, $], () => [false]), //$v_expected__type
                                tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                                tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])))),
                            };
                        })];
                });
                case 'boolean': return pl.ss($, ($) => {
                    const /*option constraint*/ $v_out = pl.cc($, ($) => {
                        const optConstraint = tempoptional /*3*/($v_expected__type, ($) => ($[0] === 'boolean')
                            ? [true, $[1]]
                            : pl.cc($, ($) => {
                                $se.error("option constraint");
                                return [false];
                            }), () => [false]);
                        return optConstraint;
                    });
                    return ['boolean', pl.cc($, ($) => {
                            return {
                                'annotation': $.annotation,
                                'constraints': {
                                    'out': $v_out,
                                },
                                'content': pl.cc($.content, ($) => map_Boolean__Expression($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                                tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))),
                            };
                        })];
                });
                case 'null': return pl.ss($, ($) => {
                    const /*option constraint*/ $v_out = pl.cc($, ($) => {
                        const optConstraint = tempoptional /*3*/($v_expected__type, ($) => ($[0] === 'null')
                            ? [true, $[1]]
                            : pl.cc($, ($) => {
                                $se.error("option constraint");
                                return [false];
                            }), () => [false]);
                        return optConstraint;
                    });
                    return ['null', pl.cc($, ($) => {
                            return {
                                'annotation': $.annotation,
                                'constraints': {
                                    'out': $v_out,
                                },
                                'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                    return null;
                                })),
                            };
                        })];
                });
                case 'numerical': return pl.ss($, ($) => {
                    const /*option constraint*/ $v_out = pl.cc($, ($) => {
                        const optConstraint = tempoptional /*3*/($v_expected__type, ($) => ($[0] === 'number')
                            ? [true, $[1]]
                            : pl.cc($, ($) => {
                                $se.error("option constraint");
                                return [false];
                            }), () => [false]);
                        return optConstraint;
                    });
                    return ['numerical', pl.cc($, ($) => {
                            return {
                                'annotation': $.annotation,
                                'constraints': {
                                    'out': $v_out,
                                },
                                'content': pl.cc($.content, ($) => map_Numerical__Expression($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                                tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))),
                            };
                        })];
                });
                case 'object literal': return pl.ss($, ($) => {
                    const /*option constraint*/ $v_out = pl.cc($, ($) => {
                        const optConstraint = tempoptional /*3*/($v_expected__type, ($) => ($[0] === 'group')
                            ? [true, $[1]]
                            : pl.cc($, ($) => {
                                $se.error("option constraint");
                                return [false];
                            }), () => [false]);
                        return optConstraint;
                    });
                    return ['object literal', pl.cc($, ($) => {
                            return {
                                'annotation': $.annotation,
                                'constraints': {
                                    'out': $v_out,
                                },
                                'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                    const $p_properties = pl.cc($['properties'], ($) => $d.resolveDictionary($, { 'map': ($, $l) => {
                                            const entrykey = $.key;
                                            return pl.cc($.value, ($) => {
                                                const /*dict constraint*/ $v_prop = tempoptional /*3*/($v_out, ($) => $.__getEntry(entrykey, ($) => [true, $], () => {
                                                    $se.error("no such entry");
                                                    return [false];
                                                }), () => [false]);
                                                return {
                                                    'annotation': $.annotation,
                                                    'constraints': {
                                                        'prop': $v_prop,
                                                    },
                                                    'content': pl.cc($.content, ($) => map_Expression($, tempoptional /*3*/($v_prop, ($) => [true, $], () => [false]), //$v_expected__type
                                                    tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                                                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))),
                                                };
                                            });
                                        } }));
                                    const $v_properties = [true, $p_properties];
                                    return {
                                        'properties': $p_properties,
                                    };
                                })),
                            };
                        })];
                });
                case 'string': return pl.ss($, ($) => {
                    const /*option constraint*/ $v_out = pl.cc($, ($) => {
                        const optConstraint = tempoptional /*3*/($v_expected__type, ($) => ($[0] === 'string')
                            ? [true, $[1]]
                            : pl.cc($, ($) => {
                                $se.error("option constraint");
                                return [false];
                            }), () => [false]);
                        return optConstraint;
                    });
                    return ['string', pl.cc($, ($) => {
                            return {
                                'annotation': $.annotation,
                                'constraints': {
                                    'out': $v_out,
                                },
                                'content': pl.cc($.content, ($) => map_String__Expression($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                                tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))),
                            };
                        })];
                });
                default: return pl.au($[0]);
            }
        });
    }
    function map_Numerical__Expression($, $v_namespace, $v_variable__stack) {
        return pl.cc($, ($) => {
            switch ($[0]) {
                case 'minus': return pl.ss($, ($) => ['minus', pl.cc($, ($) => {
                        const $p_left__hand__side = pl.cc($['left hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_left__hand__side = [true, $p_left__hand__side];
                        const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_right__hand__side = [true, $p_right__hand__side];
                        return {
                            'left hand side': $p_left__hand__side,
                            'right hand side': $p_right__hand__side,
                        };
                    })]);
                case 'numeric literal': return pl.ss($, ($) => ['numeric literal', $]);
                case 'plus': return pl.ss($, ($) => ['plus', pl.cc($, ($) => {
                        const $p_left__hand__side = pl.cc($['left hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_left__hand__side = [true, $p_left__hand__side];
                        const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_right__hand__side = [true, $p_right__hand__side];
                        return {
                            'left hand side': $p_left__hand__side,
                            'right hand side': $p_right__hand__side,
                        };
                    })]);
                case 'postdecrement': return pl.ss($, ($) => ['postdecrement', map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))]);
                case 'postincrement': return pl.ss($, ($) => ['postincrement', map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))]);
                case 'predecrement': return pl.ss($, ($) => ['predecrement', map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))]);
                case 'preincrement': return pl.ss($, ($) => ['preincrement', map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))]);
                default: return pl.au($[0]);
            }
        });
    }
    function map_Numerical__Expression__Or__Selection($, $v_namespace, $v_variable__stack) {
        return pl.cc($, ($) => {
            switch ($[0]) {
                case 'expression': return pl.ss($, ($) => ['expression', map_Numerical__Expression($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))]);
                case 'selection': return pl.ss($, ($) => ['selection', pl.cc($, ($) => {
                        const $p_selection = pl.cc($['selection'], ($) => map_Address__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_selection = [true, $p_selection];
                        const $p_cast__to__number = pl.cc($['cast to number'], ($) => pl.cc($, ($) => {
                            switch ($[0]) {
                                case 'number': return pl.ss($, ($) => {
                                    const /*option constraint*/ $v__lnumber = pl.cc($, ($) => {
                                        const optConstraint = tempoptional /*3*/($v_selection, ($) => tempoptional($.result, ($) => ($[0] === 'number')
                                            ? [true, $[1]]
                                            : pl.cc($, ($) => {
                                                $se.error("option constraint");
                                                return [false];
                                            }), () => [false]), () => [false]);
                                        return optConstraint;
                                    });
                                    return ['number', pl.cc($, ($) => {
                                            return {
                                                'annotation': $.annotation,
                                                'constraints': {
                                                    'number': $v__lnumber,
                                                },
                                                'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                                    return null;
                                                })),
                                            };
                                        })];
                                });
                                default: return pl.au($[0]);
                            }
                        }));
                        const $v_cast__to__number = [true, $p_cast__to__number];
                        return {
                            'cast to number': $p_cast__to__number,
                            'selection': $p_selection,
                        };
                    })]);
                default: return pl.au($[0]);
            }
        });
    }
    function map_Source__File($) {
        return pl.cc($, ($) => {
            return null;
        });
    }
    function map_Statements($, $v_namespace, $v_type__parameters, $v_variable__stack) {
        return $.map(($) => pl.cc($, ($) => {
            switch ($[0]) {
                case 'block': return pl.ss($, ($) => ['block', map_Block($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                    tempoptional /*3*/($v_type__parameters, ($) => [true, $], () => [false]), //$v_type__parameters
                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))]);
                case 'if': return pl.ss($, ($) => ['if', pl.cc($, ($) => {
                        const $p_condition = pl.cc($['condition'], ($) => map_Boolean__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_condition = [true, $p_condition];
                        const $p_then = pl.cc($['then'], ($) => map_Block($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_type__parameters, ($) => [true, $], () => [false]), //$v_type__parameters
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_then = [true, $p_then];
                        const $p__lelse = pl.cc($['else'], ($) => tempoptional /*4*/($, ($) => [true, map_Block($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                            tempoptional /*3*/($v_type__parameters, ($) => [true, $], () => [false]), //$v_type__parameters
                            tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))], () => [false]));
                        const $v__lelse = [true, $p__lelse];
                        return {
                            'condition': $p_condition,
                            'else': $p__lelse,
                            'then': $p_then,
                        };
                    })]);
                case 'while': return pl.ss($, ($) => ['while', pl.cc($, ($) => {
                        const $p_condition = pl.cc($['condition'], ($) => map_Boolean__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_condition = [true, $p_condition];
                        const $p_block = pl.cc($['block'], ($) => map_Block($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_type__parameters, ($) => [true, $], () => [false]), //$v_type__parameters
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_block = [true, $p_block];
                        return {
                            'block': $p_block,
                            'condition': $p_condition,
                        };
                    })]);
                case 'with': return pl.ss($, ($) => ['with', pl.cc($, ($) => {
                        const $p_address = pl.cc($['address'], ($) => map_Address__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_address = [true, $p_address];
                        const $p_action = pl.cc($['action'], ($) => pl.cc($, ($) => {
                            switch ($[0]) {
                                case 'assign': return pl.ss($, ($) => ['assign', map_Assign($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))]);
                                case 'minus assign': return pl.ss($, ($) => {
                                    const /*option constraint*/ $v_number__address = pl.cc($, ($) => {
                                        const optConstraint = tempoptional /*3*/($v_address, ($) => tempoptional($.result, ($) => ($[0] === 'number')
                                            ? [true, $[1]]
                                            : pl.cc($, ($) => {
                                                $se.error("option constraint");
                                                return [false];
                                            }), () => [false]), () => [false]);
                                        return optConstraint;
                                    });
                                    return ['minus assign', pl.cc($, ($) => {
                                            return {
                                                'annotation': $.annotation,
                                                'constraints': {
                                                    'number address': $v_number__address,
                                                },
                                                'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                                    const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                                                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                                                    const $v_right__hand__side = [true, $p_right__hand__side];
                                                    return {
                                                        'right hand side': $p_right__hand__side,
                                                    };
                                                })),
                                            };
                                        })];
                                });
                                case 'plus assign': return pl.ss($, ($) => {
                                    const /*option constraint*/ $v_number__address = pl.cc($, ($) => {
                                        const optConstraint = tempoptional /*3*/($v_address, ($) => tempoptional($.result, ($) => ($[0] === 'number')
                                            ? [true, $[1]]
                                            : pl.cc($, ($) => {
                                                $se.error("option constraint");
                                                return [false];
                                            }), () => [false]), () => [false]);
                                        return optConstraint;
                                    });
                                    return ['plus assign', pl.cc($, ($) => {
                                            return {
                                                'annotation': $.annotation,
                                                'constraints': {
                                                    'number address': $v_number__address,
                                                },
                                                'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                                    const $p_right__hand__side = pl.cc($['right hand side'], ($) => map_Numerical__Expression__Or__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                                                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                                                    const $v_right__hand__side = [true, $p_right__hand__side];
                                                    return {
                                                        'right hand side': $p_right__hand__side,
                                                    };
                                                })),
                                            };
                                        })];
                                });
                                default: return pl.au($[0]);
                            }
                        }));
                        const $v_action = [true, $p_action];
                        return {
                            'action': $p_action,
                            'address': $p_address,
                        };
                    })]);
                default: return pl.au($[0]);
            }
        }));
    }
    function map_String__Expression($, $v_namespace, $v_variable__stack) {
        return pl.cc($, ($) => {
            switch ($[0]) {
                case 'string literal': return pl.ss($, ($) => ['string literal', $]);
                default: return pl.au($[0]);
            }
        });
    }
    function map_String__Expression__Or__Selection($, $v_namespace, $v_variable__stack) {
        return pl.cc($, ($) => {
            switch ($[0]) {
                case 'expression': return pl.ss($, ($) => ['expression', map_String__Expression($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                    tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false]))]);
                case 'selection': return pl.ss($, ($) => ['selection', pl.cc($, ($) => {
                        const $p_selection = pl.cc($['selection'], ($) => map_Address__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                        tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                        const $v_selection = [true, $p_selection];
                        const $p_cast__to__string = pl.cc($['cast to string'], ($) => pl.cc($, ($) => {
                            switch ($[0]) {
                                case 'string': return pl.ss($, ($) => {
                                    const /*option constraint*/ $v__lstring = pl.cc($, ($) => {
                                        const optConstraint = tempoptional /*3*/($v_selection, ($) => tempoptional($.result, ($) => ($[0] === 'string')
                                            ? [true, $[1]]
                                            : pl.cc($, ($) => {
                                                $se.error("option constraint");
                                                return [false];
                                            }), () => [false]), () => [false]);
                                        return optConstraint;
                                    });
                                    return ['string', pl.cc($, ($) => {
                                            return {
                                                'annotation': $.annotation,
                                                'constraints': {
                                                    'string': $v__lstring,
                                                },
                                                'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                                                    return null;
                                                })),
                                            };
                                        })];
                                });
                                default: return pl.au($[0]);
                            }
                        }));
                        const $v_cast__to__string = [true, $p_cast__to__string];
                        return {
                            'cast to string': $p_cast__to__string,
                            'selection': $p_selection,
                        };
                    })]);
                default: return pl.au($[0]);
            }
        });
    }
    function map_Type__Arguments($, $v_namespace, $v_type__parameters) {
        return $d.resolveDictionary($, { 'map': ($, $l) => {
                const entrykey = $.key;
                return pl.cc($.value, ($) => {
                    const /*dict constraint*/ $v_x = tempoptional /*3*/($v_type__parameters, ($) => $.__getEntry(entrykey, ($) => [true, $], () => {
                        $se.error("no such entry");
                        return [false];
                    }), () => [false]);
                    return {
                        'annotation': $.annotation,
                        'constraints': {
                            'x': $v_x,
                        },
                        'content': pl.cc($.content, ($) => pl.cc($, ($) => {
                            const $p__ltype = pl.cc($['type'], ($) => map_Type__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false])));
                            const $v__ltype = [true, $p__ltype];
                            return {
                                'type': $p__ltype,
                            };
                        })),
                    };
                });
            } });
    }
    function map_Type__Selection($, $v_namespace) {
        const content = pl.cc($, ($) => {
            switch ($[0]) {
                case 'child namespace': return pl.ss($, ($) => {
                    const stateData = pl.cc($, ($) => {
                        const $p_namespacex = pl.cc($['namespacex'], ($) => pl.cc($, ($) => {
                            const refkey = $.key;
                            const constraint = tempoptional /*3*/($v_namespace, ($) => pl.cc($['namespaces'], ($) => $.__getEntry(refkey, ($) => [true, $], () => {
                                $se.error("no such entry");
                                return [false];
                            })), () => [false]);
                            return {
                                'annotation': $.annotation,
                                'constraint': constraint,
                                'key': $.key,
                            };
                        }));
                        const $v_namespacex = [true, $p_namespacex];
                        const $p_selection = pl.cc($['selection'], ($) => map_Type__Selection($, tempoptional /*3*/($v_namespacex, ($) => tempoptional /*1*/($.constraint, ($) => [true, $], () => [false]), () => [false])));
                        const $v_selection = [true, $p_selection];
                        return {
                            'namespacex': $p_namespacex,
                            'selection': $p_selection,
                        };
                    });
                    return {
                        'content': ['child namespace', stateData],
                        'result': pl.cc(stateData, ($) => pl.cc($['selection'], ($) => tempoptional($.result, ($) => [true, $], () => [false]))),
                    };
                });
                case 'current namespace': return pl.ss($, ($) => {
                    const stateData = pl.cc($, ($) => {
                        const refkey = $.key;
                        const constraint = tempoptional /*3*/($v_namespace, ($) => pl.cc($['types'], ($) => $.__getEntry(refkey, ($) => [true, $], () => {
                            $se.error("no such entry");
                            return [false];
                        })), () => [false]);
                        return {
                            'annotation': $.annotation,
                            'constraint': constraint,
                            'key': $.key,
                        };
                    });
                    return {
                        'content': ['current namespace', stateData],
                        'result': pl.cc(stateData, ($) => tempoptional /*1*/($.constraint, ($) => [true, $], () => [false])),
                    };
                });
                default: return pl.au($[0]);
            }
        });
        return {
            'content': content,
            'result': pl.cc(content, ($) => tempoptional($.result, ($) => [true, $], () => [false])),
        };
    }
    function map_Variables($, $v_namespace, $v_variable__stack) {
        return $d.resolveDictionary($, { 'map': ($, $l) => pl.cc($.value, ($) => pl.cc($, ($) => {
                const $p__ltype = pl.cc($['type'], ($) => pl.cc($, ($) => {
                    switch ($[0]) {
                        case 'local': return pl.ss($, ($) => {
                            const stateData = pl.cc($, ($) => {
                                const $p__ltype = pl.cc($['type'], ($) => map_Type__Selection($, tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false])));
                                const $v__ltype = [true, $p__ltype];
                                const $p_initializer = pl.cc($['initializer'], ($) => map_Expression($, tempoptional /*3*/($v__ltype, ($) => tempoptional($.result, ($) => [true, $], () => [false]), () => [false]), //$v_expected__type
                                tempoptional /*3*/($v_namespace, ($) => [true, $], () => [false]), //$v_namespace
                                tempoptional /*3*/($v_variable__stack, ($) => [true, $], () => [false])));
                                const $v_initializer = [true, $p_initializer];
                                return {
                                    'initializer': $p_initializer,
                                    'type': $p__ltype,
                                };
                            });
                            return {
                                'content': ['local', stateData],
                                'result': pl.cc(stateData, ($) => pl.cc($['type'], ($) => tempoptional($.result, ($) => [true, $], () => [false]))),
                            };
                        });
                        case 'variable stack2': return pl.ss($, ($) => {
                            const stateData = pl.cc($, ($) => {
                                const $p_variable = pl.cc($['variable'], ($) => pl.cc($, ($) => {
                                    const refkey = $.key;
                                    const constraint = tempoptional /*3*/($v_variable__stack, ($) => $.__getEntry(refkey, ($) => [true, $], () => {
                                        $se.error("no such entry");
                                        return [false];
                                    }), () => [false]);
                                    return {
                                        'annotation': $.annotation,
                                        'constraint': constraint,
                                        'key': $.key,
                                    };
                                }));
                                const $v_variable = [true, $p_variable];
                                return {
                                    'variable': $p_variable,
                                };
                            });
                            return {
                                'content': ['variable stack2', stateData],
                                'result': pl.cc(stateData, ($) => pl.cc($['variable'], ($) => tempoptional /*1*/($.constraint, ($) => pl.cc($['type'], ($) => tempoptional($.result, ($) => [true, $], () => [false])), () => [false]))),
                            };
                        });
                        default: return pl.au($[0]);
                    }
                }));
                const $v__ltype = [true, $p__ltype];
                return {
                    'type': $p__ltype,
                };
            })) });
    }
    return map_Source__File;
};
exports.$$ = $$;
