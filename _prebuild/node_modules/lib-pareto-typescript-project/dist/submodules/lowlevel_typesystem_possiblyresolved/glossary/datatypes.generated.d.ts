import * as pt from 'pareto-core-types';
export declare namespace N {
    namespace Function_$_$Declaration {
        namespace N {
            namespace G {
                namespace N {
                    namespace context {
                        namespace N { }
                        namespace T { }
                    }
                    namespace parameters {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace type_$_$parameters {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Namespace {
        namespace N {
            namespace G {
                namespace N {
                    namespace namespaces {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace parameters {
                        namespace N { }
                        namespace T { }
                    }
                    namespace types {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type {
        namespace N {
            namespace TU {
                namespace N {
                    namespace address_$_$function {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace declaration {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace return_$_$type {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace array {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$lboolean {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace dictionary {
                        namespace N { }
                        namespace T { }
                    }
                    namespace group {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lnull {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lnumber {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace optional {
                        namespace N { }
                        namespace T { }
                    }
                    namespace procedure {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace declaration {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lstring {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace tagged_$_$union {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace type_$_$reference {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace _$ltype {
                                        namespace N {
                                            namespace TU {
                                                namespace N {
                                                    namespace cyclic_$_$sibling {
                                                        namespace N {
                                                            namespace G {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                    namespace external {
                                                        namespace N {
                                                            namespace G {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                    namespace sibling {
                                                        namespace N {
                                                            namespace G {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace value_$_$function {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace declaration {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace return_$_$type {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Parameters {
        namespace N {
            namespace D {
                namespace N { }
                namespace T { }
            }
        }
        namespace T { }
    }
}
export declare namespace T {
    namespace Function__Declaration {
        type context<GAnnotation> = T.Type<GAnnotation>;
        namespace parameters {
            type D<GAnnotation> = T.Type<GAnnotation>;
        }
        type parameters<GAnnotation> = pt.Dictionary<T.Type<GAnnotation>>;
        type type__parameters<GAnnotation> = T.Type__Parameters<GAnnotation>;
    }
    type Function__Declaration<GAnnotation> = {
        readonly 'context': T.Type<GAnnotation>;
        readonly 'parameters': pt.Dictionary<T.Type<GAnnotation>>;
        readonly 'type parameters': T.Type__Parameters<GAnnotation>;
    };
    namespace Namespace {
        namespace namespaces {
            type D<GAnnotation> = T.Namespace<GAnnotation>;
        }
        type namespaces<GAnnotation> = pt.Dictionary<T.Namespace<GAnnotation>>;
        type parameters<GAnnotation> = T.Type__Parameters<GAnnotation>;
        namespace types {
            type D<GAnnotation> = T.Type<GAnnotation>;
        }
        type types<GAnnotation> = pt.Dictionary<T.Type<GAnnotation>>;
    }
    type Namespace<GAnnotation> = {
        readonly 'namespaces': pt.Dictionary<T.Namespace<GAnnotation>>;
        readonly 'parameters': T.Type__Parameters<GAnnotation>;
        readonly 'types': pt.Dictionary<T.Type<GAnnotation>>;
    };
    namespace Type {
        namespace address__function {
            type declaration<GAnnotation> = T.Function__Declaration<GAnnotation>;
            type return__type<GAnnotation> = T.Type<GAnnotation>;
        }
        type address__function<GAnnotation> = {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
            readonly 'return type': T.Type<GAnnotation>;
        };
        type array<GAnnotation> = T.Type<GAnnotation>;
        namespace _lboolean { }
        type _lboolean<GAnnotation> = null;
        type dictionary<GAnnotation> = T.Type<GAnnotation>;
        namespace group {
            type D<GAnnotation> = T.Type<GAnnotation>;
        }
        type group<GAnnotation> = pt.Dictionary<T.Type<GAnnotation>>;
        namespace _lnull { }
        type _lnull<GAnnotation> = null;
        namespace _lnumber { }
        type _lnumber<GAnnotation> = null;
        type optional<GAnnotation> = T.Type<GAnnotation>;
        namespace procedure {
            type declaration<GAnnotation> = T.Function__Declaration<GAnnotation>;
        }
        type procedure<GAnnotation> = {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
        };
        namespace _lstring { }
        type _lstring<GAnnotation> = null;
        namespace tagged__union {
            type D<GAnnotation> = T.Type<GAnnotation>;
        }
        type tagged__union<GAnnotation> = pt.Dictionary<T.Type<GAnnotation>>;
        namespace type__reference {
            namespace _ltype {
                namespace cyclic__sibling { }
                type cyclic__sibling<GAnnotation> = null;
                namespace external { }
                type external<GAnnotation> = null;
                namespace sibling { }
                type sibling<GAnnotation> = null;
            }
            type _ltype<GAnnotation> = ['cyclic sibling', null] | ['external', null] | ['sibling', null];
        }
        type type__reference<GAnnotation> = {
            readonly 'type': ['cyclic sibling', null] | ['external', null] | ['sibling', null];
        };
        namespace value__function {
            type declaration<GAnnotation> = T.Function__Declaration<GAnnotation>;
            type return__type<GAnnotation> = T.Type<GAnnotation>;
        }
        type value__function<GAnnotation> = {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
            readonly 'return type': T.Type<GAnnotation>;
        };
    }
    type Type<GAnnotation> = [
        'address function',
        {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
            readonly 'return type': T.Type<GAnnotation>;
        }
    ] | ['array', T.Type<GAnnotation>] | ['boolean', null] | ['dictionary', T.Type<GAnnotation>] | ['group', pt.Dictionary<T.Type<GAnnotation>>] | ['null', null] | ['number', null] | ['optional', T.Type<GAnnotation>] | [
        'procedure',
        {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
        }
    ] | ['string', null] | ['tagged union', pt.Dictionary<T.Type<GAnnotation>>] | [
        'type reference',
        {
            readonly 'type': ['cyclic sibling', null] | ['external', null] | ['sibling', null];
        }
    ] | [
        'value function',
        {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
            readonly 'return type': T.Type<GAnnotation>;
        }
    ];
    namespace Type__Parameters {
        type D<GAnnotation> = T.Type<GAnnotation>;
    }
    type Type__Parameters<GAnnotation> = pt.Dictionary<T.Type<GAnnotation>>;
}
