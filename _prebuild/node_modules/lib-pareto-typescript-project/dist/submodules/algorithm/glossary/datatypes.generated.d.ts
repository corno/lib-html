import * as pt from 'pareto-core-types';
export declare namespace N { }
export declare namespace T {
    namespace AsynchronousExpression {
        namespace call {
            type _lfunction<GAnnotation> = string;
        }
        type call<GAnnotation> = {
            readonly 'function': string;
        };
    }
    type AsynchronousExpression<GAnnotation> = [
        'call',
        {
            readonly 'function': string;
        }
    ];
    namespace AsynchronousFunctionBlock {
        namespace innerFunctions {
            namespace D {
                type block<GAnnotation> = T.AsynchronousFunctionBlock<GAnnotation>;
            }
            type D<GAnnotation> = {
                readonly 'block': T.AsynchronousFunctionBlock<GAnnotation>;
            };
        }
        type innerFunctions<GAnnotation> = pt.Dictionary<{
            readonly 'block': T.AsynchronousFunctionBlock<GAnnotation>;
        }>;
        type returnExpression<GAnnotation> = T.AsynchronousExpression<GAnnotation>;
    }
    type AsynchronousFunctionBlock<GAnnotation> = {
        readonly 'innerFunctions': pt.Dictionary<{
            readonly 'block': T.AsynchronousFunctionBlock<GAnnotation>;
        }>;
        readonly 'returnExpression': T.AsynchronousExpression<GAnnotation>;
    };
    namespace Implementation {
        namespace implementations {
            namespace D {
                type _lconstructor<GAnnotation> = boolean;
                type _ltype<GAnnotation> = T.ImplementationType<GAnnotation>;
            }
            type D<GAnnotation> = {
                readonly 'constructor': boolean;
                readonly 'type': T.ImplementationType<GAnnotation>;
            };
        }
        type implementations<GAnnotation> = pt.Dictionary<{
            readonly 'constructor': boolean;
            readonly 'type': T.ImplementationType<GAnnotation>;
        }>;
    }
    type Implementation<GAnnotation> = {
        readonly 'implementations': pt.Dictionary<{
            readonly 'constructor': boolean;
            readonly 'type': T.ImplementationType<GAnnotation>;
        }>;
    };
    namespace ImplementationType {
        namespace asynchronous__function {
            type block<GAnnotation> = T.AsynchronousFunctionBlock<GAnnotation>;
        }
        type asynchronous__function<GAnnotation> = {
            readonly 'block': T.AsynchronousFunctionBlock<GAnnotation>;
        };
        namespace interface__initializer {
            type block<GAnnotation> = T.InterfaceInitializerBlock<GAnnotation>;
        }
        type interface__initializer<GAnnotation> = {
            readonly 'block': T.InterfaceInitializerBlock<GAnnotation>;
        };
        namespace procedure {
            type block<GAnnotation> = T.ProcedureBlock<GAnnotation>;
        }
        type procedure<GAnnotation> = {
            readonly 'block': T.ProcedureBlock<GAnnotation>;
        };
        namespace synchronous__function {
            type block<GAnnotation> = T.SynchronousFunctionBlock<GAnnotation>;
        }
        type synchronous__function<GAnnotation> = {
            readonly 'block': T.SynchronousFunctionBlock<GAnnotation>;
        };
    }
    type ImplementationType<GAnnotation> = [
        'asynchronous function',
        {
            readonly 'block': T.AsynchronousFunctionBlock<GAnnotation>;
        }
    ] | [
        'interface initializer',
        {
            readonly 'block': T.InterfaceInitializerBlock<GAnnotation>;
        }
    ] | [
        'procedure',
        {
            readonly 'block': T.ProcedureBlock<GAnnotation>;
        }
    ] | [
        'synchronous function',
        {
            readonly 'block': T.SynchronousFunctionBlock<GAnnotation>;
        }
    ];
    namespace InterfaceInitializerBlock {
        namespace call {
            type _lfunction<GAnnotation> = string;
        }
        type call<GAnnotation> = {
            readonly 'function': string;
        };
    }
    type InterfaceInitializerBlock<GAnnotation> = [
        'call',
        {
            readonly 'function': string;
        }
    ];
    namespace ProcedureBlock {
        namespace innerFunctions {
            namespace D {
                type _ltype<GAnnotation> = T.ImplementationType<GAnnotation>;
            }
            type D<GAnnotation> = {
                readonly 'type': T.ImplementationType<GAnnotation>;
            };
        }
        type innerFunctions<GAnnotation> = pt.Dictionary<{
            readonly 'type': T.ImplementationType<GAnnotation>;
        }>;
        namespace statements {
            namespace A {
                namespace dependencyCall {
                    type callback<GAnnotation> = T.ProcedureBlock<GAnnotation>;
                    type data<GAnnotation> = string;
                }
                type dependencyCall<GAnnotation> = {
                    readonly 'callback': T.ProcedureBlock<GAnnotation>;
                    readonly 'data': string;
                };
                namespace innerCallbackCall {
                    type data<GAnnotation> = T.SynchronousExpression<GAnnotation>;
                    type innerCallback<GAnnotation> = string;
                    type _linterface<GAnnotation> = string;
                }
                type innerCallbackCall<GAnnotation> = {
                    readonly 'data': T.SynchronousExpression<GAnnotation>;
                    readonly 'innerCallback': string;
                    readonly 'interface': string;
                };
                namespace interfaceCall {
                    namespace callback {
                        type O<GAnnotation> = T.ProcedureBlock<GAnnotation>;
                    }
                    type callback<GAnnotation> = [false] | [true, T.ProcedureBlock<GAnnotation>];
                    namespace child__path {
                        type A<GAnnotation> = string;
                    }
                    type child__path<GAnnotation> = pt.Array<string>;
                    namespace data {
                        type O<GAnnotation> = T.SynchronousExpression<GAnnotation>;
                    }
                    type data<GAnnotation> = [false] | [true, T.SynchronousExpression<GAnnotation>];
                }
                type interfaceCall<GAnnotation> = {
                    readonly 'callback': [false] | [true, T.ProcedureBlock<GAnnotation>];
                    readonly 'child path': pt.Array<string>;
                    readonly 'data': [false] | [true, T.SynchronousExpression<GAnnotation>];
                };
                namespace _lswitch {
                    namespace cases {
                        type D<GAnnotation> = T.ProcedureBlock<GAnnotation>;
                    }
                    type cases<GAnnotation> = pt.Dictionary<T.ProcedureBlock<GAnnotation>>;
                    namespace path {
                        type A<GAnnotation> = string;
                    }
                    type path<GAnnotation> = pt.Array<string>;
                }
                type _lswitch<GAnnotation> = {
                    readonly 'cases': pt.Dictionary<T.ProcedureBlock<GAnnotation>>;
                    readonly 'path': pt.Array<string>;
                };
            }
            type A<GAnnotation> = [
                'dependencyCall',
                {
                    readonly 'callback': T.ProcedureBlock<GAnnotation>;
                    readonly 'data': string;
                }
            ] | [
                'innerCallbackCall',
                {
                    readonly 'data': T.SynchronousExpression<GAnnotation>;
                    readonly 'innerCallback': string;
                    readonly 'interface': string;
                }
            ] | [
                'interfaceCall',
                {
                    readonly 'callback': [false] | [true, T.ProcedureBlock<GAnnotation>];
                    readonly 'child path': pt.Array<string>;
                    readonly 'data': [false] | [true, T.SynchronousExpression<GAnnotation>];
                }
            ] | [
                'switch',
                {
                    readonly 'cases': pt.Dictionary<T.ProcedureBlock<GAnnotation>>;
                    readonly 'path': pt.Array<string>;
                }
            ];
        }
        type statements<GAnnotation> = pt.Array<[
            'dependencyCall',
            {
                readonly 'callback': T.ProcedureBlock<GAnnotation>;
                readonly 'data': string;
            }
        ] | [
            'innerCallbackCall',
            {
                readonly 'data': T.SynchronousExpression<GAnnotation>;
                readonly 'innerCallback': string;
                readonly 'interface': string;
            }
        ] | [
            'interfaceCall',
            {
                readonly 'callback': [false] | [true, T.ProcedureBlock<GAnnotation>];
                readonly 'child path': pt.Array<string>;
                readonly 'data': [false] | [true, T.SynchronousExpression<GAnnotation>];
            }
        ] | [
            'switch',
            {
                readonly 'cases': pt.Dictionary<T.ProcedureBlock<GAnnotation>>;
                readonly 'path': pt.Array<string>;
            }
        ]>;
    }
    type ProcedureBlock<GAnnotation> = {
        readonly 'innerFunctions': pt.Dictionary<{
            readonly 'type': T.ImplementationType<GAnnotation>;
        }>;
        readonly 'statements': pt.Array<[
            'dependencyCall',
            {
                readonly 'callback': T.ProcedureBlock<GAnnotation>;
                readonly 'data': string;
            }
        ] | [
            'innerCallbackCall',
            {
                readonly 'data': T.SynchronousExpression<GAnnotation>;
                readonly 'innerCallback': string;
                readonly 'interface': string;
            }
        ] | [
            'interfaceCall',
            {
                readonly 'callback': [false] | [true, T.ProcedureBlock<GAnnotation>];
                readonly 'child path': pt.Array<string>;
                readonly 'data': [false] | [true, T.SynchronousExpression<GAnnotation>];
            }
        ] | [
            'switch',
            {
                readonly 'cases': pt.Dictionary<T.ProcedureBlock<GAnnotation>>;
                readonly 'path': pt.Array<string>;
            }
        ]>;
    };
    namespace States {
        type D<GAnnotation> = T.Type<GAnnotation>;
    }
    type States<GAnnotation> = pt.Dictionary<T.Type<GAnnotation>>;
    namespace SynchronousExpression {
        namespace call {
            type _lfunction<GAnnotation> = string;
        }
        type call<GAnnotation> = {
            readonly 'function': string;
        };
        namespace contextChange {
            type block<GAnnotation> = T.SynchronousFunctionBlock<GAnnotation>;
            type property<GAnnotation> = string;
        }
        type contextChange<GAnnotation> = {
            readonly 'block': T.SynchronousFunctionBlock<GAnnotation>;
            readonly 'property': string;
        };
        namespace groupInitializer {
            namespace properties {
                type D<GAnnotation> = T.SynchronousExpression<GAnnotation>;
            }
            type properties<GAnnotation> = pt.Dictionary<T.SynchronousExpression<GAnnotation>>;
        }
        type groupInitializer<GAnnotation> = {
            readonly 'properties': pt.Dictionary<T.SynchronousExpression<GAnnotation>>;
        };
        type implementMe<GAnnotation> = string;
        namespace mapArray {
            type block<GAnnotation> = T.SynchronousFunctionBlock<GAnnotation>;
        }
        type mapArray<GAnnotation> = {
            readonly 'block': T.SynchronousFunctionBlock<GAnnotation>;
        };
        namespace mapDictionary {
            type block<GAnnotation> = T.SynchronousFunctionBlock<GAnnotation>;
        }
        type mapDictionary<GAnnotation> = {
            readonly 'block': T.SynchronousFunctionBlock<GAnnotation>;
        };
        namespace propertySelection {
            type name<GAnnotation> = string;
        }
        type propertySelection<GAnnotation> = {
            readonly 'name': string;
        };
        type string__literal<GAnnotation> = string;
        namespace _lswitch {
            namespace cases {
                type D<GAnnotation> = T.SynchronousFunctionBlock<GAnnotation>;
            }
            type cases<GAnnotation> = pt.Dictionary<T.SynchronousFunctionBlock<GAnnotation>>;
        }
        type _lswitch<GAnnotation> = {
            readonly 'cases': pt.Dictionary<T.SynchronousFunctionBlock<GAnnotation>>;
        };
    }
    type SynchronousExpression<GAnnotation> = [
        'call',
        {
            readonly 'function': string;
        }
    ] | [
        'contextChange',
        {
            readonly 'block': T.SynchronousFunctionBlock<GAnnotation>;
            readonly 'property': string;
        }
    ] | [
        'groupInitializer',
        {
            readonly 'properties': pt.Dictionary<T.SynchronousExpression<GAnnotation>>;
        }
    ] | ['implementMe', string] | [
        'mapArray',
        {
            readonly 'block': T.SynchronousFunctionBlock<GAnnotation>;
        }
    ] | [
        'mapDictionary',
        {
            readonly 'block': T.SynchronousFunctionBlock<GAnnotation>;
        }
    ] | [
        'propertySelection',
        {
            readonly 'name': string;
        }
    ] | ['string literal', string] | [
        'switch',
        {
            readonly 'cases': pt.Dictionary<T.SynchronousFunctionBlock<GAnnotation>>;
        }
    ];
    namespace SynchronousFunctionBlock {
        namespace innerFunctions {
            namespace D {
                type block<GAnnotation> = T.SynchronousFunctionBlock<GAnnotation>;
            }
            type D<GAnnotation> = {
                readonly 'block': T.SynchronousFunctionBlock<GAnnotation>;
            };
        }
        type innerFunctions<GAnnotation> = pt.Dictionary<{
            readonly 'block': T.SynchronousFunctionBlock<GAnnotation>;
        }>;
        type returnExpression<GAnnotation> = T.SynchronousExpression<GAnnotation>;
    }
    type SynchronousFunctionBlock<GAnnotation> = {
        readonly 'innerFunctions': pt.Dictionary<{
            readonly 'block': T.SynchronousFunctionBlock<GAnnotation>;
        }>;
        readonly 'returnExpression': T.SynchronousExpression<GAnnotation>;
    };
    namespace Type {
        type array<GAnnotation> = T.Type<GAnnotation>;
        namespace _lboolean { }
        type _lboolean<GAnnotation> = null;
        type dictionary<GAnnotation> = T.Type<GAnnotation>;
        namespace group {
            namespace D {
                type _ltype<GAnnotation> = T.Type<GAnnotation>;
            }
            type D<GAnnotation> = {
                readonly 'type': T.Type<GAnnotation>;
            };
        }
        type group<GAnnotation> = pt.Dictionary<{
            readonly 'type': T.Type<GAnnotation>;
        }>;
        namespace _lnull { }
        type _lnull<GAnnotation> = null;
        namespace _lnumber { }
        type _lnumber<GAnnotation> = null;
        type optional<GAnnotation> = T.Type<GAnnotation>;
        type parameter<GAnnotation> = string;
        type reference<GAnnotation> = string;
        namespace _lstring { }
        type _lstring<GAnnotation> = null;
        namespace taggedUnion {
            type D<GAnnotation> = T.Type<GAnnotation>;
        }
        type taggedUnion<GAnnotation> = pt.Dictionary<T.Type<GAnnotation>>;
    }
    type Type<GAnnotation> = ['array', T.Type<GAnnotation>] | ['boolean', null] | ['dictionary', T.Type<GAnnotation>] | [
        'group',
        pt.Dictionary<{
            readonly 'type': T.Type<GAnnotation>;
        }>
    ] | ['null', null] | ['number', null] | ['optional', T.Type<GAnnotation>] | ['parameter', string] | ['reference', string] | ['string', null] | ['taggedUnion', pt.Dictionary<T.Type<GAnnotation>>];
}
