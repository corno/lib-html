import * as pt from 'pareto-core-types';
import * as g_typesystem from "../../lowlevel_typesystem";
export declare namespace N {
    namespace A_$_$dictionary_$_$with_$_$constraint {
        namespace N {
            namespace G {
                namespace N {
                    namespace constrained_$_$dict {
                        namespace N {
                            namespace D {
                                namespace N {
                                    namespace G {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace dict {
                        namespace N {
                            namespace D {
                                namespace N {
                                    namespace G {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace A_$_$optional_$_$with_$_$result {
        namespace N {
            namespace G {
                namespace N {
                    namespace opt {
                        namespace N {
                            namespace O {
                                namespace N {
                                    namespace G {
                                        namespace N {
                                            namespace rslt {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace A_$_$Result {
        namespace N {
            namespace G {
                namespace N {
                    namespace foo {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace A_$_$tagged_$_$union_$_$with_$_$constrained_$_$option {
        namespace N {
            namespace G {
                namespace N {
                    namespace tu1 {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace a {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace bar {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace tu2 {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace a {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace rslt {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace A_$_$tagged_$_$union_$_$with_$_$constrained_$_$option_$_$and_$_$result {
        namespace N {
            namespace G {
                namespace N {
                    namespace tu1 {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace a {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace bar {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace tu2 {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace a {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace rslt {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace A_$_$tagged_$_$union_$_$with_$_$result {
        namespace N {
            namespace G {
                namespace N {
                    namespace tu {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace a {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace rslt {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Address_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace tail {
                        namespace N { }
                        namespace T { }
                    }
                    namespace variable {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Address_$_$Selection_$_$Tail {
        namespace N {
            namespace O {
                namespace N {
                    namespace G {
                        namespace N {
                            namespace step {
                                namespace N {
                                    namespace TU {
                                        namespace N {
                                            namespace call {
                                                namespace N {
                                                    namespace G {
                                                        namespace N {
                                                            namespace type_$_$arguments {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                            namespace property {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                            namespace tail {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Assign {
        namespace N {
            namespace G {
                namespace N {
                    namespace right_$_$hand_$_$side {
                        namespace N { }
                        namespace T { }
                    }
                    namespace target {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Block {
        namespace N {
            namespace G {
                namespace N {
                    namespace statements {
                        namespace N { }
                        namespace T { }
                    }
                    namespace variables {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Boolean_$_$Expression {
        namespace N {
            namespace TU {
                namespace N {
                    namespace and {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace left_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace right_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lfalse {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace greater_$_$than {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace left_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace right_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace less_$_$than {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace left_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace right_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace not {
                        namespace N { }
                        namespace T { }
                    }
                    namespace number_$_$equals {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace left_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace right_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace number_$_$not_$_$equals {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace left_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace right_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace or {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace left_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace right_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace string_$_$equals {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace left_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace right_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace string_$_$not_$_$equals {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace left_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace right_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$ltrue {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Boolean_$_$Expression_$_$Or_$_$Selection {
        namespace N {
            namespace TU {
                namespace N {
                    namespace expression {
                        namespace N { }
                        namespace T { }
                    }
                    namespace selection {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace cast_$_$to_$_$boolean {
                                        namespace N {
                                            namespace TU {
                                                namespace N {
                                                    namespace _$lboolean {
                                                        namespace N {
                                                            namespace G {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace selection {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Expression {
        namespace N {
            namespace TU {
                namespace N {
                    namespace array_$_$literal {
                        namespace N {
                            namespace A {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lboolean {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$lnull {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace numerical {
                        namespace N { }
                        namespace T { }
                    }
                    namespace object_$_$literal {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace properties {
                                        namespace N {
                                            namespace D {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lstring {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Numerical_$_$Expression {
        namespace N {
            namespace TU {
                namespace N {
                    namespace minus {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace left_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace right_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace numeric_$_$literal {
                        namespace N { }
                        namespace T { }
                    }
                    namespace plus {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace left_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace right_$_$hand_$_$side {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace postdecrement {
                        namespace N { }
                        namespace T { }
                    }
                    namespace postincrement {
                        namespace N { }
                        namespace T { }
                    }
                    namespace predecrement {
                        namespace N { }
                        namespace T { }
                    }
                    namespace preincrement {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Numerical_$_$Expression_$_$Or_$_$Selection {
        namespace N {
            namespace TU {
                namespace N {
                    namespace expression {
                        namespace N { }
                        namespace T { }
                    }
                    namespace selection {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace cast_$_$to_$_$number {
                                        namespace N {
                                            namespace TU {
                                                namespace N {
                                                    namespace _$lnumber {
                                                        namespace N {
                                                            namespace G {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace selection {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Source_$_$File {
        namespace N {
            namespace G {
                namespace N { }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Statements {
        namespace N {
            namespace A {
                namespace N {
                    namespace TU {
                        namespace N {
                            namespace block {
                                namespace N { }
                                namespace T { }
                            }
                            namespace _$lif {
                                namespace N {
                                    namespace G {
                                        namespace N {
                                            namespace condition {
                                                namespace N { }
                                                namespace T { }
                                            }
                                            namespace _$lelse {
                                                namespace N {
                                                    namespace O {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                            namespace then {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                            namespace _$lwhile {
                                namespace N {
                                    namespace G {
                                        namespace N {
                                            namespace block {
                                                namespace N { }
                                                namespace T { }
                                            }
                                            namespace condition {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                            namespace _$lwith {
                                namespace N {
                                    namespace G {
                                        namespace N {
                                            namespace action {
                                                namespace N {
                                                    namespace TU {
                                                        namespace N {
                                                            namespace assign {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                            namespace minus_$_$assign {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N {
                                                                            namespace right_$_$hand_$_$side {
                                                                                namespace N { }
                                                                                namespace T { }
                                                                            }
                                                                        }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                            namespace plus_$_$assign {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N {
                                                                            namespace right_$_$hand_$_$side {
                                                                                namespace N { }
                                                                                namespace T { }
                                                                            }
                                                                        }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                            namespace address {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace String_$_$Expression {
        namespace N {
            namespace TU {
                namespace N {
                    namespace string_$_$literal {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace String_$_$Expression_$_$Or_$_$Selection {
        namespace N {
            namespace TU {
                namespace N {
                    namespace expression {
                        namespace N { }
                        namespace T { }
                    }
                    namespace selection {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace cast_$_$to_$_$string {
                                        namespace N {
                                            namespace TU {
                                                namespace N {
                                                    namespace _$lstring {
                                                        namespace N {
                                                            namespace G {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace selection {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Arguments {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N {
                            namespace _$ltype {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Selection {
        namespace N {
            namespace TU {
                namespace N {
                    namespace child_$_$namespace {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace namespacex {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace selection {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace current_$_$namespace {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Variables {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N {
                            namespace _$ltype {
                                namespace N {
                                    namespace TU {
                                        namespace N {
                                            namespace local {
                                                namespace N {
                                                    namespace G {
                                                        namespace N {
                                                            namespace initializer {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                            namespace _$ltype {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                            namespace variable_$_$stack2 {
                                                namespace N {
                                                    namespace G {
                                                        namespace N {
                                                            namespace variable {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
}
export declare namespace T {
    namespace A__dictionary__with__constraint {
        namespace constrained__dict {
            namespace D {
                type annotation<GAnnotation> = GAnnotation;
                namespace constraints {
                    namespace a__constraint {
                        type O<GAnnotation> = T.A__dictionary__with__constraint.dict.D<GAnnotation>;
                    }
                    type a__constraint<GAnnotation> = [false] | [true, T.A__dictionary__with__constraint.dict.D<GAnnotation>];
                }
                type constraints<GAnnotation> = {
                    readonly 'a constraint': [false] | [true, T.A__dictionary__with__constraint.dict.D<GAnnotation>];
                };
                namespace content { }
                type content<GAnnotation> = null;
            }
            type D<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'constraints': {
                    readonly 'a constraint': [false] | [true, T.A__dictionary__with__constraint.dict.D<GAnnotation>];
                };
                readonly 'content': null;
            };
        }
        type constrained__dict<GAnnotation> = pt.Dictionary<{
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'a constraint': [false] | [true, T.A__dictionary__with__constraint.dict.D<GAnnotation>];
            };
            readonly 'content': null;
        }>;
        namespace dict {
            namespace D { }
            type D<GAnnotation> = null;
        }
        type dict<GAnnotation> = pt.Dictionary<null>;
    }
    type A__dictionary__with__constraint<GAnnotation> = {
        readonly 'constrained dict': pt.Dictionary<{
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'a constraint': [false] | [true, T.A__dictionary__with__constraint.dict.D<GAnnotation>];
            };
            readonly 'content': null;
        }>;
        readonly 'dict': pt.Dictionary<null>;
    };
    namespace A__optional__with__result {
        namespace opt {
            namespace content {
                namespace O {
                    type rslt<GAnnotation> = T.A__Result<GAnnotation>;
                }
                type O<GAnnotation> = {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                };
            }
            type content<GAnnotation> = [false] | [
                true,
                {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                }
            ];
            namespace result {
                type O<GAnnotation> = T.A__Result<GAnnotation>;
            }
            type result<GAnnotation> = [false] | [true, T.A__Result<GAnnotation>];
        }
        type opt<GAnnotation> = {
            readonly 'content': [false] | [
                true,
                {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                }
            ];
            readonly 'result': [false] | [true, T.A__Result<GAnnotation>];
        };
    }
    type A__optional__with__result<GAnnotation> = {
        readonly 'opt': {
            readonly 'content': [false] | [
                true,
                {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                }
            ];
            readonly 'result': [false] | [true, T.A__Result<GAnnotation>];
        };
    };
    namespace A__Result {
        type foo<GAnnotation> = string;
    }
    type A__Result<GAnnotation> = {
        readonly 'foo': string;
    };
    namespace A__tagged__union__with__constrained__option {
        namespace tu1 {
            namespace a {
                type bar<GAnnotation> = string;
            }
            type a<GAnnotation> = {
                readonly 'bar': string;
            };
        }
        type tu1<GAnnotation> = [
            'a',
            {
                readonly 'bar': string;
            }
        ];
        namespace tu2 {
            namespace a {
                type annotation<GAnnotation> = GAnnotation;
                namespace constraints {
                    namespace opt__constraint {
                        type O<GAnnotation> = T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>;
                    }
                    type opt__constraint<GAnnotation> = [false] | [true, T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>];
                }
                type constraints<GAnnotation> = {
                    readonly 'opt constraint': [false] | [true, T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>];
                };
                namespace content {
                    type rslt<GAnnotation> = T.A__Result<GAnnotation>;
                }
                type content<GAnnotation> = {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                };
            }
            type a<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'constraints': {
                    readonly 'opt constraint': [false] | [true, T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>];
                };
                readonly 'content': {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                };
            };
        }
        type tu2<GAnnotation> = [
            'a',
            {
                readonly 'annotation': GAnnotation;
                readonly 'constraints': {
                    readonly 'opt constraint': [false] | [true, T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>];
                };
                readonly 'content': {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                };
            }
        ];
    }
    type A__tagged__union__with__constrained__option<GAnnotation> = {
        readonly 'tu1': [
            'a',
            {
                readonly 'bar': string;
            }
        ];
        readonly 'tu2': [
            'a',
            {
                readonly 'annotation': GAnnotation;
                readonly 'constraints': {
                    readonly 'opt constraint': [false] | [true, T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>];
                };
                readonly 'content': {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                };
            }
        ];
    };
    namespace A__tagged__union__with__constrained__option__and__result {
        namespace tu1 {
            namespace a {
                type bar<GAnnotation> = string;
            }
            type a<GAnnotation> = {
                readonly 'bar': string;
            };
        }
        type tu1<GAnnotation> = [
            'a',
            {
                readonly 'bar': string;
            }
        ];
        namespace tu2 {
            namespace content {
                namespace a {
                    type annotation<GAnnotation> = GAnnotation;
                    namespace constraints {
                        namespace opt__constraint {
                            type O<GAnnotation> = T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>;
                        }
                        type opt__constraint<GAnnotation> = [false] | [true, T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>];
                    }
                    type constraints<GAnnotation> = {
                        readonly 'opt constraint': [false] | [true, T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>];
                    };
                    namespace content {
                        type rslt<GAnnotation> = T.A__Result<GAnnotation>;
                    }
                    type content<GAnnotation> = {
                        readonly 'rslt': T.A__Result<GAnnotation>;
                    };
                }
                type a<GAnnotation> = {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'opt constraint': [false] | [true, T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>];
                    };
                    readonly 'content': {
                        readonly 'rslt': T.A__Result<GAnnotation>;
                    };
                };
            }
            type content<GAnnotation> = [
                'a',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'opt constraint': [false] | [true, T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>];
                    };
                    readonly 'content': {
                        readonly 'rslt': T.A__Result<GAnnotation>;
                    };
                }
            ];
            namespace result {
                type O<GAnnotation> = T.A__Result<GAnnotation>;
            }
            type result<GAnnotation> = [false] | [true, T.A__Result<GAnnotation>];
        }
        type tu2<GAnnotation> = {
            readonly 'content': [
                'a',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'opt constraint': [false] | [true, T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>];
                    };
                    readonly 'content': {
                        readonly 'rslt': T.A__Result<GAnnotation>;
                    };
                }
            ];
            readonly 'result': [false] | [true, T.A__Result<GAnnotation>];
        };
    }
    type A__tagged__union__with__constrained__option__and__result<GAnnotation> = {
        readonly 'tu1': [
            'a',
            {
                readonly 'bar': string;
            }
        ];
        readonly 'tu2': {
            readonly 'content': [
                'a',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'opt constraint': [false] | [true, T.A__tagged__union__with__constrained__option.tu1.a<GAnnotation>];
                    };
                    readonly 'content': {
                        readonly 'rslt': T.A__Result<GAnnotation>;
                    };
                }
            ];
            readonly 'result': [false] | [true, T.A__Result<GAnnotation>];
        };
    };
    namespace A__tagged__union__with__result {
        namespace tu {
            namespace content {
                namespace a {
                    type rslt<GAnnotation> = T.A__Result<GAnnotation>;
                }
                type a<GAnnotation> = {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                };
            }
            type content<GAnnotation> = [
                'a',
                {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                }
            ];
            namespace result {
                type O<GAnnotation> = T.A__Result<GAnnotation>;
            }
            type result<GAnnotation> = [false] | [true, T.A__Result<GAnnotation>];
        }
        type tu<GAnnotation> = {
            readonly 'content': [
                'a',
                {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                }
            ];
            readonly 'result': [false] | [true, T.A__Result<GAnnotation>];
        };
    }
    type A__tagged__union__with__result<GAnnotation> = {
        readonly 'tu': {
            readonly 'content': [
                'a',
                {
                    readonly 'rslt': T.A__Result<GAnnotation>;
                }
            ];
            readonly 'result': [false] | [true, T.A__Result<GAnnotation>];
        };
    };
    namespace Address__Selection {
        namespace content {
            type tail<GAnnotation> = T.Address__Selection__Tail<GAnnotation>;
            namespace variable {
                type annotation<GAnnotation> = GAnnotation;
                namespace constraint {
                    type O<GAnnotation> = T.Variables.D<GAnnotation>;
                }
                type constraint<GAnnotation> = [false] | [true, T.Variables.D<GAnnotation>];
                type key<GAnnotation> = string;
            }
            type variable<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'constraint': [false] | [true, T.Variables.D<GAnnotation>];
                readonly 'key': string;
            };
        }
        type content<GAnnotation> = {
            readonly 'tail': T.Address__Selection__Tail<GAnnotation>;
            readonly 'variable': {
                readonly 'annotation': GAnnotation;
                readonly 'constraint': [false] | [true, T.Variables.D<GAnnotation>];
                readonly 'key': string;
            };
        };
        namespace result {
            type O<GAnnotation> = g_typesystem.T.Type<GAnnotation>;
        }
        type result<GAnnotation> = [false] | [true, g_typesystem.T.Type<GAnnotation>];
    }
    type Address__Selection<GAnnotation> = {
        readonly 'content': {
            readonly 'tail': T.Address__Selection__Tail<GAnnotation>;
            readonly 'variable': {
                readonly 'annotation': GAnnotation;
                readonly 'constraint': [false] | [true, T.Variables.D<GAnnotation>];
                readonly 'key': string;
            };
        };
        readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
    };
    namespace Address__Selection__Tail {
        namespace content {
            namespace content {
                namespace O {
                    namespace step {
                        namespace content {
                            namespace call {
                                type annotation<GAnnotation> = GAnnotation;
                                namespace constraints {
                                    namespace address__function {
                                        type O<GAnnotation> = g_typesystem.T.Type.address__function<GAnnotation>;
                                    }
                                    type address__function<GAnnotation> = [false] | [true, g_typesystem.T.Type.address__function<GAnnotation>];
                                }
                                type constraints<GAnnotation> = {
                                    readonly 'address function': [false] | [true, g_typesystem.T.Type.address__function<GAnnotation>];
                                };
                                namespace content {
                                    type type__arguments<GAnnotation> = T.Type__Arguments<GAnnotation>;
                                }
                                type content<GAnnotation> = {
                                    readonly 'type arguments': T.Type__Arguments<GAnnotation>;
                                };
                            }
                            type call<GAnnotation> = {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'address function': [false] | [true, g_typesystem.T.Type.address__function<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'type arguments': T.Type__Arguments<GAnnotation>;
                                };
                            };
                            namespace property {
                                type annotation<GAnnotation> = GAnnotation;
                                namespace constraints {
                                    namespace group {
                                        type O<GAnnotation> = g_typesystem.T.Type.group<GAnnotation>;
                                    }
                                    type group<GAnnotation> = [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
                                }
                                type constraints<GAnnotation> = {
                                    readonly 'group': [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
                                };
                                namespace content {
                                    type annotation<GAnnotation> = GAnnotation;
                                    namespace constraint {
                                        type O<GAnnotation> = g_typesystem.T.Type.group.D<GAnnotation>;
                                    }
                                    type constraint<GAnnotation> = [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                                    type key<GAnnotation> = string;
                                }
                                type content<GAnnotation> = {
                                    readonly 'annotation': GAnnotation;
                                    readonly 'constraint': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                                    readonly 'key': string;
                                };
                            }
                            type property<GAnnotation> = {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'group': [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'annotation': GAnnotation;
                                    readonly 'constraint': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                                    readonly 'key': string;
                                };
                            };
                        }
                        type content<GAnnotation> = [
                            'call',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'address function': [false] | [true, g_typesystem.T.Type.address__function<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'type arguments': T.Type__Arguments<GAnnotation>;
                                };
                            }
                        ] | [
                            'property',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'group': [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'annotation': GAnnotation;
                                    readonly 'constraint': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                                    readonly 'key': string;
                                };
                            }
                        ];
                        namespace result {
                            type O<GAnnotation> = g_typesystem.T.Type<GAnnotation>;
                        }
                        type result<GAnnotation> = [false] | [true, g_typesystem.T.Type<GAnnotation>];
                    }
                    type step<GAnnotation> = {
                        readonly 'content': [
                            'call',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'address function': [false] | [true, g_typesystem.T.Type.address__function<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'type arguments': T.Type__Arguments<GAnnotation>;
                                };
                            }
                        ] | [
                            'property',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'group': [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'annotation': GAnnotation;
                                    readonly 'constraint': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                                    readonly 'key': string;
                                };
                            }
                        ];
                        readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
                    };
                    type tail<GAnnotation> = T.Address__Selection__Tail<GAnnotation>;
                }
                type O<GAnnotation> = {
                    readonly 'step': {
                        readonly 'content': [
                            'call',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'address function': [false] | [true, g_typesystem.T.Type.address__function<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'type arguments': T.Type__Arguments<GAnnotation>;
                                };
                            }
                        ] | [
                            'property',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'group': [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'annotation': GAnnotation;
                                    readonly 'constraint': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                                    readonly 'key': string;
                                };
                            }
                        ];
                        readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
                    };
                    readonly 'tail': T.Address__Selection__Tail<GAnnotation>;
                };
            }
            type content<GAnnotation> = [false] | [
                true,
                {
                    readonly 'step': {
                        readonly 'content': [
                            'call',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'address function': [false] | [true, g_typesystem.T.Type.address__function<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'type arguments': T.Type__Arguments<GAnnotation>;
                                };
                            }
                        ] | [
                            'property',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'group': [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'annotation': GAnnotation;
                                    readonly 'constraint': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                                    readonly 'key': string;
                                };
                            }
                        ];
                        readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
                    };
                    readonly 'tail': T.Address__Selection__Tail<GAnnotation>;
                }
            ];
            namespace result {
                type O<GAnnotation> = g_typesystem.T.Type<GAnnotation>;
            }
            type result<GAnnotation> = [false] | [true, g_typesystem.T.Type<GAnnotation>];
        }
        type content<GAnnotation> = {
            readonly 'content': [false] | [
                true,
                {
                    readonly 'step': {
                        readonly 'content': [
                            'call',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'address function': [false] | [true, g_typesystem.T.Type.address__function<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'type arguments': T.Type__Arguments<GAnnotation>;
                                };
                            }
                        ] | [
                            'property',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'group': [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'annotation': GAnnotation;
                                    readonly 'constraint': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                                    readonly 'key': string;
                                };
                            }
                        ];
                        readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
                    };
                    readonly 'tail': T.Address__Selection__Tail<GAnnotation>;
                }
            ];
            readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
        };
        namespace result {
            type O<GAnnotation> = g_typesystem.T.Type<GAnnotation>;
        }
        type result<GAnnotation> = [false] | [true, g_typesystem.T.Type<GAnnotation>];
    }
    type Address__Selection__Tail<GAnnotation> = {
        readonly 'content': {
            readonly 'content': [false] | [
                true,
                {
                    readonly 'step': {
                        readonly 'content': [
                            'call',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'address function': [false] | [true, g_typesystem.T.Type.address__function<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'type arguments': T.Type__Arguments<GAnnotation>;
                                };
                            }
                        ] | [
                            'property',
                            {
                                readonly 'annotation': GAnnotation;
                                readonly 'constraints': {
                                    readonly 'group': [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
                                };
                                readonly 'content': {
                                    readonly 'annotation': GAnnotation;
                                    readonly 'constraint': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                                    readonly 'key': string;
                                };
                            }
                        ];
                        readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
                    };
                    readonly 'tail': T.Address__Selection__Tail<GAnnotation>;
                }
            ];
            readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
        };
        readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
    };
    namespace Assign {
        type right__hand__side<GAnnotation> = T.Expression<GAnnotation>;
        type target<GAnnotation> = T.Address__Selection<GAnnotation>;
    }
    type Assign<GAnnotation> = {
        readonly 'right hand side': T.Expression<GAnnotation>;
        readonly 'target': T.Address__Selection<GAnnotation>;
    };
    namespace Block {
        type statements<GAnnotation> = T.Statements<GAnnotation>;
        type variables<GAnnotation> = T.Variables<GAnnotation>;
    }
    type Block<GAnnotation> = {
        readonly 'statements': T.Statements<GAnnotation>;
        readonly 'variables': T.Variables<GAnnotation>;
    };
    namespace Boolean__Expression {
        namespace and {
            type left__hand__side<GAnnotation> = T.Boolean__Expression__Or__Selection<GAnnotation>;
            type right__hand__side<GAnnotation> = T.Boolean__Expression__Or__Selection<GAnnotation>;
        }
        type and<GAnnotation> = {
            readonly 'left hand side': T.Boolean__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Boolean__Expression__Or__Selection<GAnnotation>;
        };
        namespace _lfalse { }
        type _lfalse<GAnnotation> = null;
        namespace greater__than {
            type left__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
            type right__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
        type greater__than<GAnnotation> = {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        };
        namespace less__than {
            type left__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
            type right__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
        type less__than<GAnnotation> = {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        };
        type not<GAnnotation> = T.Boolean__Expression__Or__Selection<GAnnotation>;
        namespace number__equals {
            type left__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
            type right__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
        type number__equals<GAnnotation> = {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        };
        namespace number__not__equals {
            type left__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
            type right__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
        type number__not__equals<GAnnotation> = {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        };
        namespace or {
            type left__hand__side<GAnnotation> = T.Boolean__Expression__Or__Selection<GAnnotation>;
            type right__hand__side<GAnnotation> = T.Boolean__Expression__Or__Selection<GAnnotation>;
        }
        type or<GAnnotation> = {
            readonly 'left hand side': T.Boolean__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Boolean__Expression__Or__Selection<GAnnotation>;
        };
        namespace string__equals {
            type left__hand__side<GAnnotation> = T.String__Expression__Or__Selection<GAnnotation>;
            type right__hand__side<GAnnotation> = T.String__Expression__Or__Selection<GAnnotation>;
        }
        type string__equals<GAnnotation> = {
            readonly 'left hand side': T.String__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.String__Expression__Or__Selection<GAnnotation>;
        };
        namespace string__not__equals {
            type left__hand__side<GAnnotation> = T.String__Expression__Or__Selection<GAnnotation>;
            type right__hand__side<GAnnotation> = T.String__Expression__Or__Selection<GAnnotation>;
        }
        type string__not__equals<GAnnotation> = {
            readonly 'left hand side': T.String__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.String__Expression__Or__Selection<GAnnotation>;
        };
        namespace _ltrue { }
        type _ltrue<GAnnotation> = null;
    }
    type Boolean__Expression<GAnnotation> = [
        'and',
        {
            readonly 'left hand side': T.Boolean__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Boolean__Expression__Or__Selection<GAnnotation>;
        }
    ] | ['false', null] | [
        'greater than',
        {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
    ] | [
        'less than',
        {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
    ] | ['not', T.Boolean__Expression__Or__Selection<GAnnotation>] | [
        'number equals',
        {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
    ] | [
        'number not equals',
        {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
    ] | [
        'or',
        {
            readonly 'left hand side': T.Boolean__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Boolean__Expression__Or__Selection<GAnnotation>;
        }
    ] | [
        'string equals',
        {
            readonly 'left hand side': T.String__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.String__Expression__Or__Selection<GAnnotation>;
        }
    ] | [
        'string not equals',
        {
            readonly 'left hand side': T.String__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.String__Expression__Or__Selection<GAnnotation>;
        }
    ] | ['true', null];
    namespace Boolean__Expression__Or__Selection {
        type expression<GAnnotation> = T.Boolean__Expression<GAnnotation>;
        namespace selection {
            namespace cast__to__boolean {
                namespace _lboolean {
                    type annotation<GAnnotation> = GAnnotation;
                    namespace constraints {
                        namespace _lboolean {
                            type O<GAnnotation> = g_typesystem.T.Type._lboolean<GAnnotation>;
                        }
                        type _lboolean<GAnnotation> = [false] | [true, g_typesystem.T.Type._lboolean<GAnnotation>];
                    }
                    type constraints<GAnnotation> = {
                        readonly 'boolean': [false] | [true, g_typesystem.T.Type._lboolean<GAnnotation>];
                    };
                    namespace content { }
                    type content<GAnnotation> = null;
                }
                type _lboolean<GAnnotation> = {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'boolean': [false] | [true, g_typesystem.T.Type._lboolean<GAnnotation>];
                    };
                    readonly 'content': null;
                };
            }
            type cast__to__boolean<GAnnotation> = [
                'boolean',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'boolean': [false] | [true, g_typesystem.T.Type._lboolean<GAnnotation>];
                    };
                    readonly 'content': null;
                }
            ];
            type selection<GAnnotation> = T.Address__Selection<GAnnotation>;
        }
        type selection<GAnnotation> = {
            readonly 'cast to boolean': [
                'boolean',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'boolean': [false] | [true, g_typesystem.T.Type._lboolean<GAnnotation>];
                    };
                    readonly 'content': null;
                }
            ];
            readonly 'selection': T.Address__Selection<GAnnotation>;
        };
    }
    type Boolean__Expression__Or__Selection<GAnnotation> = ['expression', T.Boolean__Expression<GAnnotation>] | [
        'selection',
        {
            readonly 'cast to boolean': [
                'boolean',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'boolean': [false] | [true, g_typesystem.T.Type._lboolean<GAnnotation>];
                    };
                    readonly 'content': null;
                }
            ];
            readonly 'selection': T.Address__Selection<GAnnotation>;
        }
    ];
    namespace Expression {
        namespace array__literal {
            type annotation<GAnnotation> = GAnnotation;
            namespace constraints {
                namespace out {
                    type O<GAnnotation> = g_typesystem.T.Type.array<GAnnotation>;
                }
                type out<GAnnotation> = [false] | [true, g_typesystem.T.Type.array<GAnnotation>];
            }
            type constraints<GAnnotation> = {
                readonly 'out': [false] | [true, g_typesystem.T.Type.array<GAnnotation>];
            };
            namespace content {
                type A<GAnnotation> = T.Expression<GAnnotation>;
            }
            type content<GAnnotation> = pt.Array<T.Expression<GAnnotation>>;
        }
        type array__literal<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type.array<GAnnotation>];
            };
            readonly 'content': pt.Array<T.Expression<GAnnotation>>;
        };
        namespace _lboolean {
            type annotation<GAnnotation> = GAnnotation;
            namespace constraints {
                namespace out {
                    type O<GAnnotation> = g_typesystem.T.Type._lboolean<GAnnotation>;
                }
                type out<GAnnotation> = [false] | [true, g_typesystem.T.Type._lboolean<GAnnotation>];
            }
            type constraints<GAnnotation> = {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lboolean<GAnnotation>];
            };
            type content<GAnnotation> = T.Boolean__Expression<GAnnotation>;
        }
        type _lboolean<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lboolean<GAnnotation>];
            };
            readonly 'content': T.Boolean__Expression<GAnnotation>;
        };
        namespace _lnull {
            type annotation<GAnnotation> = GAnnotation;
            namespace constraints {
                namespace out {
                    type O<GAnnotation> = g_typesystem.T.Type._lnull<GAnnotation>;
                }
                type out<GAnnotation> = [false] | [true, g_typesystem.T.Type._lnull<GAnnotation>];
            }
            type constraints<GAnnotation> = {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lnull<GAnnotation>];
            };
            namespace content { }
            type content<GAnnotation> = null;
        }
        type _lnull<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lnull<GAnnotation>];
            };
            readonly 'content': null;
        };
        namespace numerical {
            type annotation<GAnnotation> = GAnnotation;
            namespace constraints {
                namespace out {
                    type O<GAnnotation> = g_typesystem.T.Type._lnumber<GAnnotation>;
                }
                type out<GAnnotation> = [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
            }
            type constraints<GAnnotation> = {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
            };
            type content<GAnnotation> = T.Numerical__Expression<GAnnotation>;
        }
        type numerical<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
            };
            readonly 'content': T.Numerical__Expression<GAnnotation>;
        };
        namespace object__literal {
            type annotation<GAnnotation> = GAnnotation;
            namespace constraints {
                namespace out {
                    type O<GAnnotation> = g_typesystem.T.Type.group<GAnnotation>;
                }
                type out<GAnnotation> = [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
            }
            type constraints<GAnnotation> = {
                readonly 'out': [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
            };
            namespace content {
                namespace properties {
                    namespace D {
                        type annotation<GAnnotation> = GAnnotation;
                        namespace constraints {
                            namespace prop {
                                type O<GAnnotation> = g_typesystem.T.Type.group.D<GAnnotation>;
                            }
                            type prop<GAnnotation> = [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                        }
                        type constraints<GAnnotation> = {
                            readonly 'prop': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                        };
                        type content<GAnnotation> = T.Expression<GAnnotation>;
                    }
                    type D<GAnnotation> = {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraints': {
                            readonly 'prop': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                        };
                        readonly 'content': T.Expression<GAnnotation>;
                    };
                }
                type properties<GAnnotation> = pt.Dictionary<{
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'prop': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                    };
                    readonly 'content': T.Expression<GAnnotation>;
                }>;
            }
            type content<GAnnotation> = {
                readonly 'properties': pt.Dictionary<{
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'prop': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                    };
                    readonly 'content': T.Expression<GAnnotation>;
                }>;
            };
        }
        type object__literal<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
            };
            readonly 'content': {
                readonly 'properties': pt.Dictionary<{
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'prop': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                    };
                    readonly 'content': T.Expression<GAnnotation>;
                }>;
            };
        };
        namespace _lstring {
            type annotation<GAnnotation> = GAnnotation;
            namespace constraints {
                namespace out {
                    type O<GAnnotation> = g_typesystem.T.Type._lstring<GAnnotation>;
                }
                type out<GAnnotation> = [false] | [true, g_typesystem.T.Type._lstring<GAnnotation>];
            }
            type constraints<GAnnotation> = {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lstring<GAnnotation>];
            };
            type content<GAnnotation> = T.String__Expression<GAnnotation>;
        }
        type _lstring<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lstring<GAnnotation>];
            };
            readonly 'content': T.String__Expression<GAnnotation>;
        };
    }
    type Expression<GAnnotation> = [
        'array literal',
        {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type.array<GAnnotation>];
            };
            readonly 'content': pt.Array<T.Expression<GAnnotation>>;
        }
    ] | [
        'boolean',
        {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lboolean<GAnnotation>];
            };
            readonly 'content': T.Boolean__Expression<GAnnotation>;
        }
    ] | [
        'null',
        {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lnull<GAnnotation>];
            };
            readonly 'content': null;
        }
    ] | [
        'numerical',
        {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
            };
            readonly 'content': T.Numerical__Expression<GAnnotation>;
        }
    ] | [
        'object literal',
        {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type.group<GAnnotation>];
            };
            readonly 'content': {
                readonly 'properties': pt.Dictionary<{
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'prop': [false] | [true, g_typesystem.T.Type.group.D<GAnnotation>];
                    };
                    readonly 'content': T.Expression<GAnnotation>;
                }>;
            };
        }
    ] | [
        'string',
        {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'out': [false] | [true, g_typesystem.T.Type._lstring<GAnnotation>];
            };
            readonly 'content': T.String__Expression<GAnnotation>;
        }
    ];
    namespace Numerical__Expression {
        namespace minus {
            type left__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
            type right__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
        type minus<GAnnotation> = {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        };
        type numeric__literal<GAnnotation> = string;
        namespace plus {
            type left__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
            type right__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
        type plus<GAnnotation> = {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        };
        type postdecrement<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
        type postincrement<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
        type predecrement<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
        type preincrement<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
    }
    type Numerical__Expression<GAnnotation> = [
        'minus',
        {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
    ] | ['numeric literal', string] | [
        'plus',
        {
            readonly 'left hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
        }
    ] | ['postdecrement', T.Numerical__Expression__Or__Selection<GAnnotation>] | ['postincrement', T.Numerical__Expression__Or__Selection<GAnnotation>] | ['predecrement', T.Numerical__Expression__Or__Selection<GAnnotation>] | ['preincrement', T.Numerical__Expression__Or__Selection<GAnnotation>];
    namespace Numerical__Expression__Or__Selection {
        type expression<GAnnotation> = T.Numerical__Expression<GAnnotation>;
        namespace selection {
            namespace cast__to__number {
                namespace _lnumber {
                    type annotation<GAnnotation> = GAnnotation;
                    namespace constraints {
                        namespace _lnumber {
                            type O<GAnnotation> = g_typesystem.T.Type._lnumber<GAnnotation>;
                        }
                        type _lnumber<GAnnotation> = [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                    }
                    type constraints<GAnnotation> = {
                        readonly 'number': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                    };
                    namespace content { }
                    type content<GAnnotation> = null;
                }
                type _lnumber<GAnnotation> = {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'number': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                    };
                    readonly 'content': null;
                };
            }
            type cast__to__number<GAnnotation> = [
                'number',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'number': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                    };
                    readonly 'content': null;
                }
            ];
            type selection<GAnnotation> = T.Address__Selection<GAnnotation>;
        }
        type selection<GAnnotation> = {
            readonly 'cast to number': [
                'number',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'number': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                    };
                    readonly 'content': null;
                }
            ];
            readonly 'selection': T.Address__Selection<GAnnotation>;
        };
    }
    type Numerical__Expression__Or__Selection<GAnnotation> = ['expression', T.Numerical__Expression<GAnnotation>] | [
        'selection',
        {
            readonly 'cast to number': [
                'number',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'number': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                    };
                    readonly 'content': null;
                }
            ];
            readonly 'selection': T.Address__Selection<GAnnotation>;
        }
    ];
    namespace Source__File { }
    type Source__File<GAnnotation> = null;
    namespace Statements {
        namespace A {
            type block<GAnnotation> = T.Block<GAnnotation>;
            namespace _lif {
                type condition<GAnnotation> = T.Boolean__Expression__Or__Selection<GAnnotation>;
                namespace _lelse {
                    type O<GAnnotation> = T.Block<GAnnotation>;
                }
                type _lelse<GAnnotation> = [false] | [true, T.Block<GAnnotation>];
                type then<GAnnotation> = T.Block<GAnnotation>;
            }
            type _lif<GAnnotation> = {
                readonly 'condition': T.Boolean__Expression__Or__Selection<GAnnotation>;
                readonly 'else': [false] | [true, T.Block<GAnnotation>];
                readonly 'then': T.Block<GAnnotation>;
            };
            namespace _lwhile {
                type block<GAnnotation> = T.Block<GAnnotation>;
                type condition<GAnnotation> = T.Boolean__Expression__Or__Selection<GAnnotation>;
            }
            type _lwhile<GAnnotation> = {
                readonly 'block': T.Block<GAnnotation>;
                readonly 'condition': T.Boolean__Expression__Or__Selection<GAnnotation>;
            };
            namespace _lwith {
                namespace action {
                    type assign<GAnnotation> = T.Assign<GAnnotation>;
                    namespace minus__assign {
                        type annotation<GAnnotation> = GAnnotation;
                        namespace constraints {
                            namespace number__address {
                                type O<GAnnotation> = g_typesystem.T.Type._lnumber<GAnnotation>;
                            }
                            type number__address<GAnnotation> = [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        }
                        type constraints<GAnnotation> = {
                            readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        };
                        namespace content {
                            type right__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
                        }
                        type content<GAnnotation> = {
                            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                        };
                    }
                    type minus__assign<GAnnotation> = {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraints': {
                            readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        };
                        readonly 'content': {
                            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                        };
                    };
                    namespace plus__assign {
                        type annotation<GAnnotation> = GAnnotation;
                        namespace constraints {
                            namespace number__address {
                                type O<GAnnotation> = g_typesystem.T.Type._lnumber<GAnnotation>;
                            }
                            type number__address<GAnnotation> = [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        }
                        type constraints<GAnnotation> = {
                            readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        };
                        namespace content {
                            type right__hand__side<GAnnotation> = T.Numerical__Expression__Or__Selection<GAnnotation>;
                        }
                        type content<GAnnotation> = {
                            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                        };
                    }
                    type plus__assign<GAnnotation> = {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraints': {
                            readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        };
                        readonly 'content': {
                            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                        };
                    };
                }
                type action<GAnnotation> = ['assign', T.Assign<GAnnotation>] | [
                    'minus assign',
                    {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraints': {
                            readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        };
                        readonly 'content': {
                            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                        };
                    }
                ] | [
                    'plus assign',
                    {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraints': {
                            readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        };
                        readonly 'content': {
                            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                        };
                    }
                ];
                type address<GAnnotation> = T.Address__Selection<GAnnotation>;
            }
            type _lwith<GAnnotation> = {
                readonly 'action': ['assign', T.Assign<GAnnotation>] | [
                    'minus assign',
                    {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraints': {
                            readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        };
                        readonly 'content': {
                            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                        };
                    }
                ] | [
                    'plus assign',
                    {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraints': {
                            readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        };
                        readonly 'content': {
                            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                        };
                    }
                ];
                readonly 'address': T.Address__Selection<GAnnotation>;
            };
        }
        type A<GAnnotation> = ['block', T.Block<GAnnotation>] | [
            'if',
            {
                readonly 'condition': T.Boolean__Expression__Or__Selection<GAnnotation>;
                readonly 'else': [false] | [true, T.Block<GAnnotation>];
                readonly 'then': T.Block<GAnnotation>;
            }
        ] | [
            'while',
            {
                readonly 'block': T.Block<GAnnotation>;
                readonly 'condition': T.Boolean__Expression__Or__Selection<GAnnotation>;
            }
        ] | [
            'with',
            {
                readonly 'action': ['assign', T.Assign<GAnnotation>] | [
                    'minus assign',
                    {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraints': {
                            readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        };
                        readonly 'content': {
                            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                        };
                    }
                ] | [
                    'plus assign',
                    {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraints': {
                            readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                        };
                        readonly 'content': {
                            readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                        };
                    }
                ];
                readonly 'address': T.Address__Selection<GAnnotation>;
            }
        ];
    }
    type Statements<GAnnotation> = pt.Array<['block', T.Block<GAnnotation>] | [
        'if',
        {
            readonly 'condition': T.Boolean__Expression__Or__Selection<GAnnotation>;
            readonly 'else': [false] | [true, T.Block<GAnnotation>];
            readonly 'then': T.Block<GAnnotation>;
        }
    ] | [
        'while',
        {
            readonly 'block': T.Block<GAnnotation>;
            readonly 'condition': T.Boolean__Expression__Or__Selection<GAnnotation>;
        }
    ] | [
        'with',
        {
            readonly 'action': ['assign', T.Assign<GAnnotation>] | [
                'minus assign',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                    };
                    readonly 'content': {
                        readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                    };
                }
            ] | [
                'plus assign',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'number address': [false] | [true, g_typesystem.T.Type._lnumber<GAnnotation>];
                    };
                    readonly 'content': {
                        readonly 'right hand side': T.Numerical__Expression__Or__Selection<GAnnotation>;
                    };
                }
            ];
            readonly 'address': T.Address__Selection<GAnnotation>;
        }
    ]>;
    namespace String__Expression {
        type string__literal<GAnnotation> = string;
    }
    type String__Expression<GAnnotation> = ['string literal', string];
    namespace String__Expression__Or__Selection {
        type expression<GAnnotation> = T.String__Expression<GAnnotation>;
        namespace selection {
            namespace cast__to__string {
                namespace _lstring {
                    type annotation<GAnnotation> = GAnnotation;
                    namespace constraints {
                        namespace _lstring {
                            type O<GAnnotation> = g_typesystem.T.Type._lstring<GAnnotation>;
                        }
                        type _lstring<GAnnotation> = [false] | [true, g_typesystem.T.Type._lstring<GAnnotation>];
                    }
                    type constraints<GAnnotation> = {
                        readonly 'string': [false] | [true, g_typesystem.T.Type._lstring<GAnnotation>];
                    };
                    namespace content { }
                    type content<GAnnotation> = null;
                }
                type _lstring<GAnnotation> = {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'string': [false] | [true, g_typesystem.T.Type._lstring<GAnnotation>];
                    };
                    readonly 'content': null;
                };
            }
            type cast__to__string<GAnnotation> = [
                'string',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'string': [false] | [true, g_typesystem.T.Type._lstring<GAnnotation>];
                    };
                    readonly 'content': null;
                }
            ];
            type selection<GAnnotation> = T.Address__Selection<GAnnotation>;
        }
        type selection<GAnnotation> = {
            readonly 'cast to string': [
                'string',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'string': [false] | [true, g_typesystem.T.Type._lstring<GAnnotation>];
                    };
                    readonly 'content': null;
                }
            ];
            readonly 'selection': T.Address__Selection<GAnnotation>;
        };
    }
    type String__Expression__Or__Selection<GAnnotation> = ['expression', T.String__Expression<GAnnotation>] | [
        'selection',
        {
            readonly 'cast to string': [
                'string',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraints': {
                        readonly 'string': [false] | [true, g_typesystem.T.Type._lstring<GAnnotation>];
                    };
                    readonly 'content': null;
                }
            ];
            readonly 'selection': T.Address__Selection<GAnnotation>;
        }
    ];
    namespace Type__Arguments {
        namespace D {
            type annotation<GAnnotation> = GAnnotation;
            namespace constraints {
                namespace x {
                    type O<GAnnotation> = g_typesystem.T.Type__Parameters.D<GAnnotation>;
                }
                type x<GAnnotation> = [false] | [true, g_typesystem.T.Type__Parameters.D<GAnnotation>];
            }
            type constraints<GAnnotation> = {
                readonly 'x': [false] | [true, g_typesystem.T.Type__Parameters.D<GAnnotation>];
            };
            namespace content {
                type _ltype<GAnnotation> = T.Type__Selection<GAnnotation>;
            }
            type content<GAnnotation> = {
                readonly 'type': T.Type__Selection<GAnnotation>;
            };
        }
        type D<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'constraints': {
                readonly 'x': [false] | [true, g_typesystem.T.Type__Parameters.D<GAnnotation>];
            };
            readonly 'content': {
                readonly 'type': T.Type__Selection<GAnnotation>;
            };
        };
    }
    type Type__Arguments<GAnnotation> = pt.Dictionary<{
        readonly 'annotation': GAnnotation;
        readonly 'constraints': {
            readonly 'x': [false] | [true, g_typesystem.T.Type__Parameters.D<GAnnotation>];
        };
        readonly 'content': {
            readonly 'type': T.Type__Selection<GAnnotation>;
        };
    }>;
    namespace Type__Selection {
        namespace content {
            namespace content {
                namespace child__namespace {
                    namespace namespacex {
                        type annotation<GAnnotation> = GAnnotation;
                        namespace constraint {
                            type O<GAnnotation> = g_typesystem.T.Namespace.namespaces.D<GAnnotation>;
                        }
                        type constraint<GAnnotation> = [false] | [true, g_typesystem.T.Namespace.namespaces.D<GAnnotation>];
                        type key<GAnnotation> = string;
                    }
                    type namespacex<GAnnotation> = {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraint': [false] | [true, g_typesystem.T.Namespace.namespaces.D<GAnnotation>];
                        readonly 'key': string;
                    };
                    type selection<GAnnotation> = T.Type__Selection<GAnnotation>;
                }
                type child__namespace<GAnnotation> = {
                    readonly 'namespacex': {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraint': [false] | [true, g_typesystem.T.Namespace.namespaces.D<GAnnotation>];
                        readonly 'key': string;
                    };
                    readonly 'selection': T.Type__Selection<GAnnotation>;
                };
                namespace current__namespace {
                    type annotation<GAnnotation> = GAnnotation;
                    namespace constraint {
                        type O<GAnnotation> = g_typesystem.T.Namespace.types.D<GAnnotation>;
                    }
                    type constraint<GAnnotation> = [false] | [true, g_typesystem.T.Namespace.types.D<GAnnotation>];
                    type key<GAnnotation> = string;
                }
                type current__namespace<GAnnotation> = {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraint': [false] | [true, g_typesystem.T.Namespace.types.D<GAnnotation>];
                    readonly 'key': string;
                };
            }
            type content<GAnnotation> = [
                'child namespace',
                {
                    readonly 'namespacex': {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraint': [false] | [true, g_typesystem.T.Namespace.namespaces.D<GAnnotation>];
                        readonly 'key': string;
                    };
                    readonly 'selection': T.Type__Selection<GAnnotation>;
                }
            ] | [
                'current namespace',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraint': [false] | [true, g_typesystem.T.Namespace.types.D<GAnnotation>];
                    readonly 'key': string;
                }
            ];
            namespace result {
                type O<GAnnotation> = g_typesystem.T.Type<GAnnotation>;
            }
            type result<GAnnotation> = [false] | [true, g_typesystem.T.Type<GAnnotation>];
        }
        type content<GAnnotation> = {
            readonly 'content': [
                'child namespace',
                {
                    readonly 'namespacex': {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraint': [false] | [true, g_typesystem.T.Namespace.namespaces.D<GAnnotation>];
                        readonly 'key': string;
                    };
                    readonly 'selection': T.Type__Selection<GAnnotation>;
                }
            ] | [
                'current namespace',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraint': [false] | [true, g_typesystem.T.Namespace.types.D<GAnnotation>];
                    readonly 'key': string;
                }
            ];
            readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
        };
        namespace result {
            type O<GAnnotation> = g_typesystem.T.Type<GAnnotation>;
        }
        type result<GAnnotation> = [false] | [true, g_typesystem.T.Type<GAnnotation>];
    }
    type Type__Selection<GAnnotation> = {
        readonly 'content': {
            readonly 'content': [
                'child namespace',
                {
                    readonly 'namespacex': {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraint': [false] | [true, g_typesystem.T.Namespace.namespaces.D<GAnnotation>];
                        readonly 'key': string;
                    };
                    readonly 'selection': T.Type__Selection<GAnnotation>;
                }
            ] | [
                'current namespace',
                {
                    readonly 'annotation': GAnnotation;
                    readonly 'constraint': [false] | [true, g_typesystem.T.Namespace.types.D<GAnnotation>];
                    readonly 'key': string;
                }
            ];
            readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
        };
        readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
    };
    namespace Variables {
        namespace D {
            namespace _ltype {
                namespace content {
                    namespace local {
                        type initializer<GAnnotation> = T.Expression<GAnnotation>;
                        type _ltype<GAnnotation> = T.Type__Selection<GAnnotation>;
                    }
                    type local<GAnnotation> = {
                        readonly 'initializer': T.Expression<GAnnotation>;
                        readonly 'type': T.Type__Selection<GAnnotation>;
                    };
                    namespace variable__stack2 {
                        namespace variable {
                            type annotation<GAnnotation> = GAnnotation;
                            namespace constraint {
                                type O<GAnnotation> = T.Variables.D<GAnnotation>;
                            }
                            type constraint<GAnnotation> = [false] | [true, T.Variables.D<GAnnotation>];
                            type key<GAnnotation> = string;
                        }
                        type variable<GAnnotation> = {
                            readonly 'annotation': GAnnotation;
                            readonly 'constraint': [false] | [true, T.Variables.D<GAnnotation>];
                            readonly 'key': string;
                        };
                    }
                    type variable__stack2<GAnnotation> = {
                        readonly 'variable': {
                            readonly 'annotation': GAnnotation;
                            readonly 'constraint': [false] | [true, T.Variables.D<GAnnotation>];
                            readonly 'key': string;
                        };
                    };
                }
                type content<GAnnotation> = [
                    'local',
                    {
                        readonly 'initializer': T.Expression<GAnnotation>;
                        readonly 'type': T.Type__Selection<GAnnotation>;
                    }
                ] | [
                    'variable stack2',
                    {
                        readonly 'variable': {
                            readonly 'annotation': GAnnotation;
                            readonly 'constraint': [false] | [true, T.Variables.D<GAnnotation>];
                            readonly 'key': string;
                        };
                    }
                ];
                namespace result {
                    type O<GAnnotation> = g_typesystem.T.Type<GAnnotation>;
                }
                type result<GAnnotation> = [false] | [true, g_typesystem.T.Type<GAnnotation>];
            }
            type _ltype<GAnnotation> = {
                readonly 'content': [
                    'local',
                    {
                        readonly 'initializer': T.Expression<GAnnotation>;
                        readonly 'type': T.Type__Selection<GAnnotation>;
                    }
                ] | [
                    'variable stack2',
                    {
                        readonly 'variable': {
                            readonly 'annotation': GAnnotation;
                            readonly 'constraint': [false] | [true, T.Variables.D<GAnnotation>];
                            readonly 'key': string;
                        };
                    }
                ];
                readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
            };
        }
        type D<GAnnotation> = {
            readonly 'type': {
                readonly 'content': [
                    'local',
                    {
                        readonly 'initializer': T.Expression<GAnnotation>;
                        readonly 'type': T.Type__Selection<GAnnotation>;
                    }
                ] | [
                    'variable stack2',
                    {
                        readonly 'variable': {
                            readonly 'annotation': GAnnotation;
                            readonly 'constraint': [false] | [true, T.Variables.D<GAnnotation>];
                            readonly 'key': string;
                        };
                    }
                ];
                readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
            };
        };
    }
    type Variables<GAnnotation> = pt.Dictionary<{
        readonly 'type': {
            readonly 'content': [
                'local',
                {
                    readonly 'initializer': T.Expression<GAnnotation>;
                    readonly 'type': T.Type__Selection<GAnnotation>;
                }
            ] | [
                'variable stack2',
                {
                    readonly 'variable': {
                        readonly 'annotation': GAnnotation;
                        readonly 'constraint': [false] | [true, T.Variables.D<GAnnotation>];
                        readonly 'key': string;
                    };
                }
            ];
            readonly 'result': [false] | [true, g_typesystem.T.Type<GAnnotation>];
        };
    }>;
}
