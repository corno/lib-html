import * as pt from 'pareto-core-types';
export declare namespace N {
    namespace Aggregated_$_$Type_$_$Parameters {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Function_$_$Declaration {
        namespace N {
            namespace G {
                namespace N {
                    namespace context {
                        namespace N { }
                        namespace T { }
                    }
                    namespace parameters {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace type_$_$parameters {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Local_$_$Namespace {
        namespace N {
            namespace G {
                namespace N {
                    namespace namespaces {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace parameters {
                        namespace N { }
                        namespace T { }
                    }
                    namespace types {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Namespace_$_$2 {
        namespace N {
            namespace TU {
                namespace N {
                    namespace local {
                        namespace N { }
                        namespace T { }
                    }
                    namespace parent_$_$sibling {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace namespace {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Namespace_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace arguments {
                        namespace N { }
                        namespace T { }
                    }
                    namespace namespace {
                        namespace N { }
                        namespace T { }
                    }
                    namespace tail {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Root {
        namespace N { }
        namespace T { }
    }
    namespace Type {
        namespace N {
            namespace TU {
                namespace N {
                    namespace address_$_$function {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace declaration {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace return_$_$type {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace array {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$lboolean {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace computed {
                        namespace N { }
                        namespace T { }
                    }
                    namespace dictionary {
                        namespace N { }
                        namespace T { }
                    }
                    namespace group {
                        namespace N {
                            namespace D {
                                namespace N {
                                    namespace G {
                                        namespace N {
                                            namespace mutable {
                                                namespace N {
                                                    namespace O {
                                                        namespace N {
                                                            namespace G {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                            namespace _$ltype {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lnull {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lnumber {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace optional {
                        namespace N { }
                        namespace T { }
                    }
                    namespace procedure {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace declaration {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lstring {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace tagged_$_$union {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace type_$_$parameter {
                        namespace N { }
                        namespace T { }
                    }
                    namespace type_$_$reference {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace cyclic_$_$sibling {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace external {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace namespaces {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace sibling {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace value_$_$function {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace declaration {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace return_$_$type {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Arguments {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N {
                            namespace _$ltype {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Parameters {
        namespace N {
            namespace G {
                namespace N {
                    namespace aggregated {
                        namespace N { }
                        namespace T { }
                    }
                    namespace local {
                        namespace N {
                            namespace D {
                                namespace N {
                                    namespace G {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
}
export declare namespace T {
    namespace Aggregated__Type__Parameters {
        namespace D { }
        type D = null;
    }
    type Aggregated__Type__Parameters = pt.Dictionary<null>;
    namespace Function__Declaration {
        type context = T.Type;
        namespace parameters {
            type D = T.Type;
        }
        type parameters = pt.Dictionary<T.Type>;
        type type__parameters = T.Type__Parameters;
    }
    type Function__Declaration = {
        readonly 'context': T.Type;
        readonly 'parameters': pt.Dictionary<T.Type>;
        readonly 'type parameters': T.Type__Parameters;
    };
    namespace Local__Namespace {
        namespace namespaces {
            type D = T.Namespace__2;
        }
        type namespaces = pt.Dictionary<T.Namespace__2>;
        type parameters = T.Type__Parameters;
        namespace types {
            type D = T.Type;
        }
        type types = pt.Dictionary<T.Type>;
    }
    type Local__Namespace = {
        readonly 'namespaces': pt.Dictionary<T.Namespace__2>;
        readonly 'parameters': T.Type__Parameters;
        readonly 'types': pt.Dictionary<T.Type>;
    };
    namespace Namespace__2 {
        type local = T.Local__Namespace;
        namespace parent__sibling {
            namespace namespace {
                type key = string;
                namespace referent {
                    type O = T.Namespace__2;
                }
                type referent = [false] | [true, T.Namespace__2];
            }
            type namespace = {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Namespace__2];
            };
        }
        type parent__sibling = {
            readonly 'namespace': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Namespace__2];
            };
        };
    }
    type Namespace__2 = ['local', T.Local__Namespace] | [
        'parent sibling',
        {
            readonly 'namespace': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Namespace__2];
            };
        }
    ];
    namespace Namespace__Selection {
        type arguments = T.Type__Arguments;
        namespace namespace {
            type key = string;
            namespace referent {
                type O = T.Local__Namespace.namespaces.D;
            }
            type referent = [false] | [true, T.Local__Namespace.namespaces.D];
        }
        type namespace = {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Local__Namespace.namespaces.D];
        };
        namespace tail {
            type O = T.Namespace__Selection;
        }
        type tail = [false] | [true, T.Namespace__Selection];
    }
    type Namespace__Selection = {
        readonly 'arguments': T.Type__Arguments;
        readonly 'namespace': {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Local__Namespace.namespaces.D];
        };
        readonly 'tail': [false] | [true, T.Namespace__Selection];
    };
    type Root = T.Local__Namespace;
    namespace Type {
        namespace address__function {
            type declaration = T.Function__Declaration;
            type return__type = T.Type;
        }
        type address__function = {
            readonly 'declaration': T.Function__Declaration;
            readonly 'return type': T.Type;
        };
        type array = T.Type;
        namespace _lboolean { }
        type _lboolean = null;
        type computed = T.Type;
        type dictionary = T.Type;
        namespace group {
            namespace D {
                namespace mutable {
                    namespace O { }
                    type O = null;
                }
                type mutable = [false] | [true, null];
                type _ltype = T.Type;
            }
            type D = {
                readonly 'mutable': [false] | [true, null];
                readonly 'type': T.Type;
            };
        }
        type group = pt.Dictionary<{
            readonly 'mutable': [false] | [true, null];
            readonly 'type': T.Type;
        }>;
        namespace _lnull { }
        type _lnull = null;
        namespace _lnumber { }
        type _lnumber = null;
        type optional = T.Type;
        namespace procedure {
            type declaration = T.Function__Declaration;
        }
        type procedure = {
            readonly 'declaration': T.Function__Declaration;
        };
        namespace _lstring { }
        type _lstring = null;
        namespace tagged__union {
            type D = T.Type;
        }
        type tagged__union = pt.Dictionary<T.Type>;
        namespace type__parameter {
            type key = string;
            namespace referent {
                type O = T.Aggregated__Type__Parameters.D;
            }
            type referent = [false] | [true, T.Aggregated__Type__Parameters.D];
        }
        type type__parameter = {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Aggregated__Type__Parameters.D];
        };
        namespace type__reference {
            namespace cyclic__sibling {
                type key = string;
                namespace referent {
                    namespace O {
                        type C = T.Type;
                    }
                    type O = () => T.Type;
                }
                type referent = [false] | [true, () => T.Type];
            }
            type cyclic__sibling = {
                readonly 'key': string;
                readonly 'referent': [false] | [true, () => T.Type];
            };
            namespace external {
                type namespaces = T.Namespace__Selection;
                namespace _ltype {
                    type key = string;
                    namespace referent {
                        type O = T.Local__Namespace.types.D;
                    }
                    type referent = [false] | [true, T.Local__Namespace.types.D];
                }
                type _ltype = {
                    readonly 'key': string;
                    readonly 'referent': [false] | [true, T.Local__Namespace.types.D];
                };
            }
            type external = {
                readonly 'namespaces': T.Namespace__Selection;
                readonly 'type': {
                    readonly 'key': string;
                    readonly 'referent': [false] | [true, T.Local__Namespace.types.D];
                };
            };
            namespace sibling {
                type key = string;
                namespace referent {
                    type O = T.Type;
                }
                type referent = [false] | [true, T.Type];
            }
            type sibling = {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Type];
            };
        }
        type type__reference = [
            'cyclic sibling',
            {
                readonly 'key': string;
                readonly 'referent': [false] | [true, () => T.Type];
            }
        ] | [
            'external',
            {
                readonly 'namespaces': T.Namespace__Selection;
                readonly 'type': {
                    readonly 'key': string;
                    readonly 'referent': [false] | [true, T.Local__Namespace.types.D];
                };
            }
        ] | [
            'sibling',
            {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Type];
            }
        ];
        namespace value__function {
            type declaration = T.Function__Declaration;
            type return__type = T.Type;
        }
        type value__function = {
            readonly 'declaration': T.Function__Declaration;
            readonly 'return type': T.Type;
        };
    }
    type Type = [
        'address function',
        {
            readonly 'declaration': T.Function__Declaration;
            readonly 'return type': T.Type;
        }
    ] | ['array', T.Type] | ['boolean', null] | ['computed', T.Type] | ['dictionary', T.Type] | [
        'group',
        pt.Dictionary<{
            readonly 'mutable': [false] | [true, null];
            readonly 'type': T.Type;
        }>
    ] | ['null', null] | ['number', null] | ['optional', T.Type] | [
        'procedure',
        {
            readonly 'declaration': T.Function__Declaration;
        }
    ] | ['string', null] | ['tagged union', pt.Dictionary<T.Type>] | [
        'type parameter',
        {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Aggregated__Type__Parameters.D];
        }
    ] | [
        'type reference',
        [
            'cyclic sibling',
            {
                readonly 'key': string;
                readonly 'referent': [false] | [true, () => T.Type];
            }
        ] | [
            'external',
            {
                readonly 'namespaces': T.Namespace__Selection;
                readonly 'type': {
                    readonly 'key': string;
                    readonly 'referent': [false] | [true, T.Local__Namespace.types.D];
                };
            }
        ] | [
            'sibling',
            {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Type];
            }
        ]
    ] | [
        'value function',
        {
            readonly 'declaration': T.Function__Declaration;
            readonly 'return type': T.Type;
        }
    ];
    namespace Type__Arguments {
        namespace D {
            namespace constraints {
                namespace O {
                    type parameter = T.Type__Parameters.local.D;
                }
                type O = {
                    readonly 'parameter': T.Type__Parameters.local.D;
                };
            }
            type constraints = [false] | [
                true,
                {
                    readonly 'parameter': T.Type__Parameters.local.D;
                }
            ];
            namespace content {
                type _ltype = T.Type;
            }
            type content = {
                readonly 'type': T.Type;
            };
        }
        type D = {
            readonly 'constraints': [false] | [
                true,
                {
                    readonly 'parameter': T.Type__Parameters.local.D;
                }
            ];
            readonly 'content': {
                readonly 'type': T.Type;
            };
        };
    }
    type Type__Arguments = pt.Dictionary<{
        readonly 'constraints': [false] | [
            true,
            {
                readonly 'parameter': T.Type__Parameters.local.D;
            }
        ];
        readonly 'content': {
            readonly 'type': T.Type;
        };
    }>;
    namespace Type__Parameters {
        type aggregated = T.Aggregated__Type__Parameters;
        namespace local {
            namespace D { }
            type D = null;
        }
        type local = pt.Dictionary<null>;
    }
    type Type__Parameters = {
        readonly 'aggregated': T.Aggregated__Type__Parameters;
        readonly 'local': pt.Dictionary<null>;
    };
}
