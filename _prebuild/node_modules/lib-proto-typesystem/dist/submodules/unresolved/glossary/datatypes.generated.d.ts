import * as pt from 'pareto-core-types';
export declare namespace N {
    namespace Aggregated_$_$Type_$_$Parameters {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Function_$_$Declaration {
        namespace N {
            namespace G {
                namespace N {
                    namespace context {
                        namespace N { }
                        namespace T { }
                    }
                    namespace parameters {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace type_$_$parameters {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Local_$_$Namespace {
        namespace N {
            namespace G {
                namespace N {
                    namespace namespaces {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace parameters {
                        namespace N { }
                        namespace T { }
                    }
                    namespace types {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Namespace_$_$2 {
        namespace N {
            namespace TU {
                namespace N {
                    namespace local {
                        namespace N { }
                        namespace T { }
                    }
                    namespace parent_$_$sibling {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace namespace {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Namespace_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace arguments {
                        namespace N { }
                        namespace T { }
                    }
                    namespace namespace {
                        namespace N { }
                        namespace T { }
                    }
                    namespace tail {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Root {
        namespace N { }
        namespace T { }
    }
    namespace Type {
        namespace N {
            namespace TU {
                namespace N {
                    namespace address_$_$function {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace declaration {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace return_$_$type {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace array {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$lboolean {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace computed {
                        namespace N { }
                        namespace T { }
                    }
                    namespace dictionary {
                        namespace N { }
                        namespace T { }
                    }
                    namespace group {
                        namespace N {
                            namespace D {
                                namespace N {
                                    namespace G {
                                        namespace N {
                                            namespace mutable {
                                                namespace N {
                                                    namespace O {
                                                        namespace N {
                                                            namespace G {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                            namespace _$ltype {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lnull {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lnumber {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace optional {
                        namespace N { }
                        namespace T { }
                    }
                    namespace procedure {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace declaration {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$lstring {
                        namespace N {
                            namespace G {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace tagged_$_$union {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace type_$_$parameter {
                        namespace N { }
                        namespace T { }
                    }
                    namespace type_$_$reference {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace cyclic_$_$sibling {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace external {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace namespaces {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace sibling {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace value_$_$function {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace declaration {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace return_$_$type {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Arguments {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N {
                            namespace _$ltype {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Parameters {
        namespace N {
            namespace G {
                namespace N {
                    namespace aggregated {
                        namespace N { }
                        namespace T { }
                    }
                    namespace local {
                        namespace N {
                            namespace D {
                                namespace N {
                                    namespace G {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
}
export declare namespace T {
    namespace Aggregated__Type__Parameters {
        type annotation<GAnnotation> = GAnnotation;
        namespace dictionary {
            namespace D { }
            type D<GAnnotation> = null;
        }
        type dictionary<GAnnotation> = pt.Dictionary<null>;
    }
    type Aggregated__Type__Parameters<GAnnotation> = {
        readonly 'annotation': GAnnotation;
        readonly 'dictionary': pt.Dictionary<null>;
    };
    namespace Function__Declaration {
        type context<GAnnotation> = T.Type<GAnnotation>;
        namespace parameters {
            type annotation<GAnnotation> = GAnnotation;
            namespace dictionary {
                type D<GAnnotation> = T.Type<GAnnotation>;
            }
            type dictionary<GAnnotation> = pt.Dictionary<T.Type<GAnnotation>>;
        }
        type parameters<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<T.Type<GAnnotation>>;
        };
        type type__parameters<GAnnotation> = T.Type__Parameters<GAnnotation>;
    }
    type Function__Declaration<GAnnotation> = {
        readonly 'context': T.Type<GAnnotation>;
        readonly 'parameters': {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<T.Type<GAnnotation>>;
        };
        readonly 'type parameters': T.Type__Parameters<GAnnotation>;
    };
    namespace Local__Namespace {
        namespace namespaces {
            type annotation<GAnnotation> = GAnnotation;
            namespace dictionary {
                type D<GAnnotation> = T.Namespace__2<GAnnotation>;
            }
            type dictionary<GAnnotation> = pt.Dictionary<T.Namespace__2<GAnnotation>>;
        }
        type namespaces<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<T.Namespace__2<GAnnotation>>;
        };
        type parameters<GAnnotation> = T.Type__Parameters<GAnnotation>;
        namespace types {
            type annotation<GAnnotation> = GAnnotation;
            namespace dictionary {
                type D<GAnnotation> = T.Type<GAnnotation>;
            }
            type dictionary<GAnnotation> = pt.Dictionary<T.Type<GAnnotation>>;
        }
        type types<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<T.Type<GAnnotation>>;
        };
    }
    type Local__Namespace<GAnnotation> = {
        readonly 'namespaces': {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<T.Namespace__2<GAnnotation>>;
        };
        readonly 'parameters': T.Type__Parameters<GAnnotation>;
        readonly 'types': {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<T.Type<GAnnotation>>;
        };
    };
    namespace Namespace__2 {
        type local<GAnnotation> = T.Local__Namespace<GAnnotation>;
        namespace parent__sibling {
            namespace namespace {
                type annotation<GAnnotation> = GAnnotation;
                type key<GAnnotation> = string;
            }
            type namespace<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        }
        type parent__sibling<GAnnotation> = {
            readonly 'namespace': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        };
    }
    type Namespace__2<GAnnotation> = ['local', T.Local__Namespace<GAnnotation>] | [
        'parent sibling',
        {
            readonly 'namespace': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        }
    ];
    namespace Namespace__Selection {
        type arguments<GAnnotation> = T.Type__Arguments<GAnnotation>;
        namespace namespace {
            type annotation<GAnnotation> = GAnnotation;
            type key<GAnnotation> = string;
        }
        type namespace<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        namespace tail {
            type O<GAnnotation> = T.Namespace__Selection<GAnnotation>;
        }
        type tail<GAnnotation> = [false] | [true, T.Namespace__Selection<GAnnotation>];
    }
    type Namespace__Selection<GAnnotation> = {
        readonly 'arguments': T.Type__Arguments<GAnnotation>;
        readonly 'namespace': {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        readonly 'tail': [false] | [true, T.Namespace__Selection<GAnnotation>];
    };
    type Root<GAnnotation> = T.Local__Namespace<GAnnotation>;
    namespace Type {
        namespace address__function {
            type declaration<GAnnotation> = T.Function__Declaration<GAnnotation>;
            type return__type<GAnnotation> = T.Type<GAnnotation>;
        }
        type address__function<GAnnotation> = {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
            readonly 'return type': T.Type<GAnnotation>;
        };
        type array<GAnnotation> = T.Type<GAnnotation>;
        namespace _lboolean { }
        type _lboolean<GAnnotation> = null;
        type computed<GAnnotation> = T.Type<GAnnotation>;
        type dictionary<GAnnotation> = T.Type<GAnnotation>;
        namespace group {
            type annotation<GAnnotation> = GAnnotation;
            namespace dictionary {
                namespace D {
                    namespace mutable {
                        namespace O { }
                        type O<GAnnotation> = null;
                    }
                    type mutable<GAnnotation> = [false] | [true, null];
                    type _ltype<GAnnotation> = T.Type<GAnnotation>;
                }
                type D<GAnnotation> = {
                    readonly 'mutable': [false] | [true, null];
                    readonly 'type': T.Type<GAnnotation>;
                };
            }
            type dictionary<GAnnotation> = pt.Dictionary<{
                readonly 'mutable': [false] | [true, null];
                readonly 'type': T.Type<GAnnotation>;
            }>;
        }
        type group<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<{
                readonly 'mutable': [false] | [true, null];
                readonly 'type': T.Type<GAnnotation>;
            }>;
        };
        namespace _lnull { }
        type _lnull<GAnnotation> = null;
        namespace _lnumber { }
        type _lnumber<GAnnotation> = null;
        type optional<GAnnotation> = T.Type<GAnnotation>;
        namespace procedure {
            type declaration<GAnnotation> = T.Function__Declaration<GAnnotation>;
        }
        type procedure<GAnnotation> = {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
        };
        namespace _lstring { }
        type _lstring<GAnnotation> = null;
        namespace tagged__union {
            type annotation<GAnnotation> = GAnnotation;
            namespace dictionary {
                type D<GAnnotation> = T.Type<GAnnotation>;
            }
            type dictionary<GAnnotation> = pt.Dictionary<T.Type<GAnnotation>>;
        }
        type tagged__union<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<T.Type<GAnnotation>>;
        };
        namespace type__parameter {
            type annotation<GAnnotation> = GAnnotation;
            type key<GAnnotation> = string;
        }
        type type__parameter<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        namespace type__reference {
            namespace cyclic__sibling {
                type annotation<GAnnotation> = GAnnotation;
                type key<GAnnotation> = string;
            }
            type cyclic__sibling<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
            namespace external {
                type namespaces<GAnnotation> = T.Namespace__Selection<GAnnotation>;
                namespace _ltype {
                    type annotation<GAnnotation> = GAnnotation;
                    type key<GAnnotation> = string;
                }
                type _ltype<GAnnotation> = {
                    readonly 'annotation': GAnnotation;
                    readonly 'key': string;
                };
            }
            type external<GAnnotation> = {
                readonly 'namespaces': T.Namespace__Selection<GAnnotation>;
                readonly 'type': {
                    readonly 'annotation': GAnnotation;
                    readonly 'key': string;
                };
            };
            namespace sibling {
                type annotation<GAnnotation> = GAnnotation;
                type key<GAnnotation> = string;
            }
            type sibling<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        }
        type type__reference<GAnnotation> = [
            'cyclic sibling',
            {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            }
        ] | [
            'external',
            {
                readonly 'namespaces': T.Namespace__Selection<GAnnotation>;
                readonly 'type': {
                    readonly 'annotation': GAnnotation;
                    readonly 'key': string;
                };
            }
        ] | [
            'sibling',
            {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            }
        ];
        namespace value__function {
            type declaration<GAnnotation> = T.Function__Declaration<GAnnotation>;
            type return__type<GAnnotation> = T.Type<GAnnotation>;
        }
        type value__function<GAnnotation> = {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
            readonly 'return type': T.Type<GAnnotation>;
        };
    }
    type Type<GAnnotation> = [
        'address function',
        {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
            readonly 'return type': T.Type<GAnnotation>;
        }
    ] | ['array', T.Type<GAnnotation>] | ['boolean', null] | ['computed', T.Type<GAnnotation>] | ['dictionary', T.Type<GAnnotation>] | [
        'group',
        {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<{
                readonly 'mutable': [false] | [true, null];
                readonly 'type': T.Type<GAnnotation>;
            }>;
        }
    ] | ['null', null] | ['number', null] | ['optional', T.Type<GAnnotation>] | [
        'procedure',
        {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
        }
    ] | ['string', null] | [
        'tagged union',
        {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<T.Type<GAnnotation>>;
        }
    ] | [
        'type parameter',
        {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        }
    ] | [
        'type reference',
        [
            'cyclic sibling',
            {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            }
        ] | [
            'external',
            {
                readonly 'namespaces': T.Namespace__Selection<GAnnotation>;
                readonly 'type': {
                    readonly 'annotation': GAnnotation;
                    readonly 'key': string;
                };
            }
        ] | [
            'sibling',
            {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            }
        ]
    ] | [
        'value function',
        {
            readonly 'declaration': T.Function__Declaration<GAnnotation>;
            readonly 'return type': T.Type<GAnnotation>;
        }
    ];
    namespace Type__Arguments {
        type annotation<GAnnotation> = GAnnotation;
        namespace dictionary {
            namespace D {
                type annotation<GAnnotation> = GAnnotation;
                namespace content {
                    type _ltype<GAnnotation> = T.Type<GAnnotation>;
                }
                type content<GAnnotation> = {
                    readonly 'type': T.Type<GAnnotation>;
                };
            }
            type D<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'content': {
                    readonly 'type': T.Type<GAnnotation>;
                };
            };
        }
        type dictionary<GAnnotation> = pt.Dictionary<{
            readonly 'annotation': GAnnotation;
            readonly 'content': {
                readonly 'type': T.Type<GAnnotation>;
            };
        }>;
    }
    type Type__Arguments<GAnnotation> = {
        readonly 'annotation': GAnnotation;
        readonly 'dictionary': pt.Dictionary<{
            readonly 'annotation': GAnnotation;
            readonly 'content': {
                readonly 'type': T.Type<GAnnotation>;
            };
        }>;
    };
    namespace Type__Parameters {
        type aggregated<GAnnotation> = T.Aggregated__Type__Parameters<GAnnotation>;
        namespace local {
            type annotation<GAnnotation> = GAnnotation;
            namespace dictionary {
                namespace D { }
                type D<GAnnotation> = null;
            }
            type dictionary<GAnnotation> = pt.Dictionary<null>;
        }
        type local<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<null>;
        };
    }
    type Type__Parameters<GAnnotation> = {
        readonly 'aggregated': T.Aggregated__Type__Parameters<GAnnotation>;
        readonly 'local': {
            readonly 'annotation': GAnnotation;
            readonly 'dictionary': pt.Dictionary<null>;
        };
    };
}
