"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$$ = void 0;
const pl = __importStar(require("pareto-core-lib"));
const pm = __importStar(require("pareto-core-map"));
const $$ = ($d) => {
    return ($, $i) => {
        function escape($) {
            return $d.escape({
                'escape': "$",
                'patterns to escape': pm.wrapRawArray(["_"]),
                'string': $
            });
        }
        const Function__Declaration = ($, $p, $i) => {
            $d.enrichedDictionaryForEach($['type parameters'].local, {
                'onEmpty': () => {
                },
                'onNotEmpty': ($c) => {
                    $i.snippet(`<`);
                    $c(($) => {
                        $i.snippet(`_T${$d.createIdentifier($.key)}${$.isLast ? `` : `, `}`);
                    });
                    $i.snippet(`>`);
                }
            });
            $i.snippet(`(`);
            $i.indent(($i) => {
                $i.nestedLine(($i) => {
                    $i.snippet(`$: `);
                    Type($.context, $p, $i);
                    $i.snippet(`,`);
                });
                $d.enrichedDictionaryForEach($.parameters, {
                    'onEmpty': () => { },
                    'onNotEmpty': ($c) => {
                        $i.nestedLine(($i) => {
                            $i.snippet(`$p: {`);
                            $i.indent(($i) => {
                                $c(($) => {
                                    $i.nestedLine(($i) => {
                                        $i.snippet(`readonly ${$d.createApostrophedString($.key)}: `);
                                        Type($.value, $p, $i);
                                    });
                                });
                            });
                            $i.snippet(`}`);
                        });
                    },
                });
            });
            $i.snippet(`) => `);
        };
        const Local__Namespace = ($, depth, $i) => {
            const $tp = $.parameters;
            const $ns = $.namespaces;
            /*
            namespaces in typescript work differently than namespaces in proto

            in typescript, a nested namespace shadows a higher namespace with the same name.
            in proto, this is not the case.
            to create a proper mapping from proto to typescript, we must work around this.
            If a parent namespace is referenced but would be shadowed, we create an intermediate name for that namespace
            which can be referenced by a nested namespace.

            generated typescript:

            namespace MyNamespace {
                type MyType = number
            }

            import _p0_MyNamespace = MyNamespace //additionally generated to allow access

            namespace Hierarchy {
                namespace MyNamespace { //shadows the higher one

                }

                namespace Nested {
                    type MyOtherType = _p0_MyNamespace.MyType //referring to the alternative name
                }
            }

            */
            const namespacesWithSpecialChildren = $.namespaces.map(($) => {
                switch ($[0]) {
                    case 'local': return pl.ss($, ($) => $d.filter($.namespaces.__mapWithKey(($, key) => {
                        switch ($[0]) {
                            case 'local': return pl.ss($, ($) => [false]);
                            case 'parent sibling': return pl.ss($, ($) => {
                                return key !== $.namespace.key
                                    ? [true, $.namespace.key] //A special parent namespace reference
                                    : [false];
                            });
                            default: return pl.au($[0]);
                        }
                    })));
                    case 'parent sibling': return pl.ss($, ($) => pm.wrapRawDictionary({}));
                    default: return pl.au($[0]);
                }
            });
            $d.dictionaryForEach($d.filter(namespacesWithSpecialChildren.map(($) => {
                return $d.isEmpty($)
                    ? [false]
                    : [true, $];
            })), ($) => {
                $d.dictionaryForEach($.value, ($) => {
                    $i.line(`import _p${depth}_${$d.createIdentifier(escape($.value))} = ${$d.createIdentifier(escape($.value))}`);
                });
            });
            // $d.filter($.namespaces.map<>(($) => {
            //     switch ($[0]) {
            //         case 'local': return pl.ss($, ($) =>
            //             $d.isEmpty($d.filter($.namespaces.map(($) => [false])))
            //             ? [false]
            //             : [true, null]
            //         )
            //         case 'parent sibling': return pl.ss($, ($) => [false])
            //         default: return pl.au($[0])
            //     }
            // }))
            $.namespaces.__forEach(() => false, ($, key) => {
                switch ($[0]) {
                    case 'local':
                        pl.ss($, ($) => {
                            $i.line(``);
                            $i.nestedLine(($i) => {
                                $i.snippet(`export namespace ${$d.createIdentifier(escape(key))} {`);
                                $i.indent(($i) => {
                                    Local__Namespace($, depth + 1, $i);
                                });
                                $i.snippet(`}`);
                            });
                        });
                        break;
                    case 'parent sibling':
                        pl.ss($, ($) => {
                            //if the name is the same, nothing needs to be done
                            if (key !== $.namespace.key) {
                                $i.line(``);
                                $i.line(`import ${$d.createIdentifier(escape(key))} = _p${depth - 1}_${$d.createIdentifier(escape($.namespace.key))}`);
                                if ($ns.__getEntry($.namespace.key, () => true, () => false)) { //contains
                                }
                            }
                            $.namespace.key;
                        });
                        break;
                    default: pl.au($[0]);
                }
            });
            $.types.__forEach(() => false, ($, key) => {
                $i.line(``);
                $i.nestedLine(($i) => {
                    $i.snippet(`export type ${$d.createIdentifier(key)}`);
                    Type__Parameters($tp, $i);
                    $i.snippet(` = `);
                    Type($, { 'type parameters': $tp }, $i);
                });
            });
        };
        // const Namespace__2 = (
        //     $: g_in.T.Namespace__2,
        //     $i: g_fp.SYNC.I.Block
        // ) => {
        // }
        const Namespace__Selection = ($, $i) => {
            $i.snippet(`${$d.createIdentifier(escape($.namespace.key))}.`);
            pl.optional($.tail, ($) => {
                Namespace__Selection($, $i);
            }, () => {
            });
        };
        const Root = ($, $i) => {
            $i.line(``);
            $i.line(`import * as _pt from 'pareto-core-types'`);
            $i.line(``);
            $i.nestedLine(($i) => {
                $i.snippet(`namespace _ {`);
                $i.indent(($i) => {
                    $i.line(``);
                    $i.nestedLine(($i) => {
                        $i.snippet(`export type Address<T> = { get: () => T, set: ($: T) => void } `);
                    });
                });
                $i.snippet(`}`);
            });
            Local__Namespace($, 0, $i);
        };
        const Type = ($, $p, $i) => {
            switch ($[0]) {
                case 'address function':
                    pl.ss($, ($) => {
                        Function__Declaration($.declaration, $p, $i);
                        $i.snippet(`_.Address<`);
                        Type($['return type'], $p, $i);
                        $i.snippet(`>`);
                    });
                    break;
                case 'array':
                    pl.ss($, ($) => {
                        $i.snippet(`_pt.Array<`);
                        Type($, $p, $i);
                        $i.snippet(`>`);
                    });
                    break;
                case 'boolean':
                    pl.ss($, ($) => {
                        $i.snippet(`boolean`);
                    });
                    break;
                case 'computed':
                    pl.ss($, ($) => {
                        $i.snippet(`_pt.ComputedValue<`);
                        Type($, $p, $i);
                        $i.snippet(`>`);
                    });
                    break;
                case 'dictionary':
                    pl.ss($, ($) => {
                        $i.snippet(`_pt.Dictionary<`);
                        Type($, $p, $i);
                        $i.snippet(`>`);
                    });
                    break;
                case 'group':
                    pl.ss($, ($) => {
                        $d.enrichedDictionaryForEach($, {
                            'onEmpty': () => {
                                $i.snippet(`null`);
                            },
                            'onNotEmpty': ($c) => {
                                $i.snippet(`{`);
                                $i.indent(($i) => {
                                    $c(($) => {
                                        $i.nestedLine(($i) => {
                                            pl.optional($.value.mutable, () => { }, () => {
                                                $i.snippet(`readonly `);
                                            });
                                            $i.snippet(`${$d.createApostrophedString($.key)}: `);
                                            Type($.value.type, $p, $i);
                                        });
                                    });
                                });
                                $i.snippet(`}`);
                            }
                        });
                    });
                    break;
                case 'null':
                    pl.ss($, ($) => {
                        $i.snippet(`null`);
                    });
                    break;
                case 'number':
                    pl.ss($, ($) => {
                        $i.snippet(`number`);
                    });
                    break;
                case 'optional':
                    pl.ss($, ($) => {
                        $i.snippet(`_pt.OptionalValue<`);
                        Type($, $p, $i);
                        $i.snippet(`>`);
                    });
                    break;
                case 'procedure':
                    pl.ss($, ($) => {
                        Function__Declaration($.declaration, $p, $i);
                        $i.snippet(`void`);
                    });
                    break;
                case 'string':
                    pl.ss($, ($) => {
                        $i.snippet(`string`);
                    });
                    break;
                case 'tagged union':
                    pl.ss($, ($) => {
                        $d.enrichedDictionaryForEach($, {
                            'onEmpty': () => {
                                $i.snippet(`null`);
                            },
                            'onNotEmpty': ($c) => {
                                $i.indent(($i) => {
                                    $c(($) => {
                                        $i.nestedLine(($i) => {
                                            $i.snippet(`| [${$d.createApostrophedString($.key)}, `);
                                            Type($.value, $p, $i);
                                            $i.snippet(`]`);
                                        });
                                    });
                                });
                            }
                        });
                    });
                    break;
                case 'type parameter':
                    pl.ss($, ($) => {
                        $i.snippet(`_T${$d.createIdentifier($.key)}`);
                    });
                    break;
                case 'type reference':
                    pl.ss($, ($) => {
                        switch ($[0]) {
                            case 'cyclic sibling':
                                pl.ss($, ($) => {
                                    $i.snippet(`${$d.createIdentifier($.key)}`);
                                    Type__Parameters($p['type parameters'], $i);
                                });
                                break;
                            case 'external':
                                pl.ss($, ($) => {
                                    Namespace__Selection($.namespaces, $i);
                                    $i.snippet(`${$d.createIdentifier($.type.key)}`);
                                    function selectLocalNSFromNS2($) {
                                        switch ($[0]) {
                                            case 'local': return pl.ss($, ($) => $);
                                            case 'parent sibling': return pl.ss($, ($) => selectLocalNSFromNS2($.namespace.referent));
                                            default: return pl.au($[0]);
                                        }
                                    }
                                    function selectNS2FromSelection($) {
                                        return pl.optional($.tail, ($) => selectNS2FromSelection($), () => $.namespace.referent);
                                    }
                                    function mergeTypeArguments($) {
                                        return $d.mergeAndIgnore({
                                            'primary': pl.optional($.tail, ($) => mergeTypeArguments($), () => pm.wrapRawDictionary({})),
                                            'secondary': $.arguments,
                                        });
                                    }
                                    const typeArguments = mergeTypeArguments($.namespaces);
                                    $d.enrichedDictionaryForEach(selectLocalNSFromNS2(selectNS2FromSelection($.namespaces)).parameters.aggregated, {
                                        'onEmpty': () => {
                                        },
                                        'onNotEmpty': ($c) => {
                                            $i.snippet(`<`);
                                            $c(($) => {
                                                typeArguments.__getEntry($.key, ($) => {
                                                    Type($.content.type, $p, $i);
                                                }, () => {
                                                    //it is a type parameter that is shared by the referer and referent.
                                                    $i.snippet(`_T${$d.createIdentifier($.key)}`);
                                                });
                                                $i.snippet(`${$.isLast ? `` : `, `}`);
                                            });
                                            $i.snippet(`>`);
                                        }
                                    });
                                });
                                break;
                            case 'sibling':
                                pl.ss($, ($) => {
                                    $i.snippet(`${$d.createIdentifier($.key)}`);
                                    Type__Parameters($p['type parameters'], $i);
                                });
                                break;
                            default: pl.au($[0]);
                        }
                    });
                    break;
                case 'value function':
                    pl.ss($, ($) => {
                        Function__Declaration($.declaration, $p, $i);
                        Type($['return type'], $p, $i);
                    });
                    break;
                default: pl.au($[0]);
            }
        };
        const Type__Parameters = ($, $i) => {
            $d.enrichedDictionaryForEach($.aggregated, {
                'onEmpty': () => {
                },
                'onNotEmpty': ($c) => {
                    $i.snippet(`<`);
                    $c(($) => {
                        $i.snippet(`_T${$d.createIdentifier($.key)}${$.isLast ? `` : `, `}`);
                    });
                    $i.snippet(`>`);
                }
            });
        };
        Root($, $i);
    };
};
exports.$$ = $$;
