"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapRawDictionary = exports.Dictionary = void 0;
const createCounter_1 = require("../private/createCounter");
const panic_1 = require("./panic");
const wrapAsyncValueImp_1 = require("./wrapAsyncValueImp");
class Dictionary {
    constructor(source) {
        this.source = source;
    }
    map($v) {
        return new Dictionary(this.source.map(($) => {
            return {
                key: $.key,
                value: $v($.value)
            };
        }));
    }
    asyncMap($v) {
        function imp(dictionary, $v) {
            const mapped = dictionary.map(($) => {
                return {
                    key: $.key,
                    value: $v($.value),
                };
            });
            mapped.forEach(($) => {
            });
            return (0, wrapAsyncValueImp_1.wrapAsyncValueImp)((cb) => {
                const temp = {};
                (0, createCounter_1.createCounter)((counter) => {
                    mapped.map(($) => {
                        counter.increment();
                        $.value.__execute((nv) => {
                            temp[$.key] = nv;
                            counter.decrement();
                        });
                    });
                }, () => {
                    cb(wrapRawDictionary(temp));
                });
            });
        }
        return imp(this.source, $v);
    }
    ///////
    __mapWithKey($v) {
        return new Dictionary(this.source.map(($) => {
            return {
                key: $.key,
                value: $v($.value, $.key),
            };
        }));
    }
    __forEach(isFirstBeforeSecond, callback) {
        const sortedKeys = this.source.map((entry, position) => {
            return {
                key: entry.key,
                position: position
            };
        }).sort((a, b) => {
            if (isFirstBeforeSecond(a.key, b.key)) {
                return -1;
            }
            else {
                if (isFirstBeforeSecond(b.key, a.key)) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
        });
        sortedKeys.forEach((sorted) => {
            callback(this.source[sorted.position].value, sorted.key);
        });
    }
    __unsafeGetEntry(key) {
        for (let i = 0; i !== this.source.length; i += 1) {
            const element = this.source[i];
            if (element.key === key) {
                return element.value;
            }
        }
        (0, panic_1.panic)(`entry '${key}' not found`);
    }
    __getEntry(key, exists, nonExists) {
        for (let i = 0; i !== this.source.length; i += 1) {
            const element = this.source[i];
            if (element.key === key) {
                return exists(element.value);
            }
        }
        return nonExists();
    }
}
exports.Dictionary = Dictionary;
function wrapRawDictionary(sourceX) {
    //first we clone the source data so that changes to that source will have no impact on this implementation.
    //only works if the set does not become extremely large
    function createDictionaryAsArray(source) {
        const imp = [];
        Object.keys(source).forEach((key) => {
            imp.push({ key: key, value: source[key] });
        });
        return imp;
    }
    const daa = createDictionaryAsArray(sourceX);
    return new Dictionary(daa);
}
exports.wrapRawDictionary = wrapRawDictionary;
