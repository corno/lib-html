import * as pt from 'pareto-core-types';
export declare namespace N {
    namespace Atom {
        namespace N {
            namespace G {
                namespace N {
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Atom_$_$Types {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Dictionary_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace dictionary {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Global_$_$Type {
        namespace N {
            namespace G {
                namespace N {
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Global_$_$Type_$_$Selection {
        namespace N {
            namespace TU {
                namespace N {
                    namespace cyclic_$_$sibling {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace _$ltype {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$limport {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace library {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace _$ltype {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace resolved_$_$sibling {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace _$ltype {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Imports {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Model {
        namespace N {
            namespace G {
                namespace N {
                    namespace root {
                        namespace N { }
                        namespace T { }
                    }
                    namespace type_$_$library {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Root {
        namespace N { }
        namespace T { }
    }
    namespace Type {
        namespace N {
            namespace G {
                namespace N {
                    namespace _$ltype {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace array {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace atom {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace atom {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace component {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace constraint {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace cyclic_$_$reference {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace atom {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace sibling {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace dictionary {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace constraints {
                                                        namespace N {
                                                            namespace D {
                                                                namespace N {
                                                                    namespace TU {
                                                                        namespace N {
                                                                            namespace dictionary {
                                                                                namespace N {
                                                                                    namespace G {
                                                                                        namespace N {
                                                                                            namespace dense {
                                                                                                namespace N {
                                                                                                    namespace TU {
                                                                                                        namespace N {
                                                                                                            namespace no {
                                                                                                                namespace N {
                                                                                                                    namespace G {
                                                                                                                        namespace N { }
                                                                                                                        namespace T { }
                                                                                                                    }
                                                                                                                }
                                                                                                                namespace T { }
                                                                                                            }
                                                                                                            namespace yes {
                                                                                                                namespace N {
                                                                                                                    namespace G {
                                                                                                                        namespace N { }
                                                                                                                        namespace T { }
                                                                                                                    }
                                                                                                                }
                                                                                                                namespace T { }
                                                                                                            }
                                                                                                        }
                                                                                                        namespace T { }
                                                                                                    }
                                                                                                }
                                                                                                namespace T { }
                                                                                            }
                                                                                            namespace dictionary {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                        }
                                                                                        namespace T { }
                                                                                    }
                                                                                }
                                                                                namespace T { }
                                                                            }
                                                                            namespace lookup {
                                                                                namespace N { }
                                                                                namespace T { }
                                                                            }
                                                                        }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                    namespace key {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace group {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace properties {
                                                        namespace N {
                                                            namespace D {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N {
                                                                            namespace _$ltype {
                                                                                namespace N { }
                                                                                namespace T { }
                                                                            }
                                                                        }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace nothing {
                                        namespace N {
                                            namespace G {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace optional {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace resolved_$_$reference {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace atom {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace value {
                                                        namespace N {
                                                            namespace TU {
                                                                namespace N {
                                                                    namespace dictionary {
                                                                        namespace N { }
                                                                        namespace T { }
                                                                    }
                                                                    namespace lookup {
                                                                        namespace N { }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace state_$_$group {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace states {
                                                        namespace N {
                                                            namespace D {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N {
                                                                            namespace _$ltype {
                                                                                namespace N { }
                                                                                namespace T { }
                                                                            }
                                                                        }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Library {
        namespace N {
            namespace G {
                namespace N {
                    namespace atom_$_$types {
                        namespace N { }
                        namespace T { }
                    }
                    namespace global_$_$types {
                        namespace N {
                            namespace D {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace imports {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace global_$_$type {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$limport {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace tail {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Selection_$_$Tail {
        namespace N {
            namespace G {
                namespace N {
                    namespace step_$_$type {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace array {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace array {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace dictionary {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace dictionary {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace group {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace group {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace property {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace optional {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace optional {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace state_$_$group {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace state {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace state_$_$group {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace tail {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
}
export declare namespace T {
    namespace Atom {
        namespace _ltype {
            type key = string;
            type referent = T.Atom__Types.D;
        }
        type _ltype = {
            readonly 'key': string;
            readonly 'referent': T.Atom__Types.D;
        };
    }
    type Atom = {
        readonly 'type': {
            readonly 'key': string;
            readonly 'referent': T.Atom__Types.D;
        };
    };
    namespace Atom__Types {
        namespace D { }
        type D = null;
    }
    type Atom__Types = pt.Dictionary<null>;
    namespace Dictionary__Selection {
        type dictionary = T.Type._ltype.dictionary;
        type _ltype = T.Type__Selection;
    }
    type Dictionary__Selection = {
        readonly 'dictionary': T.Type._ltype.dictionary;
        readonly 'type': T.Type__Selection;
    };
    namespace Global__Type {
        type _ltype = T.Type;
    }
    type Global__Type = {
        readonly 'type': T.Type;
    };
    namespace Global__Type__Selection {
        namespace cyclic__sibling {
            namespace _ltype {
                type key = string;
                namespace referent {
                    type C = T.Global__Type;
                }
                type referent = () => T.Global__Type;
            }
            type _ltype = {
                readonly 'key': string;
                readonly 'referent': () => T.Global__Type;
            };
        }
        type cyclic__sibling = {
            readonly 'type': {
                readonly 'key': string;
                readonly 'referent': () => T.Global__Type;
            };
        };
        namespace _limport {
            namespace library {
                type key = string;
                type referent = T.Imports.D;
            }
            type library = {
                readonly 'key': string;
                readonly 'referent': T.Imports.D;
            };
            namespace _ltype {
                type key = string;
                type referent = T.Type__Library.global__types.D;
            }
            type _ltype = {
                readonly 'key': string;
                readonly 'referent': T.Type__Library.global__types.D;
            };
        }
        type _limport = {
            readonly 'library': {
                readonly 'key': string;
                readonly 'referent': T.Imports.D;
            };
            readonly 'type': {
                readonly 'key': string;
                readonly 'referent': T.Type__Library.global__types.D;
            };
        };
        namespace resolved__sibling {
            namespace _ltype {
                type key = string;
                type referent = T.Global__Type;
            }
            type _ltype = {
                readonly 'key': string;
                readonly 'referent': T.Global__Type;
            };
        }
        type resolved__sibling = {
            readonly 'type': {
                readonly 'key': string;
                readonly 'referent': T.Global__Type;
            };
        };
    }
    type Global__Type__Selection = [
        'cyclic sibling',
        {
            readonly 'type': {
                readonly 'key': string;
                readonly 'referent': () => T.Global__Type;
            };
        }
    ] | [
        'import',
        {
            readonly 'library': {
                readonly 'key': string;
                readonly 'referent': T.Imports.D;
            };
            readonly 'type': {
                readonly 'key': string;
                readonly 'referent': T.Type__Library.global__types.D;
            };
        }
    ] | [
        'resolved sibling',
        {
            readonly 'type': {
                readonly 'key': string;
                readonly 'referent': T.Global__Type;
            };
        }
    ];
    namespace Imports {
        namespace D {
            namespace constraints {
                type library = T.Type__Library;
            }
            type constraints = {
                readonly 'library': T.Type__Library;
            };
            namespace content { }
            type content = null;
        }
        type D = {
            readonly 'constraints': {
                readonly 'library': T.Type__Library;
            };
            readonly 'content': null;
        };
    }
    type Imports = pt.Dictionary<{
        readonly 'constraints': {
            readonly 'library': T.Type__Library;
        };
        readonly 'content': null;
    }>;
    namespace Model {
        namespace root {
            type key = string;
            type referent = T.Type__Library.global__types.D;
        }
        type root = {
            readonly 'key': string;
            readonly 'referent': T.Type__Library.global__types.D;
        };
        type type__library = T.Type__Library;
    }
    type Model = {
        readonly 'root': {
            readonly 'key': string;
            readonly 'referent': T.Type__Library.global__types.D;
        };
        readonly 'type library': T.Type__Library;
    };
    type Root = T.Model;
    namespace Type {
        namespace _ltype {
            namespace array {
                type _ltype = T.Type;
            }
            type array = {
                readonly 'type': T.Type;
            };
            namespace atom {
                type atom = T.Atom;
            }
            type atom = {
                readonly 'atom': T.Atom;
            };
            namespace component {
                type _ltype = T.Global__Type__Selection;
            }
            type component = {
                readonly 'type': T.Global__Type__Selection;
            };
            type constraint = T.Type__Selection;
            namespace cyclic__reference {
                type atom = T.Atom;
                type sibling = T.Global__Type__Selection;
            }
            type cyclic__reference = {
                readonly 'atom': T.Atom;
                readonly 'sibling': T.Global__Type__Selection;
            };
            namespace dictionary {
                namespace constraints {
                    namespace D {
                        namespace dictionary {
                            namespace dense {
                                namespace no { }
                                type no = null;
                                namespace yes { }
                                type yes = null;
                            }
                            type dense = ['no', null] | ['yes', null];
                            type dictionary = T.Dictionary__Selection;
                        }
                        type dictionary = {
                            readonly 'dense': ['no', null] | ['yes', null];
                            readonly 'dictionary': T.Dictionary__Selection;
                        };
                        type lookup = T.Global__Type__Selection;
                    }
                    type D = [
                        'dictionary',
                        {
                            readonly 'dense': ['no', null] | ['yes', null];
                            readonly 'dictionary': T.Dictionary__Selection;
                        }
                    ] | ['lookup', T.Global__Type__Selection];
                }
                type constraints = pt.Dictionary<[
                    'dictionary',
                    {
                        readonly 'dense': ['no', null] | ['yes', null];
                        readonly 'dictionary': T.Dictionary__Selection;
                    }
                ] | ['lookup', T.Global__Type__Selection]>;
                type key = T.Atom;
                type _ltype = T.Type;
            }
            type dictionary = {
                readonly 'constraints': pt.Dictionary<[
                    'dictionary',
                    {
                        readonly 'dense': ['no', null] | ['yes', null];
                        readonly 'dictionary': T.Dictionary__Selection;
                    }
                ] | ['lookup', T.Global__Type__Selection]>;
                readonly 'key': T.Atom;
                readonly 'type': T.Type;
            };
            namespace group {
                namespace properties {
                    namespace D {
                        type _ltype = T.Type;
                    }
                    type D = {
                        readonly 'type': T.Type;
                    };
                }
                type properties = pt.Dictionary<{
                    readonly 'type': T.Type;
                }>;
            }
            type group = {
                readonly 'properties': pt.Dictionary<{
                    readonly 'type': T.Type;
                }>;
            };
            namespace nothing { }
            type nothing = null;
            namespace optional {
                type _ltype = T.Type;
            }
            type optional = {
                readonly 'type': T.Type;
            };
            namespace resolved__reference {
                type atom = T.Atom;
                namespace value {
                    type dictionary = T.Dictionary__Selection;
                    type lookup = T.Global__Type__Selection;
                }
                type value = ['dictionary', T.Dictionary__Selection] | ['lookup', T.Global__Type__Selection];
            }
            type resolved__reference = {
                readonly 'atom': T.Atom;
                readonly 'value': ['dictionary', T.Dictionary__Selection] | ['lookup', T.Global__Type__Selection];
            };
            namespace state__group {
                namespace states {
                    namespace D {
                        type _ltype = T.Type;
                    }
                    type D = {
                        readonly 'type': T.Type;
                    };
                }
                type states = pt.Dictionary<{
                    readonly 'type': T.Type;
                }>;
            }
            type state__group = {
                readonly 'states': pt.Dictionary<{
                    readonly 'type': T.Type;
                }>;
            };
        }
        type _ltype = [
            'array',
            {
                readonly 'type': T.Type;
            }
        ] | [
            'atom',
            {
                readonly 'atom': T.Atom;
            }
        ] | [
            'component',
            {
                readonly 'type': T.Global__Type__Selection;
            }
        ] | ['constraint', T.Type__Selection] | [
            'cyclic reference',
            {
                readonly 'atom': T.Atom;
                readonly 'sibling': T.Global__Type__Selection;
            }
        ] | [
            'dictionary',
            {
                readonly 'constraints': pt.Dictionary<[
                    'dictionary',
                    {
                        readonly 'dense': ['no', null] | ['yes', null];
                        readonly 'dictionary': T.Dictionary__Selection;
                    }
                ] | ['lookup', T.Global__Type__Selection]>;
                readonly 'key': T.Atom;
                readonly 'type': T.Type;
            }
        ] | [
            'group',
            {
                readonly 'properties': pt.Dictionary<{
                    readonly 'type': T.Type;
                }>;
            }
        ] | ['nothing', null] | [
            'optional',
            {
                readonly 'type': T.Type;
            }
        ] | [
            'resolved reference',
            {
                readonly 'atom': T.Atom;
                readonly 'value': ['dictionary', T.Dictionary__Selection] | ['lookup', T.Global__Type__Selection];
            }
        ] | [
            'state group',
            {
                readonly 'states': pt.Dictionary<{
                    readonly 'type': T.Type;
                }>;
            }
        ];
    }
    type Type = {
        readonly 'type': [
            'array',
            {
                readonly 'type': T.Type;
            }
        ] | [
            'atom',
            {
                readonly 'atom': T.Atom;
            }
        ] | [
            'component',
            {
                readonly 'type': T.Global__Type__Selection;
            }
        ] | ['constraint', T.Type__Selection] | [
            'cyclic reference',
            {
                readonly 'atom': T.Atom;
                readonly 'sibling': T.Global__Type__Selection;
            }
        ] | [
            'dictionary',
            {
                readonly 'constraints': pt.Dictionary<[
                    'dictionary',
                    {
                        readonly 'dense': ['no', null] | ['yes', null];
                        readonly 'dictionary': T.Dictionary__Selection;
                    }
                ] | ['lookup', T.Global__Type__Selection]>;
                readonly 'key': T.Atom;
                readonly 'type': T.Type;
            }
        ] | [
            'group',
            {
                readonly 'properties': pt.Dictionary<{
                    readonly 'type': T.Type;
                }>;
            }
        ] | ['nothing', null] | [
            'optional',
            {
                readonly 'type': T.Type;
            }
        ] | [
            'resolved reference',
            {
                readonly 'atom': T.Atom;
                readonly 'value': ['dictionary', T.Dictionary__Selection] | ['lookup', T.Global__Type__Selection];
            }
        ] | [
            'state group',
            {
                readonly 'states': pt.Dictionary<{
                    readonly 'type': T.Type;
                }>;
            }
        ];
    };
    namespace Type__Library {
        type atom__types = T.Atom__Types;
        namespace global__types {
            type D = T.Global__Type;
        }
        type global__types = pt.Dictionary<T.Global__Type>;
        type imports = T.Imports;
    }
    type Type__Library = {
        readonly 'atom types': T.Atom__Types;
        readonly 'global types': pt.Dictionary<T.Global__Type>;
        readonly 'imports': T.Imports;
    };
    namespace Type__Selection {
        namespace global__type {
            type key = string;
            type referent = T.Global__Type;
        }
        type global__type = {
            readonly 'key': string;
            readonly 'referent': T.Global__Type;
        };
        namespace _limport {
            namespace O {
                type key = string;
                type referent = T.Imports.D;
            }
            type O = {
                readonly 'key': string;
                readonly 'referent': T.Imports.D;
            };
        }
        type _limport = [false] | [
            true,
            {
                readonly 'key': string;
                readonly 'referent': T.Imports.D;
            }
        ];
        namespace tail {
            type O = T.Type__Selection__Tail;
        }
        type tail = [false] | [true, T.Type__Selection__Tail];
    }
    type Type__Selection = {
        readonly 'global type': {
            readonly 'key': string;
            readonly 'referent': T.Global__Type;
        };
        readonly 'import': [false] | [
            true,
            {
                readonly 'key': string;
                readonly 'referent': T.Imports.D;
            }
        ];
        readonly 'tail': [false] | [true, T.Type__Selection__Tail];
    };
    namespace Type__Selection__Tail {
        namespace step__type {
            namespace array {
                type array = T.Type._ltype.array;
            }
            type array = {
                readonly 'array': T.Type._ltype.array;
            };
            namespace dictionary {
                type dictionary = T.Type._ltype.dictionary;
            }
            type dictionary = {
                readonly 'dictionary': T.Type._ltype.dictionary;
            };
            namespace group {
                type group = T.Type._ltype.group;
                namespace property {
                    type key = string;
                    type referent = T.Type._ltype.group.properties.D;
                }
                type property = {
                    readonly 'key': string;
                    readonly 'referent': T.Type._ltype.group.properties.D;
                };
            }
            type group = {
                readonly 'group': T.Type._ltype.group;
                readonly 'property': {
                    readonly 'key': string;
                    readonly 'referent': T.Type._ltype.group.properties.D;
                };
            };
            namespace optional {
                type optional = T.Type._ltype.optional;
            }
            type optional = {
                readonly 'optional': T.Type._ltype.optional;
            };
            namespace state__group {
                namespace state {
                    type key = string;
                    type referent = T.Type._ltype.state__group.states.D;
                }
                type state = {
                    readonly 'key': string;
                    readonly 'referent': T.Type._ltype.state__group.states.D;
                };
                type state__group = T.Type._ltype.state__group;
            }
            type state__group = {
                readonly 'state': {
                    readonly 'key': string;
                    readonly 'referent': T.Type._ltype.state__group.states.D;
                };
                readonly 'state group': T.Type._ltype.state__group;
            };
        }
        type step__type = [
            'array',
            {
                readonly 'array': T.Type._ltype.array;
            }
        ] | [
            'dictionary',
            {
                readonly 'dictionary': T.Type._ltype.dictionary;
            }
        ] | [
            'group',
            {
                readonly 'group': T.Type._ltype.group;
                readonly 'property': {
                    readonly 'key': string;
                    readonly 'referent': T.Type._ltype.group.properties.D;
                };
            }
        ] | [
            'optional',
            {
                readonly 'optional': T.Type._ltype.optional;
            }
        ] | [
            'state group',
            {
                readonly 'state': {
                    readonly 'key': string;
                    readonly 'referent': T.Type._ltype.state__group.states.D;
                };
                readonly 'state group': T.Type._ltype.state__group;
            }
        ];
        namespace tail {
            type O = T.Type__Selection__Tail;
        }
        type tail = [false] | [true, T.Type__Selection__Tail];
    }
    type Type__Selection__Tail = {
        readonly 'step type': [
            'array',
            {
                readonly 'array': T.Type._ltype.array;
            }
        ] | [
            'dictionary',
            {
                readonly 'dictionary': T.Type._ltype.dictionary;
            }
        ] | [
            'group',
            {
                readonly 'group': T.Type._ltype.group;
                readonly 'property': {
                    readonly 'key': string;
                    readonly 'referent': T.Type._ltype.group.properties.D;
                };
            }
        ] | [
            'optional',
            {
                readonly 'optional': T.Type._ltype.optional;
            }
        ] | [
            'state group',
            {
                readonly 'state': {
                    readonly 'key': string;
                    readonly 'referent': T.Type._ltype.state__group.states.D;
                };
                readonly 'state group': T.Type._ltype.state__group;
            }
        ];
        readonly 'tail': [false] | [true, T.Type__Selection__Tail];
    };
}
