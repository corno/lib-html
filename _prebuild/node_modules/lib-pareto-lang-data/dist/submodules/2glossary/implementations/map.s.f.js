"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$$ = void 0;
const pl = __importStar(require("pareto-core-lib"));
const pm = __importStar(require("pareto-core-map"));
const $$ = ($d) => {
    const createOptionalAnnotation = ($, $p) => {
        return $p['mapping settings']['create annotations']
            ? [true, {
                    'type': ['reference', ['glossary parameterXX', "Annotation"]],
                }]
            : [false];
    };
    function createPossiblyOptionalType2($, $p) {
        switch ($[0]) {
            case 'optional': return pl.ss($, ($) => ['optional', $p.cb()]);
            case 'required': return pl.ss($, ($) => $p.cb());
            default: return pl.au($[0]);
        }
    }
    function createPossiblyOptionalType($, $p) {
        return pl.optional($p['mapping settings']['constraints mapping'].constraints, ($) => [true, {
                'type': createPossiblyOptionalType2($, {
                    'cb': $p.cb,
                })
            }], () => [false]);
    }
    const map_Global__Type__Selection = ($, $p) => {
        switch ($[0]) {
            case 'cyclic sibling': return pl.ss($, ($) => {
                return {
                    'context': ['local', null],
                    'type arguments': pm.wrapRawDictionary({}),
                    'typeXX': $.type.key,
                    'tailXX': pm.wrapRawArray([]),
                };
            });
            case 'import': return pl.ss($, ($) => {
                return {
                    'context': ['import', {
                            'glossary': {
                                'glossary': {
                                    'annotation': null,
                                    'key': $.library.key
                                },
                                'glossary arguments': $d.filter(pm.wrapRawDictionary({
                                    "Annotation": $p['mapping settings']['create annotations']
                                        ? [true, ['glossary parameterXX', "Annotation"],]
                                        : [false]
                                }))
                            }
                        }],
                    'type arguments': pm.wrapRawDictionary({}),
                    'typeXX': $.type.key,
                    'tailXX': pm.wrapRawArray([]),
                };
            });
            case 'resolved sibling': return pl.ss($, ($) => {
                return {
                    'context': ['local', null],
                    'type arguments': pm.wrapRawDictionary({}),
                    'typeXX': $.type.key,
                    'tailXX': pm.wrapRawArray([]),
                };
            });
            default: return pl.au($[0]);
        }
    };
    const tail2tail = ($) => {
        return $d.merge(pm.wrapRawArray([
            pl.cc($['step type'], ($) => {
                switch ($[0]) {
                    case 'array': return pl.ss($, ($) => pm.wrapRawArray(["A"]));
                    case 'dictionary': return pl.ss($, ($) => pm.wrapRawArray(["D"]));
                    case 'group': return pl.ss($, ($) => pm.wrapRawArray([$.property.key]));
                    case 'optional': return pl.ss($, ($) => pm.wrapRawArray(["O"]));
                    case 'state group': return pl.ss($, ($) => pm.wrapRawArray([$.state.key]));
                    default: return pl.au($[0]);
                }
            }),
            pl.optional($.tail, ($) => tail2tail($), () => pm.wrapRawArray([]))
        ]));
    };
    const map_Type__Selection = ($, $p) => {
        return {
            'context': pl.optional($.import, ($) => ['import', {
                    'glossary': {
                        'glossary arguments': $p['mapping settings']['create annotations']
                            ? pm.wrapRawDictionary({
                                "Annotation": ['glossary parameterXX', "Annotation"]
                            })
                            : pm.wrapRawDictionary({}),
                        'glossary': {
                            'annotation': null,
                            'key': $.key
                        }
                    }
                }], () => ['local', null]),
            'type arguments': pm.wrapRawDictionary({}),
            'typeXX': $['global type'].key,
            'tailXX': $d.merge(pm.wrapRawArray([
                pl.optional($.tail, ($) => tail2tail($), () => pm.wrapRawArray([])),
                $p.getLastSteps()
            ])),
        };
    };
    const mapTypeToNamespace = ($) => {
        return {
            'namespaces': pl.cc($, ($) => {
                return pl.cc($.type, ($) => {
                    switch ($[0]) {
                        case 'array': return pl.ss($, ($) => pm.wrapRawDictionary({
                            "A": mapTypeToNamespace($.type)
                        }));
                        case 'constraint': return pl.ss($, ($) => pm.wrapRawDictionary({}));
                        case 'nothing': return pl.ss($, ($) => pm.wrapRawDictionary({}));
                        case 'optional': return pl.ss($, ($) => pm.wrapRawDictionary({
                            "O": mapTypeToNamespace($.type)
                        }));
                        case 'component': return pl.ss($, ($) => pm.wrapRawDictionary({}));
                        case 'dictionary': return pl.ss($, ($) => pm.wrapRawDictionary({
                            "D": mapTypeToNamespace($.type)
                        }));
                        case 'group': return pl.ss($, ($) => pm.wrapRawDictionary({
                            "G": {
                                'namespaces': $.properties.map(($) => mapTypeToNamespace($.type)),
                                'types': pm.wrapRawDictionary({}),
                            }
                        }));
                        case 'atom': return pl.ss($, ($) => pm.wrapRawDictionary({}));
                        case 'cyclic reference': return pl.ss($, ($) => pm.wrapRawDictionary({}));
                        case 'resolved reference': return pl.ss($, ($) => pm.wrapRawDictionary({}));
                        case 'state group': return pl.ss($, ($) => pm.wrapRawDictionary({
                            "TU": {
                                'namespaces': $.states.map(($) => mapTypeToNamespace($.type)),
                                'types': pm.wrapRawDictionary({}),
                            }
                        }));
                        default: return pl.au($[0]);
                    }
                });
            }),
            'types': pl.cc($, ($) => pm.wrapRawDictionary({})),
        };
    };
    const createMappedAtom = (term, $p) => {
        return $p['atom mappings'].__getEntry(term.type.key, ($) => {
            switch ($[0]) {
                case 'boolean': return pl.ss($, ($) => ['boolean', null]);
                case 'number': return pl.ss($, ($) => ['number', null]);
                case 'string': return pl.ss($, ($) => ['string', null]);
                default: return pl.au($[0]);
            }
        }, () => pl.panic(`MISSING TERMINAL MAPPING: ${term.type.key}`));
    };
    const mapTypeToType = ($, $p) => {
        return pl.cc($.type, ($) => {
            switch ($[0]) {
                case 'nothing': return pl.ss($, ($) => {
                    return ['null', null];
                });
                case 'array': return pl.ss($, ($) => ['array', mapTypeToType($.type, $p)]);
                case 'optional': return pl.ss($, ($) => {
                    return ['optional', mapTypeToType($.type, $p)];
                });
                case 'component': return pl.ss($, ($) => ['reference', ['type', pl.cc($.type, ($) => {
                            switch ($[0]) {
                                case 'cyclic sibling': return pl.ss($, ($) => ({
                                    'context': ['local', null],
                                    'tailXX': pm.wrapRawArray([]),
                                    'typeXX': $.type.key,
                                    'type arguments': pm.wrapRawDictionary({}),
                                }));
                                case 'import': return pl.ss($, ($) => ({
                                    'context': ['import', {
                                            'glossary': {
                                                'glossary': {
                                                    'annotation': null,
                                                    'key': $.library.key
                                                },
                                                'glossary arguments': pm.wrapRawDictionary({
                                                    "Annotation": ['glossary parameterXX', "Annotation"]
                                                }),
                                            }
                                        }],
                                    'tailXX': pm.wrapRawArray([]),
                                    'typeXX': $.type.key,
                                    'type arguments': pm.wrapRawDictionary({}),
                                }));
                                case 'resolved sibling': return pl.ss($, ($) => ({
                                    'context': ['local', null],
                                    'tailXX': pm.wrapRawArray([]),
                                    'typeXX': $.type.key,
                                    'type arguments': pm.wrapRawDictionary({}),
                                }));
                                default: return pl.au($[0]);
                                /*
                                {
                            'context': pl.cc($, ($) => {
                                switch ($.context[0]) {
                                    case 'import': return pl.ss($.context, ($) => ['import', {
                                        'glossary': {
                                            'glossary': {
                                                'annotation': null,
                                                'key': $.library.key
                                            },
                                            'glossary arguments': pm.wrapRawDictionary({
                                                "Annotation": ['glossary parameterXX', "Annotation"]
                                            }),
                                        }
                                    }])
                                    case 'local': return pl.ss($.context, ($) => ['local', null])
                                    default: return pl.au($.context[0])
                                }
                            }),
                            'typeXX': $.type.key,
                            'tailXX': pm.wrapRawArray([]),
                            'type arguments': pm.wrapRawDictionary<g_glossary.T.DataSpecifier<null>>({}),
                        }
                        */
                            }
                        })]]);
                case 'constraint': return pl.ss($, ($) => {
                    const $a = $;
                    return pl.optional($p['mapping settings']['constraints mapping'].constraints, ($) => pl.cc($, ($) => {
                        switch ($[0]) {
                            case 'optional': return pl.ss($, ($) => ['optional', ['reference', ['type', map_Type__Selection($a, {
                                            'mapping settings': $p['mapping settings'],
                                            'getLastSteps': () => pm.wrapRawArray([])
                                        })]]]);
                            case 'required': return pl.ss($, ($) => ['reference', ['type', map_Type__Selection($a, {
                                        'mapping settings': $p['mapping settings'],
                                        'getLastSteps': () => pm.wrapRawArray([])
                                    })]]);
                            default: return pl.au($[0]);
                        }
                    }), () => ['reference', ['glossary parameterXX', "Annotation"]]);
                });
                case 'dictionary': return pl.ss($, ($) => pl.cc($, ($) => {
                    const type = $.type;
                    const constraints = $.constraints;
                    function doDict() {
                        return ['dictionary', ($d.isEmpty(constraints))
                                ? mapTypeToType(type, $p)
                                : ['group', $d.filter(pm.wrapRawDictionary({
                                        "annotation": createOptionalAnnotation(null, $p),
                                        "constraints": createPossiblyOptionalType(null, {
                                            'mapping settings': $p['mapping settings'],
                                            'cb': () => {
                                                return ['group', constraints.map(($) => {
                                                        return pl.cc($, ($) => {
                                                            switch ($[0]) {
                                                                case 'dictionary': return pl.ss($, ($) => {
                                                                    const $a = $;
                                                                    return {
                                                                        'type': pl.cc($, ($) => {
                                                                            return ['reference', ['type', map_Type__Selection($a.dictionary.type, {
                                                                                        'mapping settings': $p['mapping settings'],
                                                                                        'getLastSteps': () => pm.wrapRawArray(["D"])
                                                                                    })]];
                                                                        })
                                                                    };
                                                                });
                                                                case 'lookup': return pl.ss($, ($) => {
                                                                    const $a = $;
                                                                    return {
                                                                        'type': ['reference', ['type', map_Global__Type__Selection($a, $p)]]
                                                                    };
                                                                });
                                                                default: return pl.au($[0]);
                                                            }
                                                        });
                                                    })];
                                            }
                                        }),
                                        "content": [true, {
                                                'type': mapTypeToType(type, $p)
                                            }]
                                    }))]
                        ];
                    }
                    return $p['mapping settings']['create annotations']
                        ? ['group', pm.wrapRawDictionary({
                                "annotation": {
                                    'type': ['reference', ['glossary parameterXX', "Annotation"]],
                                },
                                "dictionary": {
                                    'type': doDict()
                                }
                            })]
                        : doDict();
                }));
                case 'group': return pl.ss($, ($) => ['group', $.properties.map(($) => ({
                        'type': mapTypeToType($.type, $p),
                    }))]);
                case 'atom': return pl.ss($, ($) => {
                    const term = $.atom;
                    return createMappedAtom(term, {
                        'atom mappings': $p['atom mappings']
                    });
                });
                case 'resolved reference': return pl.ss($, ($) => {
                    const atom = $.atom;
                    return ['group', $d.filter(pm.wrapRawDictionary({
                            "key": $p['mapping settings']['constraints mapping']['terminal values']
                                ? [true, {
                                        'type': createMappedAtom($.atom, {
                                            'atom mappings': $p['atom mappings']
                                        }),
                                    }]
                                : [false],
                            "referent": pl.cc($, ($) => {
                                function createOptionalConstraintProperty($cb) {
                                    return pl.optional($p['mapping settings']['constraints mapping'].constraints, ($) => pl.cc($, ($) => {
                                        switch ($[0]) {
                                            case 'optional': return pl.ss($, ($) => [true, {
                                                    'type': ['optional', $cb()]
                                                }]);
                                            case 'required': return pl.ss($, ($) => [true, {
                                                    'type': $cb()
                                                }]);
                                            default: return pl.au($[0]);
                                        }
                                    }), () => [false]);
                                }
                                return createOptionalConstraintProperty(() => {
                                    return pl.cc($.value, ($) => {
                                        switch ($[0]) {
                                            case 'dictionary': return pl.ss($, ($) => ['reference', ['type', map_Type__Selection($['type'], {
                                                        'mapping settings': $p['mapping settings'],
                                                        'getLastSteps': () => pm.wrapRawArray(["D"])
                                                    })]]);
                                            case 'lookup': return pl.ss($, ($) => ['reference', ['type', map_Global__Type__Selection($, $p)]]);
                                            default: return pl.au($[0]);
                                        }
                                    });
                                });
                            }),
                            "annotation": createOptionalAnnotation(null, $p),
                        }))];
                });
                case 'cyclic reference': return pl.ss($, ($) => {
                    const atom = $.atom;
                    return ['group', $d.filter(pm.wrapRawDictionary({
                            "key": $p['mapping settings']['constraints mapping']['terminal values']
                                ? [true, {
                                        'type': createMappedAtom($.atom, {
                                            'atom mappings': $p['atom mappings']
                                        }),
                                    }]
                                : [false],
                            "referent": pl.cc($, ($) => {
                                return createPossiblyOptionalType(null, {
                                    'mapping settings': $p['mapping settings'],
                                    'cb': () => {
                                        return ['computed', ['reference', ['type', map_Global__Type__Selection($.sibling, $p)]]];
                                    }
                                });
                            }),
                            "annotation": createOptionalAnnotation(null, $p),
                        }))];
                });
                case 'state group': return pl.ss($, ($) => {
                    return ['taggedUnion', $.states.map(($) => pl.cc($, ($) => {
                            const type = $.type;
                            return mapTypeToType(type, $p);
                        }))];
                });
                default: return pl.au($[0]);
            }
        });
    };
    const map_Type__Library_2_Glossary = ($, $p) => {
        return {
            'imports': $.imports.map(($) => null),
            'glossary parameters': $p['mapping settings']['create annotations']
                ? pm.wrapRawDictionary({
                    "Annotation": null,
                })
                : pm.wrapRawDictionary({}),
            'root': {
                'namespaces': $['global types'].map(($) => mapTypeToNamespace($.type)),
                'types': $['global types'].__mapWithKey(($, key) => {
                    return {
                        'parameters': pm.wrapRawDictionary({}),
                        'type': mapTypeToType($.type, $p),
                    };
                })
            },
            'asynchronous': {
                'interfaces': pm.wrapRawDictionary({}),
                'algorithms': pm.wrapRawDictionary({}),
            },
            'synchronous': {
                'interfaces': pm.wrapRawDictionary({
                // if ($.settings['visitor interface'][0] === true) {
                //     // add({
                //     //     'key': "Visitor",
                //     //     'value': ['group', {
                //     //         'members': $.mappedModel.model['type library']['global types'].map<g_glossary.T.Interface>(($) => {
                //     //             return ['method', {
                //     //                 'data': [false], //FIXME
                //     //                 'interface': [false], //FIXME
                //     //             }]
                //     //         })
                //     //     }],
                //     // })
                // }
                }),
                'algorithms': pm.wrapRawDictionary({}),
            },
        };
    };
    return ($) => {
        return map_Type__Library_2_Glossary($.library, {
            'mapping settings': $['mapping settings'],
            'atom mappings': $['atom mappings']
        });
    };
};
exports.$$ = $$;
