"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeLibrary = exports.pExternal = exports.pResolvedValue = exports.imported = exports.typeRef = exports.component = exports.aResolvedValue = exports.fromContextSelection = exports.fromVariableSelection = exports.anyValueSelection = exports.valueSelection = exports.v_ref = exports.v_sg = exports.v_grp = exports.atom = exports.stateGroup = exports.constrainedState = exports.stateConstraint = exports.state = exports.group = exports.globalType = exports.dictionary = exports.constrainedDictionary = exports.dictionaryConstraint = exports.dictionaryReference = exports.dependentProp = exports.prop = exports.nothing = exports.optional = exports.constrainedOptional = exports.array = void 0;
const pd = __importStar(require("pareto-core-data"));
const a = pd.a;
function dict($) {
    return {
        'annotation': pd.getLocationInfo(2),
        'dictionary': pd.d($),
    };
}
function ref(name, depth = 1) {
    return {
        key: name,
        annotation: pd.getLocationInfo(depth + 1),
    };
}
// function d_imp<T>($: RawDictionary<T>, annotation: pd.SourceLocation): g_common.T.AnnotatedDictionary<pd.SourceLocation, T> {
//     return {
//         'annotation': annotation,
//         'dictionary': dict($),
//     }
// }
// export function d<T>($: RawDictionary<T>) {
//     const li = pd.getLocationInfo(1)
//     return d_imp($, li)
// }
// export function r(name: string): g_common.T.AnnotatedKey<pd.SourceLocation> {
//     return r_imp(name, 1)
// }
function array(type) {
    return {
        'type': ['array', {
                'type': type,
                //'constraint': [false]
            }]
    };
}
exports.array = array;
function constrainedOptional(constraints, type) {
    return {
        'type': ['optional', {
                'constraints': dict(constraints),
                'variables': dict({}),
                'type': type,
                //'constraint': [false]
            }]
    };
}
exports.constrainedOptional = constrainedOptional;
function optional(type) {
    return {
        'type': ['optional', {
                'constraints': dict({}),
                'variables': dict({}),
                'type': type,
                //'constraint': [false]
            }]
    };
}
exports.optional = optional;
function nothing(valSel) {
    return {
        'type': ['nothing', null]
    };
}
exports.nothing = nothing;
function prop(type) {
    return type;
}
exports.prop = prop;
function dependentProp(siblings, type) {
    return {
        'variables': {
            'annotation': pd.getLocationInfo(1),
            'dictionary': pd.d(siblings).map(($) => {
                return ['sibling property', ref($)];
            })
        },
        'type': type,
    };
}
exports.dependentProp = dependentProp;
function dictionaryReference(type) {
    return {
        'type': ['resolved reference', {
                'atom': {
                    'type': ref("identifier")
                },
                'dictionary': {
                    'dictionary': pd.getLocationInfo(1),
                    'type': type,
                }
            }]
    };
}
exports.dictionaryReference = dictionaryReference;
// export function lookupReference(
//     type: g_this.T.Lookup__Selection<pd.SourceLocation>,
// ): g_this.T.Type<pd.SourceLocation> {
//     return {
//         'type': ['resolved reference', {
//             'annotation': pd.getLocationInfo(1),
//             'content': {
//                 'atom': {
//                     'type': {
//                         'annotation': pd.getLocationInfo(1),
//                         'key': "identifier",
//                     }
//                 },
//                 'value': ['lookup', {
//                     'annotation': pd.getLocationInfo(1),
//                     'content': type,
//                 }],
//             }
//         }]
//     }
// }
// export function cyclicReference(
//     gloRef: g_this.T.Global__Type__Selection<pd.SourceLocation>,
// ): g_this.T.Type<pd.SourceLocation> {
//     return {
//         'type': ['cyclic reference', {
//             'atom': {
//                 'type': {
//                     'annotation': pd.getLocationInfo(1),
//                     'key': "identifier",
//                 }
//             },
//             'sibling': gloRef,
//         }]
//     }
// }
// export function lookupConstraint(
//     lookupSelection: g_this.T.Lookup__Selection<pd.SourceLocation>
// ): g_this.T.Dictionary__Constraints.dictionary.D<pd.SourceLocation> {
//     return ['lookup', {
//         'annotation': pd.getLocationInfo(1),
//         'content': lookupSelection,
//     }]
// }
function dictionaryConstraint(type, dense) {
    return ['dictionary', {
            'dictionary': {
                'type': type,
                'dictionary': pd.getLocationInfo(1),
            },
            'dense': dense
                ? ['yes', null]
                : ['no', null]
        }];
}
exports.dictionaryConstraint = dictionaryConstraint;
function constrainedDictionary(constraints, type) {
    return {
        'type': ['dictionary', {
                'key': {
                    'type': ref("identifier"),
                },
                'constraints': dict(constraints),
                'variables': dict({}),
                'type': type,
                //'autofill': pd.a([]),
            }]
    };
}
exports.constrainedDictionary = constrainedDictionary;
function dictionary(type /*, autofill?: g_this.T.Type._ltype.dictionary.autofill.A<pd.SourceLocation>[]*/) {
    return {
        'type': ['dictionary', {
                // 'annotation': li,
                'key': {
                    'type': ref("identifier")
                },
                'constraints': dict({}),
                'variables': dict({}),
                'type': type,
                //'autofill': pd.a(autofill === undefined ? [] : autofill),
            }]
    };
}
exports.dictionary = dictionary;
function globalType(parameters, type, result) {
    return {
        'parameters': dict(parameters),
        'variables': dict({}),
        'type': type,
        'result': result === undefined ? [false] : [true, result]
    };
}
exports.globalType = globalType;
function group(rawProperties) {
    const allPrecedingSiblings = {};
    return {
        'type': ['group', {
                'properties': {
                    'annotation': pd.getLocationInfo(1),
                    'dictionary': pd.d(rawProperties).__mapWithKey(($, key) => {
                        const precedingSiblings = {};
                        pd.d(allPrecedingSiblings).__forEach(() => false, ($, key) => {
                            precedingSiblings[key] = $;
                        });
                        allPrecedingSiblings[key] = ['sibling property', {
                                'annotation': pd.getLocationInfo(1),
                                'key': key,
                            }];
                        return {
                            'variables': dict(precedingSiblings),
                            'type': $
                        };
                    }),
                },
            }]
    };
}
exports.group = group;
function state(type) {
    return {
        'constraints': dict({}),
        'variables': dict({}),
        'type': type,
    };
}
exports.state = state;
function stateConstraint(type, option) {
    return {
        'type': type,
        'state group': pd.getLocationInfo(1),
        'state': {
            'annotation': pd.getLocationInfo(1),
            'key': option
        }
    };
}
exports.stateConstraint = stateConstraint;
function constrainedState(constraints, type) {
    return {
        'constraints': dict(constraints),
        'variables': dict({}),
        'type': type,
    };
}
exports.constrainedState = constrainedState;
function stateGroup(states) {
    let firstKey = null;
    pd.d(states).__mapWithKey(($, key) => {
        if (firstKey === null) {
            firstKey = key;
        }
    });
    if (firstKey === null) {
        firstKey = "--NO STATES--";
    }
    return {
        'type': ['state group', {
                'states': dict(states),
            }]
    };
}
exports.stateGroup = stateGroup;
function atom(type) {
    return {
        'type': ['atom', {
                'atom': {
                    'type': {
                        'annotation': pd.getLocationInfo(1),
                        'key': type,
                    }
                },
            }]
    };
}
exports.atom = atom;
function v_grp(prop, tail) {
    return ['group', {
            'group': pd.getLocationInfo(1),
            'property': ref(prop),
            'tail': tail === undefined ? [false] : [true, tail]
        }];
}
exports.v_grp = v_grp;
function v_sg(type, states) {
    return ['state group', {
            'state group': pd.getLocationInfo(1),
            'result type': type,
            'states': dict(states)
        }];
}
exports.v_sg = v_sg;
function v_ref(tail) {
    return ['reference', {
            'reference': pd.getLocationInfo(1),
            'tail': tail === undefined ? [false] : [true, tail]
        }];
}
exports.v_ref = v_ref;
// export function dictionarySelection(
//     valueSelection: g_this.T.No__Context__Value__Selection<pd.SourceLocation>,
// ): g_this.T.Dictionary__Selection<pd.SourceLocation> {
//     return {
//         'type': valueSelection,
//         'cast': ['dictionary', {
//             'annotation': pd.getLocationInfo(1),
//             'content': null
//         }]
//     }
// }
// export function stateSelection(
//     valueSelection: g_this.T.No__Context__Value__Selection<pd.SourceLocation>,
//     state: string,
// ): g_this.T.State__Selection<pd.SourceLocation> {
//     return {
//         'type': valueSelection,
//         'cast': ['state group', {
//             'annotation': pd.getLocationInfo(1),
//             'content': {
//                 'state': {
//                     'annotation': pd.getLocationInfo(1),
//                     'key': state,
//                 }
//             }
//         }]
//     }
// }
function valueSelection(variable, tail) {
    return {
        'start': {
            'annotation': pd.getLocationInfo(1),
            'key': variable,
        },
        'tail': tail === undefined ? [false] : [true, tail]
    };
}
exports.valueSelection = valueSelection;
function anyValueSelection(variable, tail) {
    return {
        'start': {
            'annotation': pd.getLocationInfo(1),
            'key': variable,
        },
        'tail': tail === undefined ? [false] : [true, tail]
    };
}
exports.anyValueSelection = anyValueSelection;
function fromVariableSelection(variable, tail) {
    return {
        'start': [true, {
                'annotation': pd.getLocationInfo(1),
                'key': variable,
            }],
        'tail': tail === undefined ? [false] : [true, tail]
    };
}
exports.fromVariableSelection = fromVariableSelection;
function fromContextSelection(tail) {
    return {
        'start': [false],
        'tail': tail === undefined ? [false] : [true, tail]
    };
}
exports.fromContextSelection = fromContextSelection;
// export function tuStep(option: string): g_this.T.No__Context__Value__Selection.tail.A<pd.SourceLocation> {
//     return ['tagged union', {
//         'option': {
//             'annotation': pd.getLocationInfo(1),
//             'key': option
//         }
//     }]
// }
// export function aLookup(
//     lookupSelection: g_this.T.Lookup__Selection<pd.SourceLocation>
// ): g_this.T.Type._ltype.component.content.arguments.dictionary.D<pd.SourceLocation> {
//     return {
//         'annotation': pd.getLocationInfo(1),
//         'content': {
//             'type': ['lookup', {
//                 'annotation': pd.getLocationInfo(1),
//                 'content': lookupSelection
//             }]
//         }
//     }
// }
function aResolvedValue(valueSelection) {
    return {
        'annotation': pd.getLocationInfo(1),
        'content': {
            'type': ['resolved value', valueSelection]
        }
    };
}
exports.aResolvedValue = aResolvedValue;
function component(type, args) {
    return {
        'type': ['component', {
                'type': type,
                'arguments': dict(args),
            }]
    };
}
exports.component = component;
function typeRef(type) {
    return ['resolved sibling', {
            'type': {
                'key': type,
                'annotation': pd.getLocationInfo(1)
            }
        }];
}
exports.typeRef = typeRef;
function imported(library, type) {
    return ['import', {
            'library': ref(library),
            'type': ref(type),
        }];
}
exports.imported = imported;
function pResolvedValue(gt, optional) {
    return {
        'type': ['resolved sibling', {
                'type': ref(gt, 1),
            }],
        'optional': optional
            ? ['yes', null]
            : ['no', null],
    };
}
exports.pResolvedValue = pResolvedValue;
function pExternal(imp, gt, optional) {
    return {
        'type': ['import', {
                'library': {
                    'key': imp,
                    'annotation': pd.getLocationInfo(1),
                },
                'type': ref(gt),
            }],
        'optional': optional
            ? ['yes', null]
            : ['no', null],
    };
}
exports.pExternal = pExternal;
// export function pLookup(
//     type: g_this.T.Global__Type__Selection<pd.SourceLocation>
// ): g_this.T.Parameters.dictionary.D<pd.SourceLocation> {
//     return {
//         'type': ['lookup', {
//             'annotation': pd.getLocationInfo(1),
//             'content': {
//                 //'kind': ['non cyclic', null],
//                 'type': type
//             },
//         }]
//     }
// }
function typeLibrary(imports, atom_types, global_types) {
    return {
        'imports': dict(imports),
        'atom types': dict(atom_types),
        'global types': dict(global_types)
    };
}
exports.typeLibrary = typeLibrary;
