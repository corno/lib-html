import * as pt from 'pareto-core-types';
export declare namespace N {
    namespace Any_$_$Value_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace start {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace tail {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Atom {
        namespace N {
            namespace G {
                namespace N {
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Atom_$_$Types {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Dictionary_$_$Constraints {
        namespace N {
            namespace D {
                namespace N {
                    namespace TU {
                        namespace N {
                            namespace dictionary {
                                namespace N {
                                    namespace G {
                                        namespace N {
                                            namespace dense {
                                                namespace N {
                                                    namespace TU {
                                                        namespace N {
                                                            namespace no {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N { }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                            namespace yes {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N { }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                            namespace dictionary {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Dictionary_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace dictionary {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Global_$_$Type {
        namespace N {
            namespace G {
                namespace N {
                    namespace parameters {
                        namespace N { }
                        namespace T { }
                    }
                    namespace result {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                    namespace variables {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Global_$_$Type_$_$Selection {
        namespace N {
            namespace TU {
                namespace N {
                    namespace _$limport {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace library {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace _$ltype {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace resolved_$_$sibling {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace _$ltype {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Global_$_$Types {
        namespace N {
            namespace D {
                namespace N { }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Imports {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Model {
        namespace N {
            namespace G {
                namespace N {
                    namespace root {
                        namespace N { }
                        namespace T { }
                    }
                    namespace type_$_$library {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace No_$_$Context_$_$Value_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace start {
                        namespace N { }
                        namespace T { }
                    }
                    namespace tail {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Parameters {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N {
                            namespace optional {
                                namespace N {
                                    namespace TU {
                                        namespace N {
                                            namespace no {
                                                namespace N {
                                                    namespace G {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                            namespace yes {
                                                namespace N {
                                                    namespace G {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                            namespace _$ltype {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Property {
        namespace N {
            namespace G {
                namespace N {
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                    namespace variables {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Root {
        namespace N { }
        namespace T { }
    }
    namespace State_$_$Constraints {
        namespace N {
            namespace D {
                namespace N { }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace State_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace state {
                        namespace N { }
                        namespace T { }
                    }
                    namespace state_$_$group {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type {
        namespace N {
            namespace G {
                namespace N {
                    namespace _$ltype {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace array {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace atom {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace atom {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace component {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace arguments {
                                                        namespace N {
                                                            namespace D {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N {
                                                                            namespace _$ltype {
                                                                                namespace N {
                                                                                    namespace TU {
                                                                                        namespace N {
                                                                                            namespace resolved_$_$value {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                        }
                                                                                        namespace T { }
                                                                                    }
                                                                                }
                                                                                namespace T { }
                                                                            }
                                                                        }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace dictionary {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace constraints {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace key {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace variables {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace group {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace properties {
                                                        namespace N {
                                                            namespace D {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace nothing {
                                        namespace N {
                                            namespace G {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace optional {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace constraints {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace variables {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace resolved_$_$reference {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace atom {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace dictionary {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace state_$_$group {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace states {
                                                        namespace N {
                                                            namespace D {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N {
                                                                            namespace constraints {
                                                                                namespace N { }
                                                                                namespace T { }
                                                                            }
                                                                            namespace _$ltype {
                                                                                namespace N { }
                                                                                namespace T { }
                                                                            }
                                                                            namespace variables {
                                                                                namespace N { }
                                                                                namespace T { }
                                                                            }
                                                                        }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Library {
        namespace N {
            namespace G {
                namespace N {
                    namespace atom_$_$types {
                        namespace N { }
                        namespace T { }
                    }
                    namespace global_$_$types {
                        namespace N { }
                        namespace T { }
                    }
                    namespace imports {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Value_$_$Selection_$_$Tail {
        namespace N {
            namespace TU {
                namespace N {
                    namespace component {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace component {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace tail {
                                        namespace N {
                                            namespace O {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace group {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace group {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace property {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace tail {
                                        namespace N {
                                            namespace O {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace reference {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace reference {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace tail {
                                        namespace N {
                                            namespace O {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace state_$_$group {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace result_$_$type {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace state_$_$group {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace states {
                                        namespace N {
                                            namespace D {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Variable {
        namespace N {
            namespace TU {
                namespace N {
                    namespace dictionary_$_$constraint {
                        namespace N { }
                        namespace T { }
                    }
                    namespace parameter {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace parameter {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace parent_$_$variable {
                        namespace N { }
                        namespace T { }
                    }
                    namespace sibling_$_$property {
                        namespace N { }
                        namespace T { }
                    }
                    namespace state_$_$constraint {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Variables {
        namespace N {
            namespace D {
                namespace N { }
                namespace T { }
            }
        }
        namespace T { }
    }
}
export declare namespace T {
    namespace Any__Value__Selection {
        namespace start {
            namespace O {
                type annotation<GAnnotation> = GAnnotation;
                type key<GAnnotation> = string;
            }
            type O<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        }
        type start<GAnnotation> = [false] | [
            true,
            {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            }
        ];
        namespace tail {
            type O<GAnnotation> = T.Value__Selection__Tail<GAnnotation>;
        }
        type tail<GAnnotation> = [false] | [true, T.Value__Selection__Tail<GAnnotation>];
    }
    type Any__Value__Selection<GAnnotation> = {
        readonly 'start': [false] | [
            true,
            {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            }
        ];
        readonly 'tail': [false] | [true, T.Value__Selection__Tail<GAnnotation>];
    };
    namespace Atom {
        namespace _ltype {
            type annotation<GAnnotation> = GAnnotation;
            type key<GAnnotation> = string;
        }
        type _ltype<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
    }
    type Atom<GAnnotation> = {
        readonly 'type': {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
    };
    namespace Atom__Types {
        type annotation<GAnnotation> = GAnnotation;
        namespace dictionary {
            namespace D { }
            type D<GAnnotation> = null;
        }
        type dictionary<GAnnotation> = pt.Dictionary<null>;
    }
    type Atom__Types<GAnnotation> = {
        readonly 'annotation': GAnnotation;
        readonly 'dictionary': pt.Dictionary<null>;
    };
    namespace Dictionary__Constraints {
        type annotation<GAnnotation> = GAnnotation;
        namespace dictionary {
            namespace D {
                namespace dictionary {
                    namespace dense {
                        namespace no { }
                        type no<GAnnotation> = null;
                        namespace yes { }
                        type yes<GAnnotation> = null;
                    }
                    type dense<GAnnotation> = ['no', null] | ['yes', null];
                    type dictionary<GAnnotation> = T.Dictionary__Selection<GAnnotation>;
                }
                type dictionary<GAnnotation> = {
                    readonly 'dense': ['no', null] | ['yes', null];
                    readonly 'dictionary': T.Dictionary__Selection<GAnnotation>;
                };
            }
            type D<GAnnotation> = [
                'dictionary',
                {
                    readonly 'dense': ['no', null] | ['yes', null];
                    readonly 'dictionary': T.Dictionary__Selection<GAnnotation>;
                }
            ];
        }
        type dictionary<GAnnotation> = pt.Dictionary<[
            'dictionary',
            {
                readonly 'dense': ['no', null] | ['yes', null];
                readonly 'dictionary': T.Dictionary__Selection<GAnnotation>;
            }
        ]>;
    }
    type Dictionary__Constraints<GAnnotation> = {
        readonly 'annotation': GAnnotation;
        readonly 'dictionary': pt.Dictionary<[
            'dictionary',
            {
                readonly 'dense': ['no', null] | ['yes', null];
                readonly 'dictionary': T.Dictionary__Selection<GAnnotation>;
            }
        ]>;
    };
    namespace Dictionary__Selection {
        type dictionary<GAnnotation> = GAnnotation;
        type _ltype<GAnnotation> = T.No__Context__Value__Selection<GAnnotation>;
    }
    type Dictionary__Selection<GAnnotation> = {
        readonly 'dictionary': GAnnotation;
        readonly 'type': T.No__Context__Value__Selection<GAnnotation>;
    };
    namespace Global__Type {
        type parameters<GAnnotation> = T.Parameters<GAnnotation>;
        namespace result {
            type O<GAnnotation> = T.Any__Value__Selection<GAnnotation>;
        }
        type result<GAnnotation> = [false] | [true, T.Any__Value__Selection<GAnnotation>];
        type _ltype<GAnnotation> = T.Type<GAnnotation>;
        type variables<GAnnotation> = T.Variables<GAnnotation>;
    }
    type Global__Type<GAnnotation> = {
        readonly 'parameters': T.Parameters<GAnnotation>;
        readonly 'result': [false] | [true, T.Any__Value__Selection<GAnnotation>];
        readonly 'type': T.Type<GAnnotation>;
        readonly 'variables': T.Variables<GAnnotation>;
    };
    namespace Global__Type__Selection {
        namespace _limport {
            namespace library {
                type annotation<GAnnotation> = GAnnotation;
                type key<GAnnotation> = string;
            }
            type library<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
            namespace _ltype {
                type annotation<GAnnotation> = GAnnotation;
                type key<GAnnotation> = string;
            }
            type _ltype<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        }
        type _limport<GAnnotation> = {
            readonly 'library': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
            readonly 'type': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        };
        namespace resolved__sibling {
            namespace _ltype {
                type annotation<GAnnotation> = GAnnotation;
                type key<GAnnotation> = string;
            }
            type _ltype<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        }
        type resolved__sibling<GAnnotation> = {
            readonly 'type': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        };
    }
    type Global__Type__Selection<GAnnotation> = [
        'import',
        {
            readonly 'library': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
            readonly 'type': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        }
    ] | [
        'resolved sibling',
        {
            readonly 'type': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        }
    ];
    namespace Global__Types {
        type annotation<GAnnotation> = GAnnotation;
        namespace dictionary {
            type D<GAnnotation> = T.Global__Type<GAnnotation>;
        }
        type dictionary<GAnnotation> = pt.Dictionary<T.Global__Type<GAnnotation>>;
    }
    type Global__Types<GAnnotation> = {
        readonly 'annotation': GAnnotation;
        readonly 'dictionary': pt.Dictionary<T.Global__Type<GAnnotation>>;
    };
    namespace Imports {
        type annotation<GAnnotation> = GAnnotation;
        namespace dictionary {
            namespace D {
                type annotation<GAnnotation> = GAnnotation;
                namespace content { }
                type content<GAnnotation> = null;
            }
            type D<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'content': null;
            };
        }
        type dictionary<GAnnotation> = pt.Dictionary<{
            readonly 'annotation': GAnnotation;
            readonly 'content': null;
        }>;
    }
    type Imports<GAnnotation> = {
        readonly 'annotation': GAnnotation;
        readonly 'dictionary': pt.Dictionary<{
            readonly 'annotation': GAnnotation;
            readonly 'content': null;
        }>;
    };
    namespace Model {
        namespace root {
            type annotation<GAnnotation> = GAnnotation;
            type key<GAnnotation> = string;
        }
        type root<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        type type__library<GAnnotation> = T.Type__Library<GAnnotation>;
    }
    type Model<GAnnotation> = {
        readonly 'root': {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        readonly 'type library': T.Type__Library<GAnnotation>;
    };
    namespace No__Context__Value__Selection {
        namespace start {
            type annotation<GAnnotation> = GAnnotation;
            type key<GAnnotation> = string;
        }
        type start<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        namespace tail {
            type O<GAnnotation> = T.Value__Selection__Tail<GAnnotation>;
        }
        type tail<GAnnotation> = [false] | [true, T.Value__Selection__Tail<GAnnotation>];
    }
    type No__Context__Value__Selection<GAnnotation> = {
        readonly 'start': {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        readonly 'tail': [false] | [true, T.Value__Selection__Tail<GAnnotation>];
    };
    namespace Parameters {
        type annotation<GAnnotation> = GAnnotation;
        namespace dictionary {
            namespace D {
                namespace optional {
                    namespace no { }
                    type no<GAnnotation> = null;
                    namespace yes { }
                    type yes<GAnnotation> = null;
                }
                type optional<GAnnotation> = ['no', null] | ['yes', null];
                type _ltype<GAnnotation> = T.Global__Type__Selection<GAnnotation>;
            }
            type D<GAnnotation> = {
                readonly 'optional': ['no', null] | ['yes', null];
                readonly 'type': T.Global__Type__Selection<GAnnotation>;
            };
        }
        type dictionary<GAnnotation> = pt.Dictionary<{
            readonly 'optional': ['no', null] | ['yes', null];
            readonly 'type': T.Global__Type__Selection<GAnnotation>;
        }>;
    }
    type Parameters<GAnnotation> = {
        readonly 'annotation': GAnnotation;
        readonly 'dictionary': pt.Dictionary<{
            readonly 'optional': ['no', null] | ['yes', null];
            readonly 'type': T.Global__Type__Selection<GAnnotation>;
        }>;
    };
    namespace Property {
        type _ltype<GAnnotation> = T.Type<GAnnotation>;
        type variables<GAnnotation> = T.Variables<GAnnotation>;
    }
    type Property<GAnnotation> = {
        readonly 'type': T.Type<GAnnotation>;
        readonly 'variables': T.Variables<GAnnotation>;
    };
    type Root<GAnnotation> = T.Model<GAnnotation>;
    namespace State__Constraints {
        type annotation<GAnnotation> = GAnnotation;
        namespace dictionary {
            type D<GAnnotation> = T.State__Selection<GAnnotation>;
        }
        type dictionary<GAnnotation> = pt.Dictionary<T.State__Selection<GAnnotation>>;
    }
    type State__Constraints<GAnnotation> = {
        readonly 'annotation': GAnnotation;
        readonly 'dictionary': pt.Dictionary<T.State__Selection<GAnnotation>>;
    };
    namespace State__Selection {
        namespace state {
            type annotation<GAnnotation> = GAnnotation;
            type key<GAnnotation> = string;
        }
        type state<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        type state__group<GAnnotation> = GAnnotation;
        type _ltype<GAnnotation> = T.No__Context__Value__Selection<GAnnotation>;
    }
    type State__Selection<GAnnotation> = {
        readonly 'state': {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        readonly 'state group': GAnnotation;
        readonly 'type': T.No__Context__Value__Selection<GAnnotation>;
    };
    namespace Type {
        namespace _ltype {
            namespace array {
                type _ltype<GAnnotation> = T.Type<GAnnotation>;
            }
            type array<GAnnotation> = {
                readonly 'type': T.Type<GAnnotation>;
            };
            namespace atom {
                type atom<GAnnotation> = T.Atom<GAnnotation>;
            }
            type atom<GAnnotation> = {
                readonly 'atom': T.Atom<GAnnotation>;
            };
            namespace component {
                namespace arguments {
                    type annotation<GAnnotation> = GAnnotation;
                    namespace dictionary {
                        namespace D {
                            type annotation<GAnnotation> = GAnnotation;
                            namespace content {
                                namespace _ltype {
                                    type resolved__value<GAnnotation> = T.No__Context__Value__Selection<GAnnotation>;
                                }
                                type _ltype<GAnnotation> = ['resolved value', T.No__Context__Value__Selection<GAnnotation>];
                            }
                            type content<GAnnotation> = {
                                readonly 'type': ['resolved value', T.No__Context__Value__Selection<GAnnotation>];
                            };
                        }
                        type D<GAnnotation> = {
                            readonly 'annotation': GAnnotation;
                            readonly 'content': {
                                readonly 'type': ['resolved value', T.No__Context__Value__Selection<GAnnotation>];
                            };
                        };
                    }
                    type dictionary<GAnnotation> = pt.Dictionary<{
                        readonly 'annotation': GAnnotation;
                        readonly 'content': {
                            readonly 'type': ['resolved value', T.No__Context__Value__Selection<GAnnotation>];
                        };
                    }>;
                }
                type arguments<GAnnotation> = {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<{
                        readonly 'annotation': GAnnotation;
                        readonly 'content': {
                            readonly 'type': ['resolved value', T.No__Context__Value__Selection<GAnnotation>];
                        };
                    }>;
                };
                type _ltype<GAnnotation> = T.Global__Type__Selection<GAnnotation>;
            }
            type component<GAnnotation> = {
                readonly 'arguments': {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<{
                        readonly 'annotation': GAnnotation;
                        readonly 'content': {
                            readonly 'type': ['resolved value', T.No__Context__Value__Selection<GAnnotation>];
                        };
                    }>;
                };
                readonly 'type': T.Global__Type__Selection<GAnnotation>;
            };
            namespace dictionary {
                type constraints<GAnnotation> = T.Dictionary__Constraints<GAnnotation>;
                type key<GAnnotation> = T.Atom<GAnnotation>;
                type _ltype<GAnnotation> = T.Type<GAnnotation>;
                type variables<GAnnotation> = T.Variables<GAnnotation>;
            }
            type dictionary<GAnnotation> = {
                readonly 'constraints': T.Dictionary__Constraints<GAnnotation>;
                readonly 'key': T.Atom<GAnnotation>;
                readonly 'type': T.Type<GAnnotation>;
                readonly 'variables': T.Variables<GAnnotation>;
            };
            namespace group {
                namespace properties {
                    type annotation<GAnnotation> = GAnnotation;
                    namespace dictionary {
                        type D<GAnnotation> = T.Property<GAnnotation>;
                    }
                    type dictionary<GAnnotation> = pt.Dictionary<T.Property<GAnnotation>>;
                }
                type properties<GAnnotation> = {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<T.Property<GAnnotation>>;
                };
            }
            type group<GAnnotation> = {
                readonly 'properties': {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<T.Property<GAnnotation>>;
                };
            };
            namespace nothing { }
            type nothing<GAnnotation> = null;
            namespace optional {
                type constraints<GAnnotation> = T.State__Constraints<GAnnotation>;
                type _ltype<GAnnotation> = T.Type<GAnnotation>;
                type variables<GAnnotation> = T.Variables<GAnnotation>;
            }
            type optional<GAnnotation> = {
                readonly 'constraints': T.State__Constraints<GAnnotation>;
                readonly 'type': T.Type<GAnnotation>;
                readonly 'variables': T.Variables<GAnnotation>;
            };
            namespace resolved__reference {
                type atom<GAnnotation> = T.Atom<GAnnotation>;
                type dictionary<GAnnotation> = T.Dictionary__Selection<GAnnotation>;
            }
            type resolved__reference<GAnnotation> = {
                readonly 'atom': T.Atom<GAnnotation>;
                readonly 'dictionary': T.Dictionary__Selection<GAnnotation>;
            };
            namespace state__group {
                namespace states {
                    type annotation<GAnnotation> = GAnnotation;
                    namespace dictionary {
                        namespace D {
                            type constraints<GAnnotation> = T.State__Constraints<GAnnotation>;
                            type _ltype<GAnnotation> = T.Type<GAnnotation>;
                            type variables<GAnnotation> = T.Variables<GAnnotation>;
                        }
                        type D<GAnnotation> = {
                            readonly 'constraints': T.State__Constraints<GAnnotation>;
                            readonly 'type': T.Type<GAnnotation>;
                            readonly 'variables': T.Variables<GAnnotation>;
                        };
                    }
                    type dictionary<GAnnotation> = pt.Dictionary<{
                        readonly 'constraints': T.State__Constraints<GAnnotation>;
                        readonly 'type': T.Type<GAnnotation>;
                        readonly 'variables': T.Variables<GAnnotation>;
                    }>;
                }
                type states<GAnnotation> = {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<{
                        readonly 'constraints': T.State__Constraints<GAnnotation>;
                        readonly 'type': T.Type<GAnnotation>;
                        readonly 'variables': T.Variables<GAnnotation>;
                    }>;
                };
            }
            type state__group<GAnnotation> = {
                readonly 'states': {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<{
                        readonly 'constraints': T.State__Constraints<GAnnotation>;
                        readonly 'type': T.Type<GAnnotation>;
                        readonly 'variables': T.Variables<GAnnotation>;
                    }>;
                };
            };
        }
        type _ltype<GAnnotation> = [
            'array',
            {
                readonly 'type': T.Type<GAnnotation>;
            }
        ] | [
            'atom',
            {
                readonly 'atom': T.Atom<GAnnotation>;
            }
        ] | [
            'component',
            {
                readonly 'arguments': {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<{
                        readonly 'annotation': GAnnotation;
                        readonly 'content': {
                            readonly 'type': ['resolved value', T.No__Context__Value__Selection<GAnnotation>];
                        };
                    }>;
                };
                readonly 'type': T.Global__Type__Selection<GAnnotation>;
            }
        ] | [
            'dictionary',
            {
                readonly 'constraints': T.Dictionary__Constraints<GAnnotation>;
                readonly 'key': T.Atom<GAnnotation>;
                readonly 'type': T.Type<GAnnotation>;
                readonly 'variables': T.Variables<GAnnotation>;
            }
        ] | [
            'group',
            {
                readonly 'properties': {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<T.Property<GAnnotation>>;
                };
            }
        ] | ['nothing', null] | [
            'optional',
            {
                readonly 'constraints': T.State__Constraints<GAnnotation>;
                readonly 'type': T.Type<GAnnotation>;
                readonly 'variables': T.Variables<GAnnotation>;
            }
        ] | [
            'resolved reference',
            {
                readonly 'atom': T.Atom<GAnnotation>;
                readonly 'dictionary': T.Dictionary__Selection<GAnnotation>;
            }
        ] | [
            'state group',
            {
                readonly 'states': {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<{
                        readonly 'constraints': T.State__Constraints<GAnnotation>;
                        readonly 'type': T.Type<GAnnotation>;
                        readonly 'variables': T.Variables<GAnnotation>;
                    }>;
                };
            }
        ];
    }
    type Type<GAnnotation> = {
        readonly 'type': [
            'array',
            {
                readonly 'type': T.Type<GAnnotation>;
            }
        ] | [
            'atom',
            {
                readonly 'atom': T.Atom<GAnnotation>;
            }
        ] | [
            'component',
            {
                readonly 'arguments': {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<{
                        readonly 'annotation': GAnnotation;
                        readonly 'content': {
                            readonly 'type': ['resolved value', T.No__Context__Value__Selection<GAnnotation>];
                        };
                    }>;
                };
                readonly 'type': T.Global__Type__Selection<GAnnotation>;
            }
        ] | [
            'dictionary',
            {
                readonly 'constraints': T.Dictionary__Constraints<GAnnotation>;
                readonly 'key': T.Atom<GAnnotation>;
                readonly 'type': T.Type<GAnnotation>;
                readonly 'variables': T.Variables<GAnnotation>;
            }
        ] | [
            'group',
            {
                readonly 'properties': {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<T.Property<GAnnotation>>;
                };
            }
        ] | ['nothing', null] | [
            'optional',
            {
                readonly 'constraints': T.State__Constraints<GAnnotation>;
                readonly 'type': T.Type<GAnnotation>;
                readonly 'variables': T.Variables<GAnnotation>;
            }
        ] | [
            'resolved reference',
            {
                readonly 'atom': T.Atom<GAnnotation>;
                readonly 'dictionary': T.Dictionary__Selection<GAnnotation>;
            }
        ] | [
            'state group',
            {
                readonly 'states': {
                    readonly 'annotation': GAnnotation;
                    readonly 'dictionary': pt.Dictionary<{
                        readonly 'constraints': T.State__Constraints<GAnnotation>;
                        readonly 'type': T.Type<GAnnotation>;
                        readonly 'variables': T.Variables<GAnnotation>;
                    }>;
                };
            }
        ];
    };
    namespace Type__Library {
        type atom__types<GAnnotation> = T.Atom__Types<GAnnotation>;
        type global__types<GAnnotation> = T.Global__Types<GAnnotation>;
        type imports<GAnnotation> = T.Imports<GAnnotation>;
    }
    type Type__Library<GAnnotation> = {
        readonly 'atom types': T.Atom__Types<GAnnotation>;
        readonly 'global types': T.Global__Types<GAnnotation>;
        readonly 'imports': T.Imports<GAnnotation>;
    };
    namespace Value__Selection__Tail {
        namespace component {
            type component<GAnnotation> = GAnnotation;
            namespace tail {
                type O<GAnnotation> = T.Value__Selection__Tail<GAnnotation>;
            }
            type tail<GAnnotation> = [false] | [true, T.Value__Selection__Tail<GAnnotation>];
        }
        type component<GAnnotation> = {
            readonly 'component': GAnnotation;
            readonly 'tail': [false] | [true, T.Value__Selection__Tail<GAnnotation>];
        };
        namespace group {
            type group<GAnnotation> = GAnnotation;
            namespace property {
                type annotation<GAnnotation> = GAnnotation;
                type key<GAnnotation> = string;
            }
            type property<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
            namespace tail {
                type O<GAnnotation> = T.Value__Selection__Tail<GAnnotation>;
            }
            type tail<GAnnotation> = [false] | [true, T.Value__Selection__Tail<GAnnotation>];
        }
        type group<GAnnotation> = {
            readonly 'group': GAnnotation;
            readonly 'property': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
            readonly 'tail': [false] | [true, T.Value__Selection__Tail<GAnnotation>];
        };
        namespace reference {
            type reference<GAnnotation> = GAnnotation;
            namespace tail {
                type O<GAnnotation> = T.Value__Selection__Tail<GAnnotation>;
            }
            type tail<GAnnotation> = [false] | [true, T.Value__Selection__Tail<GAnnotation>];
        }
        type reference<GAnnotation> = {
            readonly 'reference': GAnnotation;
            readonly 'tail': [false] | [true, T.Value__Selection__Tail<GAnnotation>];
        };
        namespace state__group {
            type result__type<GAnnotation> = T.Global__Type__Selection<GAnnotation>;
            type state__group<GAnnotation> = GAnnotation;
            namespace states {
                type annotation<GAnnotation> = GAnnotation;
                namespace dictionary {
                    namespace D {
                        type annotation<GAnnotation> = GAnnotation;
                        type content<GAnnotation> = T.Any__Value__Selection<GAnnotation>;
                    }
                    type D<GAnnotation> = {
                        readonly 'annotation': GAnnotation;
                        readonly 'content': T.Any__Value__Selection<GAnnotation>;
                    };
                }
                type dictionary<GAnnotation> = pt.Dictionary<{
                    readonly 'annotation': GAnnotation;
                    readonly 'content': T.Any__Value__Selection<GAnnotation>;
                }>;
            }
            type states<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'dictionary': pt.Dictionary<{
                    readonly 'annotation': GAnnotation;
                    readonly 'content': T.Any__Value__Selection<GAnnotation>;
                }>;
            };
        }
        type state__group<GAnnotation> = {
            readonly 'result type': T.Global__Type__Selection<GAnnotation>;
            readonly 'state group': GAnnotation;
            readonly 'states': {
                readonly 'annotation': GAnnotation;
                readonly 'dictionary': pt.Dictionary<{
                    readonly 'annotation': GAnnotation;
                    readonly 'content': T.Any__Value__Selection<GAnnotation>;
                }>;
            };
        };
    }
    type Value__Selection__Tail<GAnnotation> = [
        'component',
        {
            readonly 'component': GAnnotation;
            readonly 'tail': [false] | [true, T.Value__Selection__Tail<GAnnotation>];
        }
    ] | [
        'group',
        {
            readonly 'group': GAnnotation;
            readonly 'property': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
            readonly 'tail': [false] | [true, T.Value__Selection__Tail<GAnnotation>];
        }
    ] | [
        'reference',
        {
            readonly 'reference': GAnnotation;
            readonly 'tail': [false] | [true, T.Value__Selection__Tail<GAnnotation>];
        }
    ] | [
        'state group',
        {
            readonly 'result type': T.Global__Type__Selection<GAnnotation>;
            readonly 'state group': GAnnotation;
            readonly 'states': {
                readonly 'annotation': GAnnotation;
                readonly 'dictionary': pt.Dictionary<{
                    readonly 'annotation': GAnnotation;
                    readonly 'content': T.Any__Value__Selection<GAnnotation>;
                }>;
            };
        }
    ];
    namespace Variable {
        namespace dictionary__constraint {
            type annotation<GAnnotation> = GAnnotation;
            type key<GAnnotation> = string;
        }
        type dictionary__constraint<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        namespace parameter {
            namespace parameter {
                type annotation<GAnnotation> = GAnnotation;
                type key<GAnnotation> = string;
            }
            type parameter<GAnnotation> = {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        }
        type parameter<GAnnotation> = {
            readonly 'parameter': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        };
        namespace parent__variable {
            type annotation<GAnnotation> = GAnnotation;
            type key<GAnnotation> = string;
        }
        type parent__variable<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        namespace sibling__property {
            type annotation<GAnnotation> = GAnnotation;
            type key<GAnnotation> = string;
        }
        type sibling__property<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
        namespace state__constraint {
            type annotation<GAnnotation> = GAnnotation;
            type key<GAnnotation> = string;
        }
        type state__constraint<GAnnotation> = {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        };
    }
    type Variable<GAnnotation> = [
        'dictionary constraint',
        {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        }
    ] | [
        'parameter',
        {
            readonly 'parameter': {
                readonly 'annotation': GAnnotation;
                readonly 'key': string;
            };
        }
    ] | [
        'parent variable',
        {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        }
    ] | [
        'sibling property',
        {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        }
    ] | [
        'state constraint',
        {
            readonly 'annotation': GAnnotation;
            readonly 'key': string;
        }
    ];
    namespace Variables {
        type annotation<GAnnotation> = GAnnotation;
        namespace dictionary {
            type D<GAnnotation> = T.Variable<GAnnotation>;
        }
        type dictionary<GAnnotation> = pt.Dictionary<T.Variable<GAnnotation>>;
    }
    type Variables<GAnnotation> = {
        readonly 'annotation': GAnnotation;
        readonly 'dictionary': pt.Dictionary<T.Variable<GAnnotation>>;
    };
}
