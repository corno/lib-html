"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$$ = void 0;
const pl = __importStar(require("pareto-core-lib"));
const pm = __importStar(require("pareto-core-map"));
const select_s_f_1 = require("./select.s.f");
function mapOptional($, a) {
    return pl.optional($, ($) => {
        const out = a($);
        return [true, out];
    }, () => [false]);
}
const $$ = ($d, $se) => {
    function getEntryForConstrainedDictionaryEntry($, key, annotation) {
        return $.__getEntry(key, ($) => $, () => {
            // let keys = ""
            // $.__forEach(() => false, ($, key) => {
            //     keys += `${key}, `
            // })
            //pl.panic(`No Such Entry: ${key} (${keys})`)
            $se.onError({
                'annotation': annotation,
                'message': ['no such entry', {
                        'key': key
                    }]
            });
            return pl.panic(`No Such Entry: ${key}`);
        });
    }
    function getAnnotatedEntry($, key) {
        return $.__getEntry(key.key, ($) => {
            return {
                'key': key.key,
                'referent': $
            };
        }, () => {
            // let keys = ""
            // $.__forEach(() => false, ($, key) => {
            //     keys += `${key}, `
            // })
            // pd.logDebugMessage(`entries: ${keys}`)
            $se.onError({
                'annotation': key.annotation,
                'message': ['no such entry', {
                        'key': key.key
                    }]
            });
            return pl.panic(`No Such Entry: ${key.key}`);
        });
    }
    function getAnnotatedLookupEntry($, key) {
        return $.__getEntry(key.key, ($) => {
            return {
                'key': key.key,
                'referent': $
            };
        }, () => {
            // let keys = ""
            // $.__forEach(() => false, ($, key) => {
            //     keys += `${key}, `
            // })
            //pl.panic(`No Such Entry: ${key} (${keys})`)
            $se.onError({
                'annotation': key.annotation,
                'message': ['no such entry', {
                        'key': key.key
                    }]
            });
            return pl.panic(`No Such Entry: ${key.key}`);
        });
    }
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    const resolve_Atom = ($, $p) => ({
        'type': getAnnotatedEntry($p['atom types'], $.type)
    });
    const resolve_Model = ($, $p) => {
        const tl = resolve_Type__Library($['type library'], $p);
        return {
            'type library': tl,
            'root': getAnnotatedEntry(tl['global types'], $.root)
        };
    };
    const resolve_Variables = ($, $p) => {
        return $d.mergeAndIgnore({
            'primary': $.dictionary.__mapWithKey(($, key) => pl.cc($, ($) => {
                switch ($[0]) {
                    case 'dictionary constraint': return pl.ss($, ($) => {
                        const x$ = $;
                        return ['dictionary constraint', pl.optional($p['dictionary constraints'], ($) => getAnnotatedEntry($, x$), () => {
                                return pl.panic(`no dictionary constraints`);
                            })];
                    });
                    case 'parameter': return pl.ss($, ($) => {
                        const x$ = $;
                        return ['parameter', {
                                'parameter': pl.optional($p['parameters'], ($) => getAnnotatedEntry($, x$.parameter), () => {
                                    return pl.panic(`no parameters`);
                                })
                            }];
                    });
                    case 'parent variable': return pl.ss($, ($) => {
                        const x$ = $;
                        return ['parent variable', pl.optional($p['parent variables'], ($) => getAnnotatedEntry($, x$), () => {
                                return pl.panic(`no parent variables`);
                            })];
                    });
                    case 'sibling property': return pl.ss($, ($) => {
                        const x$ = $;
                        return ['sibling property', pl.optional($p['sibling properties'], ($) => getAnnotatedLookupEntry($, x$), () => {
                                return pl.panic(`no siblings`);
                            })];
                    });
                    case 'state constraint': return pl.ss($, ($) => {
                        const x$ = $;
                        return ['state constraint', pl.optional($p['state constraints'], ($) => getAnnotatedEntry($, x$), () => {
                                return pl.panic(`no state constraints`);
                            })];
                    });
                    default: return pl.au($[0]);
                }
            })),
            'secondary': $d.mergeAndIgnore({
                'primary': pl.optional($p['parent variables'], ($) => {
                    return $.__mapWithKey(($, key) => {
                        return ['parent variable', {
                                'key': key,
                                'referent': $
                            }];
                    });
                }, () => pm.wrapRawDictionary({})),
                'secondary': $d.mergeAndIgnore({
                    'primary': pl.optional($p['parameters'], ($) => {
                        return $.__mapWithKey(($, key) => {
                            return ['parameter', {
                                    'parameter': {
                                        'key': key,
                                        'referent': $
                                    }
                                }];
                        });
                    }, () => pm.wrapRawDictionary({})),
                    'secondary': $d.mergeAndIgnore({
                        'primary': pl.optional($p['dictionary constraints'], ($) => {
                            return $.__mapWithKey(($, key) => {
                                return ['dictionary constraint', {
                                        'key': key,
                                        'referent': $
                                    }];
                            });
                        }, () => pm.wrapRawDictionary({})),
                        'secondary': $d.mergeAndIgnore({
                            'primary': pl.optional($p['state constraints'], ($) => {
                                return $.__mapWithKey(($, key) => {
                                    return ['state constraint', {
                                            'key': key,
                                            'referent': $
                                        }];
                                });
                            }, () => pm.wrapRawDictionary({})),
                            'secondary': pm.wrapRawDictionary({})
                        })
                    })
                })
            })
        });
    };
    const resolve_Type = ($, $p) => {
        return {
            'type': pl.cc($.type, ($) => {
                switch ($[0]) {
                    case 'array': return pl.ss($, ($) => ['array', {
                            'type': resolve_Type($.type, {
                                'atom types': $p['atom types'],
                                'imports': $p.imports,
                                'sibling global types': $p['sibling global types'],
                                'variables': $p.variables,
                            })
                        }]);
                    case 'component': return pl.ss($, ($) => {
                        const v_type = resolve_Global__Type__Selection($.type, $p);
                        return ['component', {
                                'type': v_type,
                                'arguments': $.arguments.dictionary.__mapWithKey(($, key) => pl.cc($, ($) => {
                                    return {
                                        'constraints': {
                                            'parameter': getEntryForConstrainedDictionaryEntry(select_s_f_1.select.Global__Type__Selection(v_type).parameters, key, $.annotation)
                                        },
                                        'content': {
                                            'type': pl.cc($.content.type, ($) => {
                                                switch ($[0]) {
                                                    // case 'lookup': return pl.ss($, ($): g_out.T.Type._ltype.component.arguments.D.content._ltype => {
                                                    //     return ['lookup', resolve_Lookup__Selection($.content, {
                                                    //         'parameters': $p.parameters,
                                                    //         'current dictionary': $p['current dictionary']
                                                    //     })]
                                                    // })
                                                    case 'resolved value': return pl.ss($, ($) => ['resolved value', resolve_Value__Selection($, {
                                                            'imports': $p.imports,
                                                            'sibling global types': $p['sibling global types'],
                                                            'variables': $p.variables,
                                                        })]);
                                                    default: return pl.au($[0]);
                                                }
                                            })
                                        }
                                    };
                                })),
                            }];
                    });
                    case 'dictionary': return pl.ss($, ($) => {
                        const v_constraints = $.constraints.dictionary.map(($) => pl.cc($, ($) => {
                            switch ($[0]) {
                                // case 'lookup': return pl.ss($, ($) => {
                                //     const v_gts = resolve_Lookup__Selection($.content, $p)
                                //     return ['lookup', v_gts]
                                // })
                                case 'dictionary': return pl.ss($, ($) => {
                                    return ['dictionary', {
                                            'dictionary': resolve_Dictionary__Selection($.dictionary, $p),
                                            'dense': pl.cc($.dense, ($) => {
                                                switch ($[0]) {
                                                    case 'no': return pl.ss($, ($) => ['no', null]);
                                                    case 'yes': return pl.ss($, ($) => ['yes', null]);
                                                    default: return pl.au($[0]);
                                                }
                                            }),
                                        }];
                                });
                                default: return pl.au($[0]);
                            }
                        }));
                        const v_variables = resolve_Variables($.variables, {
                            'dictionary constraints': [true, v_constraints],
                            'parameters': [false],
                            'sibling properties': [false],
                            'state constraints': [false],
                            'parent variables': [true, $p.variables],
                        });
                        return ['dictionary', {
                                'constraints': v_constraints,
                                'variables': v_variables,
                                'key': resolve_Atom($.key, { 'atom types': $p['atom types'] }),
                                'type': resolve_Type($.type, {
                                    'atom types': $p['atom types'],
                                    'imports': $p.imports,
                                    'sibling global types': $p['sibling global types'],
                                    'variables': v_variables,
                                })
                            }];
                    });
                    case 'group': return pl.ss($, ($) => {
                        return ['group', {
                                'properties': $d.resolveDictionary($.properties.dictionary, {
                                    'map': (($, $l) => {
                                        const v_variables = resolve_Variables($.value.variables, {
                                            'dictionary constraints': [false],
                                            'parameters': [false],
                                            'sibling properties': [true, $l['non circular siblings']],
                                            'state constraints': [false],
                                            'parent variables': [true, $p.variables],
                                        });
                                        return {
                                            'variables': v_variables,
                                            'type': resolve_Type($.value.type, {
                                                'atom types': $p['atom types'],
                                                'imports': $p.imports,
                                                'sibling global types': $p['sibling global types'],
                                                'variables': v_variables,
                                            })
                                        };
                                    })
                                })
                            }];
                    });
                    case 'nothing': return pl.ss($, ($) => ['nothing', null]);
                    case 'optional': return pl.ss($, ($) => {
                        const v_constraints = $.constraints.dictionary.map(($) => resolve_State__Selection($, $p));
                        const v_variables = resolve_Variables($.variables, {
                            'dictionary constraints': [false],
                            'parameters': [false],
                            'sibling properties': [false],
                            'state constraints': [true, v_constraints],
                            'parent variables': [true, $p.variables],
                        });
                        return ['optional', {
                                'constraints': v_constraints,
                                'variables': v_variables,
                                'type': resolve_Type($.type, {
                                    'atom types': $p['atom types'],
                                    'imports': $p.imports,
                                    'sibling global types': $p['sibling global types'],
                                    'variables': v_variables,
                                }),
                            }];
                    });
                    case 'state group': return pl.ss($, ($) => {
                        return ['state group', {
                                'states': $d.resolveDictionary($.states.dictionary, {
                                    'map': ($, $l) => {
                                        const v_constraints = $.value.constraints.dictionary.map(($) => resolve_State__Selection($, $p));
                                        const v_variables = resolve_Variables($.value.variables, {
                                            'dictionary constraints': [false],
                                            'parameters': [false],
                                            'sibling properties': [false],
                                            'state constraints': [true, v_constraints],
                                            'parent variables': [true, $p.variables],
                                        });
                                        return {
                                            'constraints': v_constraints,
                                            'variables': v_variables,
                                            'type': resolve_Type($.value.type, {
                                                'atom types': $p['atom types'],
                                                'imports': $p.imports,
                                                'sibling global types': $p['sibling global types'],
                                                'variables': v_variables,
                                            }),
                                        };
                                    }
                                }),
                            }];
                    });
                    // case 'cyclic reference': return pl.ss($, ($) => {
                    //     return ['cyclic reference', {
                    //         'atom': resolve_Atom($.atom, { 'atom types': $p['atom types'] }),
                    //         'sibling': resolve_Global__Type__Selection($.sibling, $p)
                    //     }]
                    // })
                    case 'resolved reference': return pl.ss($, ($) => {
                        return ['resolved reference', {
                                'atom': resolve_Atom($.atom, { 'atom types': $p['atom types'] }),
                                'dictionary': resolve_Dictionary__Selection($.dictionary, $p)
                            }];
                    });
                    case 'atom': return pl.ss($, ($) => {
                        return ['atom', {
                                'atom': resolve_Atom($.atom, { 'atom types': $p['atom types'] }),
                            }];
                    });
                    default: return pl.au($[0]);
                }
            })
        };
    };
    // const resolve_Lookup__Selection: Resolve.Lookup__Selection<Annotation> = ($, $p) => {
    //     switch ($[0]) {
    //         // case 'cyclic sibling': return pl.ss($, ($) => {
    //         //     const v_type = getAnnotatedEntry($p['cyclic sibling global types'], $.type)
    //         //     return ['cyclic sibling', {
    //         //         'type': v_type,//FIX ME; don't call
    //         //     }]
    //         // })
    //         case 'parameter': return pl.ss($, ($): g_out.T.Lookup__Selection => {
    //             const v_parameter = getAnnotatedEntry($p.parameters, $.content.parameter).referent
    //             const c_lookup = pl.cc(v_parameter.type, ($) => {
    //                 if ($[0] !== 'lookup') {
    //                     // $se.onError({
    //                     //     'annotation': x.annotation,
    //                     //     'message': ['not the right state', {
    //                     //         'found': $.type[0],
    //                     //         'expected': `state group`
    //                     //     }]
    //                     // })
    //                     return pl.panic(`not a lookup`)
    //                 }
    //                 return $[1]
    //             })
    //             return ['parameter', {
    //                 'parameter': {
    //                     'key': $.content.parameter.key,
    //                     'referent': v_parameter
    //                 },
    //                 'lookup': c_lookup
    //             }]
    //         })
    //         case 'this': return pl.ss($, ($) => {
    //             return ['this', null]
    //         })
    //         case 'resolved dictionary': return pl.ss($, ($) => {
    //             const v_type = getAnnotatedEntry($p['sibling global types'], $.content)
    //             return ['resolved dictionary', {
    //                 'type': v_type,
    //             }]
    //         })
    //         default: return pl.au($[0])
    //     }
    // }
    const resolve_Global__Type__Selection = ($, $p) => {
        switch ($[0]) {
            // case 'cyclic sibling': return pl.ss($, ($) => {
            //     const v_type = getAnnotatedEntry($p['cyclic sibling global types'], $.type)
            //     return ['cyclic sibling', {
            //         'type': v_type,//FIX ME; don't call
            //     }]
            // })
            case 'import': return pl.ss($, ($) => {
                const v_library = getAnnotatedEntry($p.imports, $.library);
                const v_type = getAnnotatedEntry(v_library.referent.constraints.library['global types'], $.type);
                return ['import', {
                        'library': v_library,
                        'type': v_type,
                    }];
            });
            case 'resolved sibling': return pl.ss($, ($) => {
                const v_type = getAnnotatedLookupEntry($p['sibling global types'], $.type);
                return ['resolved sibling', {
                        'type': v_type,
                    }];
            });
            default: return pl.au($[0]);
        }
    };
    const resolve_State__Selection = ($, $p) => {
        const v_type = resolve_Value__Selection($.type, $p);
        const $x = $['state group'];
        const c_tagged_union = pl.cc(select_s_f_1.select.No__Context__Value__Selection(v_type), ($) => {
            if ($.type[0] !== 'state group') {
                $se.onError({
                    'annotation': $x,
                    'message': ['not the right state', {
                            'found': $.type[0],
                            'expected': `state group`
                        }]
                });
                return pl.panic(`not a dictionary`);
            }
            return $.type[1];
        });
        const v_state = getAnnotatedEntry(c_tagged_union.states, $.state);
        return {
            'type': v_type,
            'state group': c_tagged_union,
            'state': v_state,
        };
    };
    const resolve_Value__Selection = ($, $p) => {
        const v_start = getAnnotatedEntry($p.variables, $.start);
        const v_tail = mapOptional($.tail, ($) => resolve_Value__Selection__Tail($, {
            'variables': $p.variables,
            'context': select_s_f_1.select.Variable(v_start.referent),
            'imports': $p.imports,
            'sibling global types': $p['sibling global types']
        }));
        return {
            'start': v_start,
            'tail': v_tail,
        };
    };
    const resolve_Any__Value__Selection = ($, $p) => {
        const v_start = mapOptional($.start, ($) => getAnnotatedEntry($p.variables, $));
        const v_tail = mapOptional($.tail, ($) => resolve_Value__Selection__Tail($, {
            'variables': $p.variables,
            'context': pl.optional(v_start, ($) => select_s_f_1.select.Variable($.referent), () => $p.context),
            'imports': $p.imports,
            'sibling global types': $p['sibling global types']
        }));
        return {
            'start': v_start,
            'tail': v_tail,
        };
    };
    const resolve_Dictionary__Selection = ($, $p) => {
        const v_type = resolve_Value__Selection($.type, {
            'imports': $p.imports,
            'sibling global types': $p['sibling global types'],
            'variables': $p.variables,
        });
        const $ann = $.dictionary;
        return {
            'type': v_type,
            'dictionary': pl.cc(select_s_f_1.select.No__Context__Value__Selection(v_type), ($) => {
                if ($.type[0] !== 'dictionary') {
                    $se.onError({
                        'annotation': $ann,
                        'message': ['not the right state', {
                                'found': $.type[0],
                                'expected': `dictionary`
                            }]
                    });
                    pl.panic(`not a dictionary`);
                }
                return $.type[1];
            })
        };
    };
    const resolve_Value__Selection__Tail = ($, $p) => {
        switch ($[0]) {
            case 'component': return pl.ss($, ($) => {
                const $ann = $.component;
                const v_component = pl.cc($p.context.type, ($) => {
                    if ($[0] !== 'component') {
                        $se.onError({
                            'annotation': $ann,
                            'message': ['not the right state', {
                                    'found': $[0],
                                    'expected': `component`
                                }]
                        });
                        pl.panic(`not a component`);
                    }
                    return $[1];
                });
                const v_tail = mapOptional($.tail, ($) => {
                    return resolve_Value__Selection__Tail($, {
                        'variables': select_s_f_1.select.Global__Type__Selection(v_component.type).variables,
                        'context': select_s_f_1.select.Global__Type__Selection(v_component.type).type,
                        'imports': $p.imports,
                        'sibling global types': $p['sibling global types'],
                    });
                });
                return ['component', {
                        'component': v_component,
                        'tail': v_tail,
                    }];
            });
            case 'group': return pl.ss($, ($) => {
                const $ann = $.group;
                const v_group = pl.cc($p.context.type, ($) => {
                    if ($[0] !== 'group') {
                        $se.onError({
                            'annotation': $ann,
                            'message': ['not the right state', {
                                    'found': $[0],
                                    'expected': `group`
                                }]
                        });
                        pl.panic(`not a group`);
                    }
                    return $[1];
                });
                const v_property = getAnnotatedEntry(v_group.properties, $.property);
                const v_tail = mapOptional($.tail, ($) => {
                    return resolve_Value__Selection__Tail($, {
                        'variables': v_property.referent.variables,
                        'context': v_property.referent.type,
                        'imports': $p.imports,
                        'sibling global types': $p['sibling global types'],
                    });
                });
                return ['group', {
                        'group': v_group,
                        'property': v_property,
                        'tail': v_tail,
                    }];
            });
            // case 'nothing': return pl.ss($, ($) => {
            //     const x = $
            //     const v_nothing = pl.cc($p.context.type, ($) => {
            //         if ($[0] !== 'nothing') {
            //             $se.onError({
            //                 'annotation': x.annotation,
            //                 'message': ['not the right state', {
            //                     'found': $[0],
            //                     'expected': `nothing`
            //                 }]
            //             })
            //             pl.panic(`not a nothing type`)
            //         }
            //         return $[1]
            //     })
            //     return {
            //         'content': ['nothing', {
            //             'constraints': {
            //                 'nothing': v_nothing,
            //             },
            //             'content': null,
            //         }],
            //         'result': v_nothing.type,
            //     }
            // })
            // case 'optional': return pl.ss($, ($) => {
            //     const v_optional = pl.cc($p.context.type, ($) => {
            //         if ($[0] !== 'optional') {
            //             // $se.onError({
            //             //     'annotation': x.annotation,
            //             //     'message': ['not the right state', {
            //             //         'found': $[0],
            //             //         'expected': `optional`
            //             //     }]
            //             // })
            //             pl.panic(`not an optional`)
            //         }
            //         return $[1]
            //     })
            //     const v_set = resolve_Any__Value__Selection($.content.set, {
            //         'context': v_optional.type,
            //         'imports': $p.imports,
            //         'sibling global types': $p['sibling global types'],
            //         'variables': $p.variables,
            //     })
            //     const v_not_set = resolve_Value__Selection($.content['not set'], {
            //         'imports': $p.imports,
            //         'sibling global types': $p['sibling global types'],
            //         'variables': xnotset,
            //     })
            //     return ['optional', {
            //         'optional': v_optional,
            //         'set': v_set,
            //         'not set': v_not_set
            //     }]
            // })
            case 'reference': return pl.ss($, ($) => {
                const $ann = $.reference;
                const v_reference = pl.cc($p.context.type, ($) => {
                    if ($[0] !== 'resolved reference') {
                        $se.onError({
                            'annotation': $ann,
                            'message': ['not the right state', {
                                    'found': $[0],
                                    'expected': `ref`
                                }]
                        });
                        pl.panic(`not a reference`);
                    }
                    return $[1];
                });
                const v_tail = mapOptional($.tail, ($) => {
                    return resolve_Value__Selection__Tail($, {
                        'variables': $p.variables,
                        'context': v_reference.dictionary.dictionary.type,
                        'imports': $p.imports,
                        'sibling global types': $p['sibling global types'],
                    });
                });
                return ['reference', {
                        'reference': v_reference,
                        'tail': v_tail,
                    }];
            });
            case 'state group': return pl.ss($, ($) => {
                const x = $['state group'];
                const v_state_group = pl.cc($p.context.type, ($) => {
                    if ($[0] !== 'state group') {
                        $se.onError({
                            'annotation': x,
                            'message': ['not the right state', {
                                    'found': $[0],
                                    'expected': `state group`
                                }]
                        });
                        pl.panic(`not a state group`);
                    }
                    return $[1];
                });
                const v_result_type = resolve_Global__Type__Selection($['result type'], {
                    'imports': $p.imports,
                    'sibling global types': $p['sibling global types']
                });
                const v_states = $.states.dictionary.__mapWithKey(($, key) => {
                    const v_state = getEntryForConstrainedDictionaryEntry(v_state_group.states, key, $.annotation);
                    return {
                        'constraints': {
                            'state': v_state,
                        },
                        'content': resolve_Any__Value__Selection($.content, {
                            'imports': $p.imports,
                            'sibling global types': $p['sibling global types'],
                            'context': v_state.type,
                            'variables': v_state.variables,
                        })
                    };
                });
                return ['state group', {
                        'state group': v_state_group,
                        'result type': v_result_type,
                        'states': v_states,
                    }];
            });
            default: return pl.au($[0]);
        }
    };
    const resolve_Type__Library = ($, $p) => {
        const v_imports = $.imports.dictionary.__mapWithKey(($, key) => {
            return {
                'constraints': {
                    'library': getEntryForConstrainedDictionaryEntry($p.imports, key, $.annotation)
                },
                'content': null
            };
        });
        const v_atom__types = $['atom types'].dictionary.map(($) => null);
        return {
            'imports': v_imports,
            'atom types': v_atom__types,
            'global types': $d.resolveDictionary($['global types'].dictionary, {
                'map': (($, $l) => {
                    const v_parameters = $.value.parameters.dictionary.map(($) => {
                        return {
                            'optional': pl.cc($.optional, ($) => {
                                switch ($[0]) {
                                    case 'no': return pl.ss($, ($) => ['no', null]);
                                    case 'yes': return pl.ss($, ($) => ['yes', null]);
                                    default: return pl.au($[0]);
                                }
                            }),
                            'type': resolve_Global__Type__Selection($.type, {
                                'imports': v_imports,
                                'sibling global types': $l['non circular siblings'],
                            })
                            // 'type': pl.cc($.type, ($) => {
                            //     return pl.cc($, ($) => {
                            //         switch ($[0]) {
                            //             // case 'lookup': return pl.ss($, ($): g_out.T.Parameters.D._ltype => ['lookup', {
                            //             //     'type': resolve_Global__Type__Selection($.content.type, {
                            //             //         'sibling global types': $l['non circular siblings'],
                            //             //         'imports': v_imports,
                            //             //     })
                            //             // }])
                            //             case 'resolved value': return pl.ss($, ($): g_out.T.Parameters.D._ltype => ['resolved value', {
                            //             }])
                            //             default: return pl.au($[0])
                            //         }
                            //     })
                            // })
                        };
                    });
                    const v_variables = resolve_Variables($.value.variables, {
                        'dictionary constraints': [false],
                        'parameters': [true, v_parameters],
                        'sibling properties': [false],
                        'state constraints': [false],
                        'parent variables': [false],
                    });
                    const v_type = resolve_Type($.value.type, {
                        'atom types': v_atom__types,
                        'imports': v_imports,
                        'sibling global types': $l['non circular siblings'],
                        'variables': v_variables,
                    });
                    const v_result = mapOptional($.value.result, ($) => {
                        return resolve_Any__Value__Selection($, {
                            'context': v_type,
                            'variables': v_variables,
                            'imports': v_imports,
                            'sibling global types': $l['non circular siblings']
                        });
                    });
                    return {
                        'parameters': v_parameters,
                        'variables': v_variables,
                        'type': v_type,
                        'result': v_result,
                    };
                })
            })
        };
    };
    const resolve_Root = ($, $p) => {
        return resolve_Model($, $p);
    };
    return ($) => {
        return resolve_Root($.root, {
            'imports': $.imports,
        });
    };
};
exports.$$ = $$;
