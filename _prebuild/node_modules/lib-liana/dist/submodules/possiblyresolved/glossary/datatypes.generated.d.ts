import * as pt from 'pareto-core-types';
export declare namespace N {
    namespace Any_$_$Value_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace start {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace tail {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Atom {
        namespace N {
            namespace G {
                namespace N {
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Atom_$_$Types {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Dictionary_$_$Constraints {
        namespace N {
            namespace D {
                namespace N {
                    namespace TU {
                        namespace N {
                            namespace dictionary {
                                namespace N {
                                    namespace G {
                                        namespace N {
                                            namespace dense {
                                                namespace N {
                                                    namespace TU {
                                                        namespace N {
                                                            namespace no {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N { }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                            namespace yes {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N { }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                            namespace dictionary {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Dictionary_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace dictionary {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Global_$_$Type {
        namespace N {
            namespace G {
                namespace N {
                    namespace parameters {
                        namespace N { }
                        namespace T { }
                    }
                    namespace result {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                    namespace variables {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Global_$_$Type_$_$Selection {
        namespace N {
            namespace TU {
                namespace N {
                    namespace _$limport {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace library {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace _$ltype {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace resolved_$_$sibling {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace _$ltype {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Global_$_$Types {
        namespace N {
            namespace D {
                namespace N { }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Imports {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Model {
        namespace N {
            namespace G {
                namespace N {
                    namespace root {
                        namespace N { }
                        namespace T { }
                    }
                    namespace type_$_$library {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace No_$_$Context_$_$Value_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace start {
                        namespace N { }
                        namespace T { }
                    }
                    namespace tail {
                        namespace N {
                            namespace O {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Parameters {
        namespace N {
            namespace D {
                namespace N {
                    namespace G {
                        namespace N {
                            namespace optional {
                                namespace N {
                                    namespace TU {
                                        namespace N {
                                            namespace no {
                                                namespace N {
                                                    namespace G {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                            namespace yes {
                                                namespace N {
                                                    namespace G {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                            namespace _$ltype {
                                namespace N { }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Property {
        namespace N {
            namespace G {
                namespace N {
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                    namespace variables {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Root {
        namespace N { }
        namespace T { }
    }
    namespace State_$_$Constraints {
        namespace N {
            namespace D {
                namespace N { }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace State_$_$Selection {
        namespace N {
            namespace G {
                namespace N {
                    namespace state {
                        namespace N { }
                        namespace T { }
                    }
                    namespace state_$_$group {
                        namespace N { }
                        namespace T { }
                    }
                    namespace _$ltype {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type {
        namespace N {
            namespace G {
                namespace N {
                    namespace _$ltype {
                        namespace N {
                            namespace TU {
                                namespace N {
                                    namespace array {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace atom {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace atom {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace component {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace arguments {
                                                        namespace N {
                                                            namespace D {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N {
                                                                            namespace _$ltype {
                                                                                namespace N {
                                                                                    namespace TU {
                                                                                        namespace N {
                                                                                            namespace resolved_$_$value {
                                                                                                namespace N { }
                                                                                                namespace T { }
                                                                                            }
                                                                                        }
                                                                                        namespace T { }
                                                                                    }
                                                                                }
                                                                                namespace T { }
                                                                            }
                                                                        }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace dictionary {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace constraints {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace key {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace variables {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace group {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace properties {
                                                        namespace N {
                                                            namespace D {
                                                                namespace N { }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace nothing {
                                        namespace N {
                                            namespace G {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace optional {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace constraints {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace _$ltype {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace variables {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace resolved_$_$reference {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace atom {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                    namespace dictionary {
                                                        namespace N { }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                    namespace state_$_$group {
                                        namespace N {
                                            namespace G {
                                                namespace N {
                                                    namespace states {
                                                        namespace N {
                                                            namespace D {
                                                                namespace N {
                                                                    namespace G {
                                                                        namespace N {
                                                                            namespace constraints {
                                                                                namespace N { }
                                                                                namespace T { }
                                                                            }
                                                                            namespace _$ltype {
                                                                                namespace N { }
                                                                                namespace T { }
                                                                            }
                                                                            namespace variables {
                                                                                namespace N { }
                                                                                namespace T { }
                                                                            }
                                                                        }
                                                                        namespace T { }
                                                                    }
                                                                }
                                                                namespace T { }
                                                            }
                                                        }
                                                        namespace T { }
                                                    }
                                                }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Type_$_$Library {
        namespace N {
            namespace G {
                namespace N {
                    namespace atom_$_$types {
                        namespace N { }
                        namespace T { }
                    }
                    namespace global_$_$types {
                        namespace N { }
                        namespace T { }
                    }
                    namespace imports {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Value_$_$Selection_$_$Tail {
        namespace N {
            namespace TU {
                namespace N {
                    namespace component {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace component {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace tail {
                                        namespace N {
                                            namespace O {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace group {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace group {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace property {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace tail {
                                        namespace N {
                                            namespace O {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace reference {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace reference {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace tail {
                                        namespace N {
                                            namespace O {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace state_$_$group {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace result_$_$type {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace state_$_$group {
                                        namespace N { }
                                        namespace T { }
                                    }
                                    namespace states {
                                        namespace N {
                                            namespace D {
                                                namespace N { }
                                                namespace T { }
                                            }
                                        }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Variable {
        namespace N {
            namespace TU {
                namespace N {
                    namespace dictionary_$_$constraint {
                        namespace N { }
                        namespace T { }
                    }
                    namespace parameter {
                        namespace N {
                            namespace G {
                                namespace N {
                                    namespace parameter {
                                        namespace N { }
                                        namespace T { }
                                    }
                                }
                                namespace T { }
                            }
                        }
                        namespace T { }
                    }
                    namespace parent_$_$variable {
                        namespace N { }
                        namespace T { }
                    }
                    namespace sibling_$_$property {
                        namespace N { }
                        namespace T { }
                    }
                    namespace state_$_$constraint {
                        namespace N { }
                        namespace T { }
                    }
                }
                namespace T { }
            }
        }
        namespace T { }
    }
    namespace Variables {
        namespace N {
            namespace D {
                namespace N { }
                namespace T { }
            }
        }
        namespace T { }
    }
}
export declare namespace T {
    namespace Any__Value__Selection {
        namespace start {
            namespace O {
                type key = string;
                namespace referent {
                    type O = T.Variables.D;
                }
                type referent = [false] | [true, T.Variables.D];
            }
            type O = {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Variables.D];
            };
        }
        type start = [false] | [
            true,
            {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Variables.D];
            }
        ];
        namespace tail {
            type O = T.Value__Selection__Tail;
        }
        type tail = [false] | [true, T.Value__Selection__Tail];
    }
    type Any__Value__Selection = {
        readonly 'start': [false] | [
            true,
            {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Variables.D];
            }
        ];
        readonly 'tail': [false] | [true, T.Value__Selection__Tail];
    };
    namespace Atom {
        namespace _ltype {
            type key = string;
            namespace referent {
                type O = T.Atom__Types.D;
            }
            type referent = [false] | [true, T.Atom__Types.D];
        }
        type _ltype = {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Atom__Types.D];
        };
    }
    type Atom = {
        readonly 'type': {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Atom__Types.D];
        };
    };
    namespace Atom__Types {
        namespace D { }
        type D = null;
    }
    type Atom__Types = pt.Dictionary<null>;
    namespace Dictionary__Constraints {
        namespace D {
            namespace dictionary {
                namespace dense {
                    namespace no { }
                    type no = null;
                    namespace yes { }
                    type yes = null;
                }
                type dense = ['no', null] | ['yes', null];
                type dictionary = T.Dictionary__Selection;
            }
            type dictionary = {
                readonly 'dense': ['no', null] | ['yes', null];
                readonly 'dictionary': T.Dictionary__Selection;
            };
        }
        type D = [
            'dictionary',
            {
                readonly 'dense': ['no', null] | ['yes', null];
                readonly 'dictionary': T.Dictionary__Selection;
            }
        ];
    }
    type Dictionary__Constraints = pt.Dictionary<[
        'dictionary',
        {
            readonly 'dense': ['no', null] | ['yes', null];
            readonly 'dictionary': T.Dictionary__Selection;
        }
    ]>;
    namespace Dictionary__Selection {
        namespace dictionary {
            type O = T.Type._ltype.dictionary;
        }
        type dictionary = [false] | [true, T.Type._ltype.dictionary];
        type _ltype = T.No__Context__Value__Selection;
    }
    type Dictionary__Selection = {
        readonly 'dictionary': [false] | [true, T.Type._ltype.dictionary];
        readonly 'type': T.No__Context__Value__Selection;
    };
    namespace Global__Type {
        type parameters = T.Parameters;
        namespace result {
            type O = T.Any__Value__Selection;
        }
        type result = [false] | [true, T.Any__Value__Selection];
        type _ltype = T.Type;
        type variables = T.Variables;
    }
    type Global__Type = {
        readonly 'parameters': T.Parameters;
        readonly 'result': [false] | [true, T.Any__Value__Selection];
        readonly 'type': T.Type;
        readonly 'variables': T.Variables;
    };
    namespace Global__Type__Selection {
        namespace _limport {
            namespace library {
                type key = string;
                namespace referent {
                    type O = T.Imports.D;
                }
                type referent = [false] | [true, T.Imports.D];
            }
            type library = {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Imports.D];
            };
            namespace _ltype {
                type key = string;
                namespace referent {
                    type O = T.Global__Types.D;
                }
                type referent = [false] | [true, T.Global__Types.D];
            }
            type _ltype = {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Global__Types.D];
            };
        }
        type _limport = {
            readonly 'library': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Imports.D];
            };
            readonly 'type': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Global__Types.D];
            };
        };
        namespace resolved__sibling {
            namespace _ltype {
                type key = string;
                namespace referent {
                    type O = T.Global__Type;
                }
                type referent = [false] | [true, T.Global__Type];
            }
            type _ltype = {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Global__Type];
            };
        }
        type resolved__sibling = {
            readonly 'type': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Global__Type];
            };
        };
    }
    type Global__Type__Selection = [
        'import',
        {
            readonly 'library': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Imports.D];
            };
            readonly 'type': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Global__Types.D];
            };
        }
    ] | [
        'resolved sibling',
        {
            readonly 'type': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Global__Type];
            };
        }
    ];
    namespace Global__Types {
        type D = T.Global__Type;
    }
    type Global__Types = pt.Dictionary<T.Global__Type>;
    namespace Imports {
        namespace D {
            namespace constraints {
                namespace O {
                    type library = T.Type__Library;
                }
                type O = {
                    readonly 'library': T.Type__Library;
                };
            }
            type constraints = [false] | [
                true,
                {
                    readonly 'library': T.Type__Library;
                }
            ];
            namespace content { }
            type content = null;
        }
        type D = {
            readonly 'constraints': [false] | [
                true,
                {
                    readonly 'library': T.Type__Library;
                }
            ];
            readonly 'content': null;
        };
    }
    type Imports = pt.Dictionary<{
        readonly 'constraints': [false] | [
            true,
            {
                readonly 'library': T.Type__Library;
            }
        ];
        readonly 'content': null;
    }>;
    namespace Model {
        namespace root {
            type key = string;
            namespace referent {
                type O = T.Global__Types.D;
            }
            type referent = [false] | [true, T.Global__Types.D];
        }
        type root = {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Global__Types.D];
        };
        type type__library = T.Type__Library;
    }
    type Model = {
        readonly 'root': {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Global__Types.D];
        };
        readonly 'type library': T.Type__Library;
    };
    namespace No__Context__Value__Selection {
        namespace start {
            type key = string;
            namespace referent {
                type O = T.Variables.D;
            }
            type referent = [false] | [true, T.Variables.D];
        }
        type start = {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Variables.D];
        };
        namespace tail {
            type O = T.Value__Selection__Tail;
        }
        type tail = [false] | [true, T.Value__Selection__Tail];
    }
    type No__Context__Value__Selection = {
        readonly 'start': {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Variables.D];
        };
        readonly 'tail': [false] | [true, T.Value__Selection__Tail];
    };
    namespace Parameters {
        namespace D {
            namespace optional {
                namespace no { }
                type no = null;
                namespace yes { }
                type yes = null;
            }
            type optional = ['no', null] | ['yes', null];
            type _ltype = T.Global__Type__Selection;
        }
        type D = {
            readonly 'optional': ['no', null] | ['yes', null];
            readonly 'type': T.Global__Type__Selection;
        };
    }
    type Parameters = pt.Dictionary<{
        readonly 'optional': ['no', null] | ['yes', null];
        readonly 'type': T.Global__Type__Selection;
    }>;
    namespace Property {
        type _ltype = T.Type;
        type variables = T.Variables;
    }
    type Property = {
        readonly 'type': T.Type;
        readonly 'variables': T.Variables;
    };
    type Root = T.Model;
    namespace State__Constraints {
        type D = T.State__Selection;
    }
    type State__Constraints = pt.Dictionary<T.State__Selection>;
    namespace State__Selection {
        namespace state {
            type key = string;
            namespace referent {
                type O = T.Type._ltype.state__group.states.D;
            }
            type referent = [false] | [true, T.Type._ltype.state__group.states.D];
        }
        type state = {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Type._ltype.state__group.states.D];
        };
        namespace state__group {
            type O = T.Type._ltype.state__group;
        }
        type state__group = [false] | [true, T.Type._ltype.state__group];
        type _ltype = T.No__Context__Value__Selection;
    }
    type State__Selection = {
        readonly 'state': {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Type._ltype.state__group.states.D];
        };
        readonly 'state group': [false] | [true, T.Type._ltype.state__group];
        readonly 'type': T.No__Context__Value__Selection;
    };
    namespace Type {
        namespace _ltype {
            namespace array {
                type _ltype = T.Type;
            }
            type array = {
                readonly 'type': T.Type;
            };
            namespace atom {
                type atom = T.Atom;
            }
            type atom = {
                readonly 'atom': T.Atom;
            };
            namespace component {
                namespace arguments {
                    namespace D {
                        namespace constraints {
                            namespace O {
                                type parameter = T.Parameters.D;
                            }
                            type O = {
                                readonly 'parameter': T.Parameters.D;
                            };
                        }
                        type constraints = [false] | [
                            true,
                            {
                                readonly 'parameter': T.Parameters.D;
                            }
                        ];
                        namespace content {
                            namespace _ltype {
                                type resolved__value = T.No__Context__Value__Selection;
                            }
                            type _ltype = ['resolved value', T.No__Context__Value__Selection];
                        }
                        type content = {
                            readonly 'type': ['resolved value', T.No__Context__Value__Selection];
                        };
                    }
                    type D = {
                        readonly 'constraints': [false] | [
                            true,
                            {
                                readonly 'parameter': T.Parameters.D;
                            }
                        ];
                        readonly 'content': {
                            readonly 'type': ['resolved value', T.No__Context__Value__Selection];
                        };
                    };
                }
                type arguments = pt.Dictionary<{
                    readonly 'constraints': [false] | [
                        true,
                        {
                            readonly 'parameter': T.Parameters.D;
                        }
                    ];
                    readonly 'content': {
                        readonly 'type': ['resolved value', T.No__Context__Value__Selection];
                    };
                }>;
                type _ltype = T.Global__Type__Selection;
            }
            type component = {
                readonly 'arguments': pt.Dictionary<{
                    readonly 'constraints': [false] | [
                        true,
                        {
                            readonly 'parameter': T.Parameters.D;
                        }
                    ];
                    readonly 'content': {
                        readonly 'type': ['resolved value', T.No__Context__Value__Selection];
                    };
                }>;
                readonly 'type': T.Global__Type__Selection;
            };
            namespace dictionary {
                type constraints = T.Dictionary__Constraints;
                type key = T.Atom;
                type _ltype = T.Type;
                type variables = T.Variables;
            }
            type dictionary = {
                readonly 'constraints': T.Dictionary__Constraints;
                readonly 'key': T.Atom;
                readonly 'type': T.Type;
                readonly 'variables': T.Variables;
            };
            namespace group {
                namespace properties {
                    type D = T.Property;
                }
                type properties = pt.Dictionary<T.Property>;
            }
            type group = {
                readonly 'properties': pt.Dictionary<T.Property>;
            };
            namespace nothing { }
            type nothing = null;
            namespace optional {
                type constraints = T.State__Constraints;
                type _ltype = T.Type;
                type variables = T.Variables;
            }
            type optional = {
                readonly 'constraints': T.State__Constraints;
                readonly 'type': T.Type;
                readonly 'variables': T.Variables;
            };
            namespace resolved__reference {
                type atom = T.Atom;
                type dictionary = T.Dictionary__Selection;
            }
            type resolved__reference = {
                readonly 'atom': T.Atom;
                readonly 'dictionary': T.Dictionary__Selection;
            };
            namespace state__group {
                namespace states {
                    namespace D {
                        type constraints = T.State__Constraints;
                        type _ltype = T.Type;
                        type variables = T.Variables;
                    }
                    type D = {
                        readonly 'constraints': T.State__Constraints;
                        readonly 'type': T.Type;
                        readonly 'variables': T.Variables;
                    };
                }
                type states = pt.Dictionary<{
                    readonly 'constraints': T.State__Constraints;
                    readonly 'type': T.Type;
                    readonly 'variables': T.Variables;
                }>;
            }
            type state__group = {
                readonly 'states': pt.Dictionary<{
                    readonly 'constraints': T.State__Constraints;
                    readonly 'type': T.Type;
                    readonly 'variables': T.Variables;
                }>;
            };
        }
        type _ltype = [
            'array',
            {
                readonly 'type': T.Type;
            }
        ] | [
            'atom',
            {
                readonly 'atom': T.Atom;
            }
        ] | [
            'component',
            {
                readonly 'arguments': pt.Dictionary<{
                    readonly 'constraints': [false] | [
                        true,
                        {
                            readonly 'parameter': T.Parameters.D;
                        }
                    ];
                    readonly 'content': {
                        readonly 'type': ['resolved value', T.No__Context__Value__Selection];
                    };
                }>;
                readonly 'type': T.Global__Type__Selection;
            }
        ] | [
            'dictionary',
            {
                readonly 'constraints': T.Dictionary__Constraints;
                readonly 'key': T.Atom;
                readonly 'type': T.Type;
                readonly 'variables': T.Variables;
            }
        ] | [
            'group',
            {
                readonly 'properties': pt.Dictionary<T.Property>;
            }
        ] | ['nothing', null] | [
            'optional',
            {
                readonly 'constraints': T.State__Constraints;
                readonly 'type': T.Type;
                readonly 'variables': T.Variables;
            }
        ] | [
            'resolved reference',
            {
                readonly 'atom': T.Atom;
                readonly 'dictionary': T.Dictionary__Selection;
            }
        ] | [
            'state group',
            {
                readonly 'states': pt.Dictionary<{
                    readonly 'constraints': T.State__Constraints;
                    readonly 'type': T.Type;
                    readonly 'variables': T.Variables;
                }>;
            }
        ];
    }
    type Type = {
        readonly 'type': [
            'array',
            {
                readonly 'type': T.Type;
            }
        ] | [
            'atom',
            {
                readonly 'atom': T.Atom;
            }
        ] | [
            'component',
            {
                readonly 'arguments': pt.Dictionary<{
                    readonly 'constraints': [false] | [
                        true,
                        {
                            readonly 'parameter': T.Parameters.D;
                        }
                    ];
                    readonly 'content': {
                        readonly 'type': ['resolved value', T.No__Context__Value__Selection];
                    };
                }>;
                readonly 'type': T.Global__Type__Selection;
            }
        ] | [
            'dictionary',
            {
                readonly 'constraints': T.Dictionary__Constraints;
                readonly 'key': T.Atom;
                readonly 'type': T.Type;
                readonly 'variables': T.Variables;
            }
        ] | [
            'group',
            {
                readonly 'properties': pt.Dictionary<T.Property>;
            }
        ] | ['nothing', null] | [
            'optional',
            {
                readonly 'constraints': T.State__Constraints;
                readonly 'type': T.Type;
                readonly 'variables': T.Variables;
            }
        ] | [
            'resolved reference',
            {
                readonly 'atom': T.Atom;
                readonly 'dictionary': T.Dictionary__Selection;
            }
        ] | [
            'state group',
            {
                readonly 'states': pt.Dictionary<{
                    readonly 'constraints': T.State__Constraints;
                    readonly 'type': T.Type;
                    readonly 'variables': T.Variables;
                }>;
            }
        ];
    };
    namespace Type__Library {
        type atom__types = T.Atom__Types;
        type global__types = T.Global__Types;
        type imports = T.Imports;
    }
    type Type__Library = {
        readonly 'atom types': T.Atom__Types;
        readonly 'global types': T.Global__Types;
        readonly 'imports': T.Imports;
    };
    namespace Value__Selection__Tail {
        namespace component {
            namespace component {
                type O = T.Type._ltype.component;
            }
            type component = [false] | [true, T.Type._ltype.component];
            namespace tail {
                type O = T.Value__Selection__Tail;
            }
            type tail = [false] | [true, T.Value__Selection__Tail];
        }
        type component = {
            readonly 'component': [false] | [true, T.Type._ltype.component];
            readonly 'tail': [false] | [true, T.Value__Selection__Tail];
        };
        namespace group {
            namespace group {
                type O = T.Type._ltype.group;
            }
            type group = [false] | [true, T.Type._ltype.group];
            namespace property {
                type key = string;
                namespace referent {
                    type O = T.Type._ltype.group.properties.D;
                }
                type referent = [false] | [true, T.Type._ltype.group.properties.D];
            }
            type property = {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Type._ltype.group.properties.D];
            };
            namespace tail {
                type O = T.Value__Selection__Tail;
            }
            type tail = [false] | [true, T.Value__Selection__Tail];
        }
        type group = {
            readonly 'group': [false] | [true, T.Type._ltype.group];
            readonly 'property': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Type._ltype.group.properties.D];
            };
            readonly 'tail': [false] | [true, T.Value__Selection__Tail];
        };
        namespace reference {
            namespace reference {
                type O = T.Type._ltype.resolved__reference;
            }
            type reference = [false] | [true, T.Type._ltype.resolved__reference];
            namespace tail {
                type O = T.Value__Selection__Tail;
            }
            type tail = [false] | [true, T.Value__Selection__Tail];
        }
        type reference = {
            readonly 'reference': [false] | [true, T.Type._ltype.resolved__reference];
            readonly 'tail': [false] | [true, T.Value__Selection__Tail];
        };
        namespace state__group {
            type result__type = T.Global__Type__Selection;
            namespace state__group {
                type O = T.Type._ltype.state__group;
            }
            type state__group = [false] | [true, T.Type._ltype.state__group];
            namespace states {
                namespace D {
                    namespace constraints {
                        namespace O {
                            type state = T.Type._ltype.state__group.states.D;
                        }
                        type O = {
                            readonly 'state': T.Type._ltype.state__group.states.D;
                        };
                    }
                    type constraints = [false] | [
                        true,
                        {
                            readonly 'state': T.Type._ltype.state__group.states.D;
                        }
                    ];
                    type content = T.Any__Value__Selection;
                }
                type D = {
                    readonly 'constraints': [false] | [
                        true,
                        {
                            readonly 'state': T.Type._ltype.state__group.states.D;
                        }
                    ];
                    readonly 'content': T.Any__Value__Selection;
                };
            }
            type states = pt.Dictionary<{
                readonly 'constraints': [false] | [
                    true,
                    {
                        readonly 'state': T.Type._ltype.state__group.states.D;
                    }
                ];
                readonly 'content': T.Any__Value__Selection;
            }>;
        }
        type state__group = {
            readonly 'result type': T.Global__Type__Selection;
            readonly 'state group': [false] | [true, T.Type._ltype.state__group];
            readonly 'states': pt.Dictionary<{
                readonly 'constraints': [false] | [
                    true,
                    {
                        readonly 'state': T.Type._ltype.state__group.states.D;
                    }
                ];
                readonly 'content': T.Any__Value__Selection;
            }>;
        };
    }
    type Value__Selection__Tail = [
        'component',
        {
            readonly 'component': [false] | [true, T.Type._ltype.component];
            readonly 'tail': [false] | [true, T.Value__Selection__Tail];
        }
    ] | [
        'group',
        {
            readonly 'group': [false] | [true, T.Type._ltype.group];
            readonly 'property': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Type._ltype.group.properties.D];
            };
            readonly 'tail': [false] | [true, T.Value__Selection__Tail];
        }
    ] | [
        'reference',
        {
            readonly 'reference': [false] | [true, T.Type._ltype.resolved__reference];
            readonly 'tail': [false] | [true, T.Value__Selection__Tail];
        }
    ] | [
        'state group',
        {
            readonly 'result type': T.Global__Type__Selection;
            readonly 'state group': [false] | [true, T.Type._ltype.state__group];
            readonly 'states': pt.Dictionary<{
                readonly 'constraints': [false] | [
                    true,
                    {
                        readonly 'state': T.Type._ltype.state__group.states.D;
                    }
                ];
                readonly 'content': T.Any__Value__Selection;
            }>;
        }
    ];
    namespace Variable {
        namespace dictionary__constraint {
            type key = string;
            namespace referent {
                type O = T.Dictionary__Constraints.D;
            }
            type referent = [false] | [true, T.Dictionary__Constraints.D];
        }
        type dictionary__constraint = {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Dictionary__Constraints.D];
        };
        namespace parameter {
            namespace parameter {
                type key = string;
                namespace referent {
                    type O = T.Parameters.D;
                }
                type referent = [false] | [true, T.Parameters.D];
            }
            type parameter = {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Parameters.D];
            };
        }
        type parameter = {
            readonly 'parameter': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Parameters.D];
            };
        };
        namespace parent__variable {
            type key = string;
            namespace referent {
                type O = T.Variable;
            }
            type referent = [false] | [true, T.Variable];
        }
        type parent__variable = {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Variable];
        };
        namespace sibling__property {
            type key = string;
            namespace referent {
                type O = T.Property;
            }
            type referent = [false] | [true, T.Property];
        }
        type sibling__property = {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Property];
        };
        namespace state__constraint {
            type key = string;
            namespace referent {
                type O = T.State__Constraints.D;
            }
            type referent = [false] | [true, T.State__Constraints.D];
        }
        type state__constraint = {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.State__Constraints.D];
        };
    }
    type Variable = [
        'dictionary constraint',
        {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Dictionary__Constraints.D];
        }
    ] | [
        'parameter',
        {
            readonly 'parameter': {
                readonly 'key': string;
                readonly 'referent': [false] | [true, T.Parameters.D];
            };
        }
    ] | [
        'parent variable',
        {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Variable];
        }
    ] | [
        'sibling property',
        {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.Property];
        }
    ] | [
        'state constraint',
        {
            readonly 'key': string;
            readonly 'referent': [false] | [true, T.State__Constraints.D];
        }
    ];
    namespace Variables {
        type D = T.Variable;
    }
    type Variables = pt.Dictionary<T.Variable>;
}
