import { T } from "./datatypes.generated";
import * as g_common from "glo-pareto-common";
export declare namespace ASYNC {
    namespace I {
        type Error = {
            'data': ($: T.Error) => void;
            'end': () => void;
        };
    }
    namespace A { }
}
export declare namespace SYNC {
    namespace A {
        namespace F {
            type Contains = <TType>($: T.DictionaryAndKey<TType>) => g_common.T.Boolean;
        }
        namespace F {
            type Filter = <TType>($: T.FilterableDictionary<TType>) => T.Dictionary<TType>;
        }
        namespace F {
            type IsEmpty = <TType>($: T.Dictionary<TType>) => g_common.T.Boolean;
        }
        namespace F {
            type MergeAndIgnore = <TType>($: T.MergeParameters<TType>) => T.Dictionary<TType>;
        }
        namespace F {
            type MergeAndOverwrite = <TType>($: T.MergeParameters<TType>) => T.Dictionary<TType>;
        }
        namespace F {
            type MergeDictionaries = <TType>($: T.MergeDictionariesParameters<TType>) => T.Dictionary<TType>;
        }
        namespace F {
            type UnsafeAddEntry = <TType>($: T.UnsafeAddEntryParameters<TType>) => T.Dictionary<TType>;
        }
        namespace F {
            type UnsafeMerge = <TType>($: T.MergeParameters<TType>) => T.Dictionary<TType>;
        }
        namespace F {
            type UnsafeRekey = <TType>($: T.Dictionary<TType>, $c: {
                'map': ($: T.KeyValuePair<TType>) => g_common.T.String;
            }) => T.Dictionary<TType>;
        }
    }
}
